/*!
 * VERSION: 1.13.1
 * DATE: 2014-07-19
 * UPDATES AND DOCS AT: http://www.greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

/*! jQuery v2.1.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */

/*!
 * matter-0.8.0.js 0.8.0-alpha 2014-05-04
 * http://brm.io/matter-js/
 * License: MIT
 */

// threejs.org/license

var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
		_gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, n) {
				var r = function(e) {
						var t, n = [],
							r = e.length;
						for(t = 0; t !== r; n.push(e[t++]));
						return n
					},
					i = function(e, t, r) {
						n.call(this, e, t, r), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = i.prototype.render
					},
					s = 1e-10,
					o = n._internals,
					u = o.isSelector,
					a = o.isArray,
					f = i.prototype = n.to({}, .1, {}),
					l = [];
				i.version = "1.13.1", f.constructor = i, f.kill()._gc = !1, i.killTweensOf = i.killDelayedCallsTo = n.killTweensOf, i.getTweensOf = n.getTweensOf, i.lagSmoothing = n.lagSmoothing, i.ticker = n.ticker, i.render = n.render, f.invalidate = function() {
					return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), n.prototype.invalidate.call(this)
				}, f.updateTo = function(e, t) {
					var r, i = this.ratio;
					t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
					for(r in e) this.vars[r] = e[r];
					if(this._initted)
						if(t) this._initted = !1;
						else if(this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
						var s = this._time;
						this.render(0, !0, !1), this._initted = !1, this.render(s, !0, !1)
					} else if(this._time > 0) {
						this._initted = !1, this._init();
						for(var o, u = 1 / (1 - i), a = this._firstPT; a;) o = a.s + a.c, a.c *= u, a.s = o - a.c, a = a._next
					}
					return this
				}, f.render = function(e, t, n) {
					this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
					var r, i, u, a, f, c, h, p, d = this._dirty ? this.totalDuration() : this._totalDuration,
						v = this._time,
						m = this._totalTime,
						g = this._cycle,
						y = this._duration,
						b = this._rawPrevTime;
					if(e >= d ? (this._totalTime = d, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, i = "onComplete"), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (0 === e || 0 > b || b === s) && b !== e && (n = !0, b > s && (i = "onReverseComplete")), this._rawPrevTime = p = !t || e || b === e ? e : s)) : 1e-7 > e ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== m || 0 === y && b > 0 && b !== s) && (i = "onReverseComplete", r = this._reversed), 0 > e ? (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (b >= 0 && (n = !0), this._rawPrevTime = p = !t || e || b === e ? e : s)) : this._initted || (n = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (a = y + this._repeatDelay, this._cycle = this._totalTime / a >> 0, 0 !== this._cycle && this._cycle === this._totalTime / a && this._cycle--, this._time = this._totalTime - this._cycle * a, this._yoyo && 0 !== (1 & this._cycle) && (this._time = y - this._time), this._time > y ? this._time = y : 0 > this._time && (this._time = 0)), this._easeType ? (f = this._time / y, c = this._easeType, h = this._easePower, (1 === c || 3 === c && f >= .5) && (f = 1 - f), 3 === c && (f *= 2), 1 === h ? f *= f : 2 === h ? f *= f * f : 3 === h ? f *= f * f * f : 4 === h && (f *= f * f * f * f), this.ratio = 1 === c ? 1 - f : 2 === c ? f : .5 > this._time / y ? f / 2 : 1 - f / 2) : this.ratio = this._ease.getRatio(this._time / y)), v === this._time && !n && g === this._cycle) return m !== this._totalTime && this._onUpdate && (t || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l)), void 0;
					if(!this._initted) {
						if(this._init(), !this._initted || this._gc) return;
						if(!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = v, this._totalTime = m, this._rawPrevTime = b, this._cycle = g, o.lazyTweens.push(this), this._lazy = e, void 0;
						this._time && !r ? this.ratio = this._ease.getRatio(this._time / y) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
					}
					for(this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== v && e >= 0 && (this._active = !0), 0 === m && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, t, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === y) && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || l))), u = this._firstPT; u;) u.f ? u.t[u.p](u.c * this.ratio + u.s) : u.t[u.p] = u.c * this.ratio + u.s, u = u._next;
					this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, n), t || (this._totalTime !== m || r) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l)), this._cycle !== g && (t || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || l)), i && (!this._gc || n) && (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this.vars[i].apply(this.vars[i + "Scope"] || this, this.vars[i + "Params"] || l), 0 === y && this._rawPrevTime === s && p !== s && (this._rawPrevTime = 0))
				}, i.to = function(e, t, n) {
					return new i(e, t, n)
				}, i.from = function(e, t, n) {
					return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new i(e, t, n)
				}, i.fromTo = function(e, t, n, r) {
					return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new i(e, t, r)
				}, i.staggerTo = i.allTo = function(e, t, s, o, f, c, h) {
					o = o || 0;
					var p, d, v, m, g = s.delay || 0,
						y = [],
						b = function() {
							s.onComplete && s.onComplete.apply(s.onCompleteScope || this, arguments), f.apply(h || this, c || l)
						};
					for(a(e) || ("string" == typeof e && (e = n.selector(e) || e), u(e) && (e = r(e))), p = e.length, v = 0; p > v; v++) {
						d = {};
						for(m in s) d[m] = s[m];
						d.delay = g, v === p - 1 && f && (d.onComplete = b), y[v] = new i(e[v], t, d), g += o
					}
					return y
				}, i.staggerFrom = i.allFrom = function(e, t, n, r, s, o, u) {
					return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, i.staggerTo(e, t, n, r, s, o, u)
				}, i.staggerFromTo = i.allFromTo = function(e, t, n, r, s, o, u, a) {
					return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, i.staggerTo(e, t, r, s, o, u, a)
				}, i.delayedCall = function(e, t, n, r, s) {
					return new i(t, 0, {
						delay: e,
						onComplete: t,
						onCompleteParams: n,
						onCompleteScope: r,
						onReverseComplete: t,
						onReverseCompleteParams: n,
						onReverseCompleteScope: r,
						immediateRender: !1,
						useFrames: s,
						overwrite: 0
					})
				}, i.set = function(e, t) {
					return new i(e, 0, t)
				}, i.isTweening = function(e) {
					return n.getTweensOf(e, !0).length > 0
				};
				var c = function(e, t) {
						for(var r = [], i = 0, s = e._first; s;) s instanceof n ? r[i++] = s : (t && (r[i++] = s), r = r.concat(c(s, t)), i = r.length), s = s._next;
						return r
					},
					h = i.getAllTweens = function(t) {
						return c(e._rootTimeline, t).concat(c(e._rootFramesTimeline, t))
					};
				i.killAll = function(e, n, r, i) {
					null == n && (n = !0), null == r && (r = !0);
					var s, o, u, a = h(0 != i),
						f = a.length,
						l = n && r && i;
					for(u = 0; f > u; u++) o = a[u], (l || o instanceof t || (s = o.target === o.vars.onComplete) && r || n && !s) && (e ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
				}, i.killChildTweensOf = function(e, t) {
					if(null != e) {
						var s, f, l, c, h, p = o.tweenLookup;
						if("string" == typeof e && (e = n.selector(e) || e), u(e) && (e = r(e)), a(e))
							for(c = e.length; --c > -1;) i.killChildTweensOf(e[c], t);
						else {
							s = [];
							for(l in p)
								for(f = p[l].target.parentNode; f;) f === e && (s = s.concat(p[l].tweens)), f = f.parentNode;
							for(h = s.length, c = 0; h > c; c++) t && s[c].totalTime(s[c].totalDuration()), s[c]._enabled(!1, !1)
						}
					}
				};
				var p = function(e, n, r, i) {
					n = n !== !1, r = r !== !1, i = i !== !1;
					for(var s, o, u = h(i), a = n && r && i, f = u.length; --f > -1;) o = u[f], (a || o instanceof t || (s = o.target === o.vars.onComplete) && r || n && !s) && o.paused(e)
				};
				return i.pauseAll = function(e, t, n) {
					p(!0, e, t, n)
				}, i.resumeAll = function(e, t, n) {
					p(!1, e, t, n)
				}, i.globalTimeScale = function(t) {
					var r = e._rootTimeline,
						i = n.ticker.time;
					return arguments.length ? (t = t || s, r._startTime = i - (i - r._startTime) * r._timeScale / t, r = e._rootFramesTimeline, i = n.ticker.frame, r._startTime = i - (i - r._startTime) * r._timeScale / t, r._timeScale = e._rootTimeline._timeScale = t, t) : r._timeScale
				}, f.progress = function(e) {
					return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
				}, f.totalProgress = function(e) {
					return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
				}, f.time = function(e, t) {
					return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
				}, f.duration = function(t) {
					return arguments.length ? e.prototype.duration.call(this, t) : this._duration
				}, f.totalDuration = function(e) {
					return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
				}, f.repeat = function(e) {
					return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
				}, f.repeatDelay = function(e) {
					return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
				}, f.yoyo = function(e) {
					return arguments.length ? (this._yoyo = e, this) : this._yoyo
				}, i
			}, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, n) {
				var r = function(e) {
						t.call(this, e), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
						var n, r, i = this.vars;
						for(r in i) n = i[r], u(n) && -1 !== n.join("").indexOf("{self}") && (i[r] = this._swapSelfInParams(n));
						u(i.tweens) && this.add(i.tweens, 0, i.align, i.stagger)
					},
					i = 1e-10,
					s = n._internals,
					o = s.isSelector,
					u = s.isArray,
					a = s.lazyTweens,
					f = s.lazyRender,
					l = [],
					c = _gsScope._gsDefine.globals,
					h = function(e) {
						var t, n = {};
						for(t in e) n[t] = e[t];
						return n
					},
					p = function(e, t, n, r) {
						e._timeline.pause(e._startTime), t && t.apply(r || e._timeline, n || l)
					},
					d = function(e) {
						var t, n = [],
							r = e.length;
						for(t = 0; t !== r; n.push(e[t++]));
						return n
					},
					v = r.prototype = new t;
				return r.version = "1.13.1", v.constructor = r, v.kill()._gc = !1, v.to = function(e, t, r, i) {
					var s = r.repeat && c.TweenMax || n;
					return t ? this.add(new s(e, t, r), i) : this.set(e, r, i)
				}, v.from = function(e, t, r, i) {
					return this.add((r.repeat && c.TweenMax || n).from(e, t, r), i)
				}, v.fromTo = function(e, t, r, i, s) {
					var o = i.repeat && c.TweenMax || n;
					return t ? this.add(o.fromTo(e, t, r, i), s) : this.set(e, i, s)
				}, v.staggerTo = function(e, t, i, s, u, a, f, l) {
					var c, p = new r({
						onComplete: a,
						onCompleteParams: f,
						onCompleteScope: l,
						smoothChildTiming: this.smoothChildTiming
					});
					for("string" == typeof e && (e = n.selector(e) || e), o(e) && (e = d(e)), s = s || 0, c = 0; e.length > c; c++) i.startAt && (i.startAt = h(i.startAt)), p.to(e[c], t, h(i), c * s);
					return this.add(p, u)
				}, v.staggerFrom = function(e, t, n, r, i, s, o, u) {
					return n.immediateRender = 0 != n.immediateRender, n.runBackwards = !0, this.staggerTo(e, t, n, r, i, s, o, u)
				}, v.staggerFromTo = function(e, t, n, r, i, s, o, u, a) {
					return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, this.staggerTo(e, t, r, i, s, o, u, a)
				}, v.call = function(e, t, r, i) {
					return this.add(n.delayedCall(0, e, t, r), i)
				}, v.set = function(e, t, r) {
					return r = this._parseTimeOrLabel(r, 0, !0), null == t.immediateRender && (t.immediateRender = r === this._time && !this._paused), this.add(new n(e, 0, t), r)
				}, r.exportRoot = function(e, t) {
					e = e || {}, null == e.smoothChildTiming && (e.smoothChildTiming = !0);
					var i, s, o = new r(e),
						u = o._timeline;
					for(null == t && (t = !0), u._remove(o, !0), o._startTime = 0, o._rawPrevTime = o._time = o._totalTime = u._time, i = u._first; i;) s = i._next, t && i instanceof n && i.target === i.vars.onComplete || o.add(i, i._startTime - i._delay), i = s;
					return u.add(o, 0), o
				}, v.add = function(i, s, o, a) {
					var f, l, c, h, p, d;
					if("number" != typeof s && (s = this._parseTimeOrLabel(s, 0, !0, i)), !(i instanceof e)) {
						if(i instanceof Array || i && i.push && u(i)) {
							for(o = o || "normal", a = a || 0, f = s, l = i.length, c = 0; l > c; c++) u(h = i[c]) && (h = new r({
								tweens: h
							})), this.add(h, f), "string" != typeof h && "function" != typeof h && ("sequence" === o ? f = h._startTime + h.totalDuration() / h._timeScale : "start" === o && (h._startTime -= h.delay())), f += a;
							return this._uncache(!0)
						}
						if("string" == typeof i) return this.addLabel(i, s);
						if("function" != typeof i) throw "Cannot add " + i + " into the timeline; it is not a tween, timeline, function, or string.";
						i = n.delayedCall(0, i)
					}
					if(t.prototype.add.call(this, i, s), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
						for(p = this, d = p.rawTime() > i._startTime; p._timeline;) d && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
					return this
				}, v.remove = function(t) {
					if(t instanceof e) return this._remove(t, !1);
					if(t instanceof Array || t && t.push && u(t)) {
						for(var n = t.length; --n > -1;) this.remove(t[n]);
						return this
					}
					return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
				}, v._remove = function(e, n) {
					t.prototype._remove.call(this, e, n);
					var r = this._last;
					return r ? this._time > r._startTime + r._totalDuration / r._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
				}, v.append = function(e, t) {
					return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
				}, v.insert = v.insertMultiple = function(e, t, n, r) {
					return this.add(e, t || 0, n, r)
				}, v.appendMultiple = function(e, t, n, r) {
					return this.add(e, this._parseTimeOrLabel(null, t, !0, e), n, r)
				}, v.addLabel = function(e, t) {
					return this._labels[e] = this._parseTimeOrLabel(t), this
				}, v.addPause = function(e, t, n, r) {
					return this.call(p, ["{self}", t, n, r], this, e)
				}, v.removeLabel = function(e) {
					return delete this._labels[e], this
				}, v.getLabelTime = function(e) {
					return null != this._labels[e] ? this._labels[e] : -1
				}, v._parseTimeOrLabel = function(t, n, r, i) {
					var s;
					if(i instanceof e && i.timeline === this) this.remove(i);
					else if(i && (i instanceof Array || i.push && u(i)))
						for(s = i.length; --s > -1;) i[s] instanceof e && i[s].timeline === this && this.remove(i[s]);
					if("string" == typeof n) return this._parseTimeOrLabel(n, r && "number" == typeof t && null == this._labels[n] ? t - this.duration() : 0, r);
					if(n = n || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
					else {
						if(s = t.indexOf("="), -1 === s) return null == this._labels[t] ? r ? this._labels[t] = this.duration() + n : n : this._labels[t] + n;
						n = parseInt(t.charAt(s - 1) + "1", 10) * Number(t.substr(s + 1)), t = s > 1 ? this._parseTimeOrLabel(t.substr(0, s - 1), 0, r) : this.duration()
					}
					return Number(t) + n
				}, v.seek = function(e, t) {
					return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), t !== !1)
				}, v.stop = function() {
					return this.paused(!0)
				}, v.gotoAndPlay = function(e, t) {
					return this.play(e, t)
				}, v.gotoAndStop = function(e, t) {
					return this.pause(e, t)
				}, v.render = function(e, t, n) {
					this._gc && this._enabled(!0, !1);
					var r, s, o, u, c, h = this._dirty ? this.totalDuration() : this._totalDuration,
						p = this._time,
						d = this._startTime,
						v = this._timeScale,
						m = this._paused;
					if(e >= h ? (this._totalTime = this._time = h, this._reversed || this._hasPausedChild() || (s = !0, u = "onComplete", 0 === this._duration && (0 === e || 0 > this._rawPrevTime || this._rawPrevTime === i) && this._rawPrevTime !== e && this._first && (c = !0, this._rawPrevTime > i && (u = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : i, e = h + 1e-4) : 1e-7 > e ? (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && this._rawPrevTime !== i && (this._rawPrevTime > 0 || 0 > e && this._rawPrevTime >= 0)) && (u = "onReverseComplete", s = this._reversed), 0 > e ? (this._active = !1, this._rawPrevTime >= 0 && this._first && (c = !0), this._rawPrevTime = e) : (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : i, e = 0, this._initted || (c = !0))) : this._totalTime = this._time = this._rawPrevTime = e, this._time !== p && this._first || n || c) {
						if(this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && e > 0 && (this._active = !0), 0 === p && this.vars.onStart && 0 !== this._time && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || l)), this._time >= p)
							for(r = this._first; r && (o = r._next, !this._paused || m);)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = o;
						else
							for(r = this._last; r && (o = r._prev, !this._paused || m);)(r._active || p >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = o;
						this._onUpdate && (t || (a.length && f(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l))), u && (this._gc || (d === this._startTime || v !== this._timeScale) && (0 === this._time || h >= this.totalDuration()) && (s && (a.length && f(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[u] && this.vars[u].apply(this.vars[u + "Scope"] || this, this.vars[u + "Params"] || l)))
					}
				}, v._hasPausedChild = function() {
					for(var e = this._first; e;) {
						if(e._paused || e instanceof r && e._hasPausedChild()) return !0;
						e = e._next
					}
					return !1
				}, v.getChildren = function(e, t, r, i) {
					i = i || -9999999999;
					for(var s = [], o = this._first, u = 0; o;) i > o._startTime || (o instanceof n ? t !== !1 && (s[u++] = o) : (r !== !1 && (s[u++] = o), e !== !1 && (s = s.concat(o.getChildren(!0, t, r)), u = s.length))), o = o._next;
					return s
				}, v.getTweensOf = function(e, t) {
					var r, i, s = this._gc,
						o = [],
						u = 0;
					for(s && this._enabled(!0, !0), r = n.getTweensOf(e), i = r.length; --i > -1;)(r[i].timeline === this || t && this._contains(r[i])) && (o[u++] = r[i]);
					return s && this._enabled(!1, !0), o
				}, v._contains = function(e) {
					for(var t = e.timeline; t;) {
						if(t === this) return !0;
						t = t.timeline
					}
					return !1
				}, v.shiftChildren = function(e, t, n) {
					n = n || 0;
					for(var r, i = this._first, s = this._labels; i;) i._startTime >= n && (i._startTime += e), i = i._next;
					if(t)
						for(r in s) s[r] >= n && (s[r] += e);
					return this._uncache(!0)
				}, v._kill = function(e, t) {
					if(!e && !t) return this._enabled(!1, !1);
					for(var n = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), r = n.length, i = !1; --r > -1;) n[r]._kill(e, t) && (i = !0);
					return i
				}, v.clear = function(e) {
					var t = this.getChildren(!1, !0, !0),
						n = t.length;
					for(this._time = this._totalTime = 0; --n > -1;) t[n]._enabled(!1, !1);
					return e !== !1 && (this._labels = {}), this._uncache(!0)
				}, v.invalidate = function() {
					for(var e = this._first; e;) e.invalidate(), e = e._next;
					return this
				}, v._enabled = function(e, n) {
					if(e === this._gc)
						for(var r = this._first; r;) r._enabled(e, !0), r = r._next;
					return t.prototype._enabled.call(this, e, n)
				}, v.duration = function(e) {
					return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
				}, v.totalDuration = function(e) {
					if(!arguments.length) {
						if(this._dirty) {
							for(var t, n, r = 0, i = this._last, s = 999999999999; i;) t = i._prev, i._dirty && i.totalDuration(), i._startTime > s && this._sortChildren && !i._paused ? this.add(i, i._startTime - i._delay) : s = i._startTime, 0 > i._startTime && !i._paused && (r -= i._startTime, this._timeline.smoothChildTiming && (this._startTime += i._startTime / this._timeScale), this.shiftChildren(-i._startTime, !1, -9999999999), s = 0), n = i._startTime + i._totalDuration / i._timeScale, n > r && (r = n), i = t;
							this._duration = this._totalDuration = r, this._dirty = !1
						}
						return this._totalDuration
					}
					return 0 !== this.totalDuration() && 0 !== e && this.timeScale(this._totalDuration / e), this
				}, v.usesFrames = function() {
					for(var t = this._timeline; t._timeline;) t = t._timeline;
					return t === e._rootFramesTimeline
				}, v.rawTime = function() {
					return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
				}, r
			}, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(e, t, n) {
				var r = function(t) {
						e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
					},
					i = 1e-10,
					s = [],
					o = t._internals,
					u = o.lazyTweens,
					a = o.lazyRender,
					f = new n(null, null, 1, 0),
					l = r.prototype = new e;
				return l.constructor = r, l.kill()._gc = !1, r.version = "1.13.1", l.invalidate = function() {
					return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
				}, l.addCallback = function(e, n, r, i) {
					return this.add(t.delayedCall(0, e, r, i), n)
				}, l.removeCallback = function(e, t) {
					if(e)
						if(null == t) this._kill(null, e);
						else
							for(var n = this.getTweensOf(e, !1), r = n.length, i = this._parseTimeOrLabel(t); --r > -1;) n[r]._startTime === i && n[r]._enabled(!1, !1);
					return this
				}, l.tweenTo = function(e, n) {
					n = n || {};
					var r, i, o, u = {
						ease: f,
						overwrite: n.delay ? 2 : 1,
						useFrames: this.usesFrames(),
						immediateRender: !1
					};
					for(i in n) u[i] = n[i];
					return u.time = this._parseTimeOrLabel(e), r = Math.abs(Number(u.time) - this._time) / this._timeScale || .001, o = new t(this, r, u), u.onStart = function() {
						o.target.paused(!0), o.vars.time !== o.target.time() && r === o.duration() && o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale), n.onStart && n.onStart.apply(n.onStartScope || o, n.onStartParams || s)
					}, o
				}, l.tweenFromTo = function(e, t, n) {
					n = n || {}, e = this._parseTimeOrLabel(e), n.startAt = {
						onComplete: this.seek,
						onCompleteParams: [e],
						onCompleteScope: this
					}, n.immediateRender = n.immediateRender !== !1;
					var r = this.tweenTo(t, n);
					return r.duration(Math.abs(r.vars.time - e) / this._timeScale || .001)
				}, l.render = function(e, t, n) {
					this._gc && this._enabled(!0, !1);
					var r, o, f, l, c, p, d = this._dirty ? this.totalDuration() : this._totalDuration,
						v = this._duration,
						m = this._time,
						g = this._totalTime,
						y = this._startTime,
						b = this._timeScale,
						w = this._rawPrevTime,
						E = this._paused,
						S = this._cycle;
					if(e >= d ? (this._locked || (this._totalTime = d, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, l = "onComplete", 0 === this._duration && (0 === e || 0 > w || w === i) && w !== e && this._first && (c = !0, w > i && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : i, this._yoyo && 0 !== (1 & this._cycle) ? this._time = e = 0 : (this._time = v, e = v + 1e-4)) : 1e-7 > e ? (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== m || 0 === v && w !== i && (w > 0 || 0 > e && w >= 0) && !this._locked) && (l = "onReverseComplete", o = this._reversed), 0 > e ? (this._active = !1, w >= 0 && this._first && (c = !0), this._rawPrevTime = e) : (this._rawPrevTime = v || !t || e || this._rawPrevTime === e ? e : i, e = 0, this._initted || (c = !0))) : (0 === v && 0 > w && (c = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (p = v + this._repeatDelay, this._cycle = this._totalTime / p >> 0, 0 !== this._cycle && this._cycle === this._totalTime / p && this._cycle--, this._time = this._totalTime - this._cycle * p, this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time), this._time > v ? (this._time = v, e = v + 1e-4) : 0 > this._time ? this._time = e = 0 : e = this._time))), this._cycle !== S && !this._locked) {
						var x = this._yoyo && 0 !== (1 & S),
							T = x === (this._yoyo && 0 !== (1 & this._cycle)),
							N = this._totalTime,
							C = this._cycle,
							k = this._rawPrevTime,
							L = this._time;
						if(this._totalTime = S * v, S > this._cycle ? x = !x : this._totalTime += v, this._time = m, this._rawPrevTime = 0 === v ? w - 1e-4 : w, this._cycle = S, this._locked = !0, m = x ? 0 : v, this.render(m, t, 0 === v), t || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || s), T && (m = x ? v + 1e-4 : -0.0001, this.render(m, !0, !1)), this._locked = !1, this._paused && !E) return;
						this._time = L, this._totalTime = N, this._cycle = C, this._rawPrevTime = k
					}
					if(!(this._time !== m && this._first || n || c)) return g !== this._totalTime && this._onUpdate && (t || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || s)), void 0;
					if(this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && e > 0 && (this._active = !0), 0 === g && this.vars.onStart && 0 !== this._totalTime && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || s)), this._time >= m)
						for(r = this._first; r && (f = r._next, !this._paused || E);)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = f;
					else
						for(r = this._last; r && (f = r._prev, !this._paused || E);)(r._active || m >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = f;
					this._onUpdate && (t || (u.length && a(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || s))), l && (this._locked || this._gc || (y === this._startTime || b !== this._timeScale) && (0 === this._time || d >= this.totalDuration()) && (o && (u.length && a(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[l] && this.vars[l].apply(this.vars[l + "Scope"] || this, this.vars[l + "Params"] || s)))
				}, l.getActive = function(e, t, n) {
					null == e && (e = !0), null == t && (t = !0), null == n && (n = !1);
					var r, i, s = [],
						o = this.getChildren(e, t, n),
						u = 0,
						a = o.length;
					for(r = 0; a > r; r++) i = o[r], i.isActive() && (s[u++] = i);
					return s
				}, l.getLabelAfter = function(e) {
					e || 0 !== e && (e = this._time);
					var t, n = this.getLabelsArray(),
						r = n.length;
					for(t = 0; r > t; t++)
						if(n[t].time > e) return n[t].name;
					return null
				}, l.getLabelBefore = function(e) {
					null == e && (e = this._time);
					for(var t = this.getLabelsArray(), n = t.length; --n > -1;)
						if(e > t[n].time) return t[n].name;
					return null
				}, l.getLabelsArray = function() {
					var e, t = [],
						n = 0;
					for(e in this._labels) t[n++] = {
						time: this._labels[e],
						name: e
					};
					return t.sort(function(e, t) {
						return e.time - t.time
					}), t
				}, l.progress = function(e) {
					return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
				}, l.totalProgress = function(e) {
					return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
				}, l.totalDuration = function(t) {
					return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
				}, l.time = function(e, t) {
					return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
				}, l.repeat = function(e) {
					return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
				}, l.repeatDelay = function(e) {
					return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
				}, l.yoyo = function(e) {
					return arguments.length ? (this._yoyo = e, this) : this._yoyo
				}, l.currentLabel = function(e) {
					return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
				}, r
			}, !0),
			function() {
				var e = 180 / Math.PI,
					t = [],
					n = [],
					r = [],
					i = {},
					s = function(e, t, n, r) {
						this.a = e, this.b = t, this.c = n, this.d = r, this.da = r - e, this.ca = n - e, this.ba = t - e
					},
					o = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
					u = function(e, t, n, r) {
						var i = {
								a: e
							},
							s = {},
							o = {},
							u = {
								c: r
							},
							a = (e + t) / 2,
							f = (t + n) / 2,
							l = (n + r) / 2,
							c = (a + f) / 2,
							h = (f + l) / 2,
							p = (h - c) / 8;
						return i.b = a + (e - a) / 4, s.b = c + p, i.c = s.a = (i.b + s.b) / 2, s.c = o.a = (c + h) / 2, o.b = h - p, u.b = l + (r - l) / 4, o.c = u.a = (o.b + u.b) / 2, [i, s, o, u]
					},
					a = function(e, i, s, o, a) {
						var f, l, c, h, p, d, v, m, g, y, b, w, E, S = e.length - 1,
							x = 0,
							T = e[0].a;
						for(f = 0; S > f; f++) p = e[x], l = p.a, c = p.d, h = e[x + 1].d, a ? (b = t[f], w = n[f], E = .25 * (w + b) * i / (o ? .5 : r[f] || .5), d = c - (c - l) * (o ? .5 * i : 0 !== b ? E / b : 0), v = c + (h - c) * (o ? .5 * i : 0 !== w ? E / w : 0), m = c - (d + ((v - d) * (3 * b / (b + w) + .5) / 4 || 0))) : (d = c - .5 * (c - l) * i, v = c + .5 * (h - c) * i, m = c - (d + v) / 2), d += m, v += m, p.c = g = d, p.b = 0 !== f ? T : T = p.a + .6 * (p.c - p.a), p.da = c - l, p.ca = g - l, p.ba = T - l, s ? (y = u(l, T, g, c), e.splice(x, 1, y[0], y[1], y[2], y[3]), x += 4) : x++, T = v;
						p = e[x], p.b = T, p.c = T + .4 * (p.d - T), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = T - p.a, s && (y = u(p.a, T, p.c, p.d), e.splice(x, 1, y[0], y[1], y[2], y[3]))
					},
					f = function(e, r, i, o) {
						var u, a, f, l, c, h, p = [];
						if(o)
							for(e = [o].concat(e), a = e.length; --a > -1;) "string" == typeof(h = e[a][r]) && "=" === h.charAt(1) && (e[a][r] = o[r] + Number(h.charAt(0) + h.substr(2)));
						if(u = e.length - 2, 0 > u) return p[0] = new s(e[0][r], 0, 0, e[-1 > u ? 0 : 1][r]), p;
						for(a = 0; u > a; a++) f = e[a][r], l = e[a + 1][r], p[a] = new s(f, 0, 0, l), i && (c = e[a + 2][r], t[a] = (t[a] || 0) + (l - f) * (l - f), n[a] = (n[a] || 0) + (c - l) * (c - l));
						return p[a] = new s(e[a][r], 0, 0, e[a + 1][r]), p
					},
					l = function(e, s, u, l, c, h) {
						var p, d, v, m, g, y, b, w, E = {},
							S = [],
							x = h || e[0];
						c = "string" == typeof c ? "," + c + "," : o, null == s && (s = 1);
						for(d in e[0]) S.push(d);
						if(e.length > 1) {
							for(w = e[e.length - 1], b = !0, p = S.length; --p > -1;)
								if(d = S[p], Math.abs(x[d] - w[d]) > .05) {
									b = !1;
									break
								}
							b && (e = e.concat(), h && e.unshift(h), e.push(e[1]), h = e[e.length - 3])
						}
						for(t.length = n.length = r.length = 0, p = S.length; --p > -1;) d = S[p], i[d] = -1 !== c.indexOf("," + d + ","), E[d] = f(e, d, i[d], h);
						for(p = t.length; --p > -1;) t[p] = Math.sqrt(t[p]), n[p] = Math.sqrt(n[p]);
						if(!l) {
							for(p = S.length; --p > -1;)
								if(i[d])
									for(v = E[S[p]], y = v.length - 1, m = 0; y > m; m++) g = v[m + 1].da / n[m] + v[m].da / t[m], r[m] = (r[m] || 0) + g * g;
							for(p = r.length; --p > -1;) r[p] = Math.sqrt(r[p])
						}
						for(p = S.length, m = u ? 4 : 1; --p > -1;) d = S[p], v = E[d], a(v, s, u, l, i[d]), b && (v.splice(0, m), v.splice(v.length - m, m));
						return E
					},
					c = function(e, t, n) {
						t = t || "soft";
						var r, i, o, u, a, f, l, c, h, p, d, v = {},
							m = "cubic" === t ? 3 : 2,
							g = "soft" === t,
							y = [];
						if(g && n && (e = [n].concat(e)), null == e || m + 1 > e.length) throw "invalid Bezier data";
						for(h in e[0]) y.push(h);
						for(f = y.length; --f > -1;) {
							for(h = y[f], v[h] = a = [], p = 0, c = e.length, l = 0; c > l; l++) r = null == n ? e[l][h] : "string" == typeof(d = e[l][h]) && "=" === d.charAt(1) ? n[h] + Number(d.charAt(0) + d.substr(2)) : Number(d), g && l > 1 && c - 1 > l && (a[p++] = (r + a[p - 2]) / 2), a[p++] = r;
							for(c = p - m + 1, p = 0, l = 0; c > l; l += m) r = a[l], i = a[l + 1], o = a[l + 2], u = 2 === m ? 0 : a[l + 3], a[p++] = d = 3 === m ? new s(r, i, o, u) : new s(r, (2 * i + r) / 3, (2 * i + o) / 3, o);
							a.length = p
						}
						return v
					},
					h = function(e, t, n) {
						for(var r, i, s, o, u, a, f, l, c, h, p, d = 1 / n, v = e.length; --v > -1;)
							for(h = e[v], s = h.a, o = h.d - s, u = h.c - s, a = h.b - s, r = i = 0, l = 1; n >= l; l++) f = d * l, c = 1 - f, r = i - (i = (f * f * o + 3 * c * (f * u + c * a)) * f), p = v * n + l - 1, t[p] = (t[p] || 0) + r * r
					},
					p = function(e, t) {
						t = t >> 0 || 6;
						var n, r, i, s, o = [],
							u = [],
							a = 0,
							f = 0,
							l = t - 1,
							c = [],
							p = [];
						for(n in e) h(e[n], o, t);
						for(i = o.length, r = 0; i > r; r++) a += Math.sqrt(o[r]), s = r % t, p[s] = a, s === l && (f += a, s = r / t >> 0, c[s] = p, u[s] = f, a = 0, p = []);
						return {
							length: f,
							lengths: u,
							segments: c
						}
					},
					d = _gsScope._gsDefine.plugin({
						propName: "bezier",
						priority: -1,
						version: "1.3.3",
						API: 2,
						global: !0,
						init: function(e, t, n) {
							this._target = e, t instanceof Array && (t = {
								values: t
							}), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
							var r, i, s, o, u, a = t.values || [],
								f = {},
								h = a[0],
								d = t.autoRotate || n.vars.orientToBezier;
							this._autoRotate = d ? d instanceof Array ? d : [
								["x", "y", "rotation", d === !0 ? 0 : Number(d) || 0]
							] : null;
							for(r in h) this._props.push(r);
							for(s = this._props.length; --s > -1;) r = this._props[s], this._overwriteProps.push(r), i = this._func[r] = "function" == typeof e[r], f[r] = i ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(e[r]), u || f[r] !== a[0][r] && (u = f);
							if(this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? l(a, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, u) : c(a, t.type, f), this._segCount = this._beziers[r].length, this._timeRes) {
								var v = p(this._beziers, this._timeRes);
								this._length = v.length, this._lengths = v.lengths, this._segments = v.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
							}
							if(d = this._autoRotate)
								for(this._initialRotations = [], d[0] instanceof Array || (this._autoRotate = d = [d]), s = d.length; --s > -1;) {
									for(o = 0; 3 > o; o++) r = d[s][o], this._func[r] = "function" == typeof e[r] ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)] : !1;
									r = d[s][2], this._initialRotations[s] = this._func[r] ? this._func[r].call(this._target) : this._target[r]
								}
							return this._startRatio = n.vars.runBackwards ? 1 : 0, !0
						},
						set: function(t) {
							var n, r, i, s, o, u, a, f, l, c, h = this._segCount,
								p = this._func,
								d = this._target,
								v = t !== this._startRatio;
							if(this._timeRes) {
								if(l = this._lengths, c = this._curSeg, t *= this._length, i = this._li, t > this._l2 && h - 1 > i) {
									for(f = h - 1; f > i && t >= (this._l2 = l[++i]););
									this._l1 = l[i - 1], this._li = i, this._curSeg = c = this._segments[i], this._s2 = c[this._s1 = this._si = 0]
								} else if(this._l1 > t && i > 0) {
									for(; i > 0 && (this._l1 = l[--i]) >= t;);
									0 === i && this._l1 > t ? this._l1 = 0 : i++, this._l2 = l[i], this._li = i, this._curSeg = c = this._segments[i], this._s1 = c[(this._si = c.length - 1) - 1] || 0, this._s2 = c[this._si]
								}
								if(n = i, t -= this._l1, i = this._si, t > this._s2 && c.length - 1 > i) {
									for(f = c.length - 1; f > i && t >= (this._s2 = c[++i]););
									this._s1 = c[i - 1], this._si = i
								} else if(this._s1 > t && i > 0) {
									for(; i > 0 && (this._s1 = c[--i]) >= t;);
									0 === i && this._s1 > t ? this._s1 = 0 : i++, this._s2 = c[i], this._si = i
								}
								u = (i + (t - this._s1) / (this._s2 - this._s1)) * this._prec
							} else n = 0 > t ? 0 : t >= 1 ? h - 1 : h * t >> 0, u = (t - n * (1 / h)) * h;
							for(r = 1 - u, i = this._props.length; --i > -1;) s = this._props[i], o = this._beziers[s][n], a = (u * u * o.da + 3 * r * (u * o.ca + r * o.ba)) * u + o.a, this._round[s] && (a = Math.round(a)), p[s] ? d[s](a) : d[s] = a;
							if(this._autoRotate) {
								var m, g, y, b, w, E, S, x = this._autoRotate;
								for(i = x.length; --i > -1;) s = x[i][2], E = x[i][3] || 0, S = x[i][4] === !0 ? 1 : e, o = this._beziers[x[i][0]], m = this._beziers[x[i][1]], o && m && (o = o[n], m = m[n], g = o.a + (o.b - o.a) * u, b = o.b + (o.c - o.b) * u, g += (b - g) * u, b += (o.c + (o.d - o.c) * u - b) * u, y = m.a + (m.b - m.a) * u, w = m.b + (m.c - m.b) * u, y += (w - y) * u, w += (m.c + (m.d - m.c) * u - w) * u, a = v ? Math.atan2(w - y, b - g) * S + E : this._initialRotations[i], p[s] ? d[s](a) : d[s] = a)
							}
						}
					}),
					v = d.prototype;
				d.bezierThrough = l, d.cubicToQuadratic = u, d._autoCSS = !0, d.quadraticToCubic = function(e, t, n) {
					return new s(e, (2 * t + e) / 3, (2 * t + n) / 3, n)
				}, d._cssRegister = function() {
					var e = _gsScope._gsDefine.globals.CSSPlugin;
					if(e) {
						var t = e._internals,
							n = t._parseToProxy,
							r = t._setPluginRatio,
							i = t.CSSPropTween;
						t._registerComplexSpecialProp("bezier", {
							parser: function(e, t, s, o, u, a) {
								t instanceof Array && (t = {
									values: t
								}), a = new d;
								var f, l, c, h = t.values,
									p = h.length - 1,
									v = [],
									m = {};
								if(0 > p) return u;
								for(f = 0; p >= f; f++) c = n(e, h[f], o, u, a, p !== f), v[f] = c.end;
								for(l in t) m[l] = t[l];
								return m.values = v, u = new i(e, "bezier", 0, 0, c.pt, 2), u.data = c, u.plugin = a, u.setRatio = r, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (f = m.autoRotate === !0 ? 0 : Number(m.autoRotate), m.autoRotate = null != c.end.left ? [
									["left", "top", "rotation", f, !1]
								] : null != c.end.x ? [
									["x", "y", "rotation", f, !1]
								] : !1), m.autoRotate && (o._transform || o._enableTransforms(!1), c.autoRotate = o._target._gsTransform), a._onInitTween(c.proxy, m, o._tween), u
							}
						})
					}
				}, v._roundProps = function(e, t) {
					for(var n = this._overwriteProps, r = n.length; --r > -1;)(e[n[r]] || e.bezier || e.bezierThrough) && (this._round[n[r]] = t)
				}, v._kill = function(e) {
					var t, n, r = this._props;
					for(t in this._beziers)
						if(t in e)
							for(delete this._beziers[t], delete this._func[t], n = r.length; --n > -1;) r[n] === t && r.splice(n, 1);
					return this._super._kill.call(this, e)
				}
			}(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(e, t) {
				var n, r, i, s, o = function() {
						e.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
					},
					u = {},
					a = o.prototype = new e("css");
				a.constructor = o, o.version = "1.13.1", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", a = "px", o.suffixMap = {
					top: a,
					right: a,
					bottom: a,
					left: a,
					width: a,
					height: a,
					fontSize: a,
					padding: a,
					margin: a,
					perspective: a,
					lineHeight: ""
				};
				var f, l, c, h, p, d, v = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
					m = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
					g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
					y = /[^\d\-\.]/g,
					b = /(?:\d|\-|\+|=|#|\.)*/g,
					w = /opacity *= *([^)]*)/i,
					E = /opacity:([^;]*)/i,
					S = /alpha\(opacity *=.+?\)/i,
					x = /^(rgb|hsl)/,
					T = /([A-Z])/g,
					N = /-([a-z])/gi,
					C = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
					k = function(e, t) {
						return t.toUpperCase()
					},
					L = /(?:Left|Right|Width)/i,
					A = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
					O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
					M = /,(?=[^\)]*(?:\(|$))/gi,
					_ = Math.PI / 180,
					D = 180 / Math.PI,
					P = {},
					H = document,
					B = H.createElement("div"),
					j = H.createElement("img"),
					F = o._internals = {
						_specialProps: u
					},
					I = navigator.userAgent,
					q = function() {
						var e, t = I.indexOf("Android"),
							n = H.createElement("div");
						return c = -1 !== I.indexOf("Safari") && -1 === I.indexOf("Chrome") && (-1 === t || Number(I.substr(t + 8, 1)) > 3), p = c && 6 > Number(I.substr(I.indexOf("Version/") + 8, 1)), h = -1 !== I.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(I) && (d = parseFloat(RegExp.$1)), n.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", e = n.getElementsByTagName("a")[0], e ? /^0.55/.test(e.style.opacity) : !1
					}(),
					R = function(e) {
						return w.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
					},
					U = function(e) {
						window.console && console.log(e)
					},
					z = "",
					W = "",
					X = function(e, t) {
						t = t || B;
						var n, r, i = t.style;
						if(void 0 !== i[e]) return e;
						for(e = e.charAt(0).toUpperCase() + e.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === i[n[r] + e];);
						return r >= 0 ? (W = 3 === r ? "ms" : n[r], z = "-" + W.toLowerCase() + "-", W + e) : null
					},
					V = H.defaultView ? H.defaultView.getComputedStyle : function() {},
					$ = o.getStyle = function(e, t, n, r, i) {
						var s;
						return q || "opacity" !== t ? (!r && e.style[t] ? s = e.style[t] : (n = n || V(e)) ? s = n[t] || n.getPropertyValue(t) || n.getPropertyValue(t.replace(T, "-$1").toLowerCase()) : e.currentStyle && (s = e.currentStyle[t]), null == i || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s : i) : R(e)
					},
					J = F.convertToPixels = function(e, n, r, i, s) {
						if("px" === i || !i) return r;
						if("auto" === i || !r) return 0;
						var u, a, f, l = L.test(n),
							c = e,
							h = B.style,
							p = 0 > r;
						if(p && (r = -r), "%" === i && -1 !== n.indexOf("border")) u = r / 100 * (l ? e.clientWidth : e.clientHeight);
						else {
							if(h.cssText = "border:0 solid red;position:" + $(e, "position") + ";line-height:0;", "%" !== i && c.appendChild) h[l ? "borderLeftWidth" : "borderTopWidth"] = r + i;
							else {
								if(c = e.parentNode || H.body, a = c._gsCache, f = t.ticker.frame, a && l && a.time === f) return a.width * r / 100;
								h[l ? "width" : "height"] = r + i
							}
							c.appendChild(B), u = parseFloat(B[l ? "offsetWidth" : "offsetHeight"]), c.removeChild(B), l && "%" === i && o.cacheWidths !== !1 && (a = c._gsCache = c._gsCache || {}, a.time = f, a.width = 100 * (u / r)), 0 !== u || s || (u = J(e, n, r, i, !0))
						}
						return p ? -u : u
					},
					K = F.calculateOffset = function(e, t, n) {
						if("absolute" !== $(e, "position", n)) return 0;
						var r = "left" === t ? "Left" : "Top",
							i = $(e, "margin" + r, n);
						return e["offset" + r] - (J(e, t, parseFloat(i), i.replace(b, "")) || 0)
					},
					Q = function(e, t) {
						var n, r, i = {};
						if(t = t || V(e, null))
							if(n = t.length)
								for(; --n > -1;) i[t[n].replace(N, k)] = t.getPropertyValue(t[n]);
							else
								for(n in t) i[n] = t[n];
						else if(t = e.currentStyle || e.style)
							for(n in t) "string" == typeof n && void 0 === i[n] && (i[n.replace(N, k)] = t[n]);
						return q || (i.opacity = R(e)), r = Tt(e, t, !1), i.rotation = r.rotation, i.skewX = r.skewX, i.scaleX = r.scaleX, i.scaleY = r.scaleY, i.x = r.x, i.y = r.y, St && (i.z = r.z, i.rotationX = r.rotationX, i.rotationY = r.rotationY, i.scaleZ = r.scaleZ), i.filters && delete i.filters, i
					},
					G = function(e, t, n, r, i) {
						var s, o, u, a = {},
							f = e.style;
						for(o in n) "cssText" !== o && "length" !== o && isNaN(o) && (t[o] !== (s = n[o]) || i && i[o]) && -1 === o.indexOf("Origin") && ("number" == typeof s || "string" == typeof s) && (a[o] = "auto" !== s || "left" !== o && "top" !== o ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof t[o] || "" === t[o].replace(y, "") ? s : 0 : K(e, o), void 0 !== f[o] && (u = new ct(f, o, f[o], u)));
						if(r)
							for(o in r) "className" !== o && (a[o] = r[o]);
						return {
							difs: a,
							firstMPT: u
						}
					},
					Y = {
						width: ["Left", "Right"],
						height: ["Top", "Bottom"]
					},
					Z = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
					et = function(e, t, n) {
						var r = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight),
							i = Y[t],
							s = i.length;
						for(n = n || V(e, null); --s > -1;) r -= parseFloat($(e, "padding" + i[s], n, !0)) || 0, r -= parseFloat($(e, "border" + i[s] + "Width", n, !0)) || 0;
						return r
					},
					tt = function(e, t) {
						(null == e || "" === e || "auto" === e || "auto auto" === e) && (e = "0 0");
						var n = e.split(" "),
							r = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : n[0],
							i = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : n[1];
						return null == i ? i = "0" : "center" === i && (i = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== i.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === i.charAt(1), t.ox = parseFloat(r.replace(y, "")), t.oy = parseFloat(i.replace(y, ""))), r + " " + i + (n.length > 2 ? " " + n[2] : "")
					},
					nt = function(e, t) {
						return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t)
					},
					rt = function(e, t) {
						return null == e ? t : "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * Number(e.substr(2)) + t : parseFloat(e)
					},
					it = function(e, t, n, r) {
						var i, s, o, u, a = 1e-6;
						return null == e ? u = t : "number" == typeof e ? u = e : (i = 360, s = e.split("_"), o = Number(s[0].replace(y, "")) * (-1 === e.indexOf("rad") ? 1 : D) - ("=" === e.charAt(1) ? 0 : t), s.length && (r && (r[n] = t + o), -1 !== e.indexOf("short") && (o %= i, o !== o % (i / 2) && (o = 0 > o ? o + i : o - i)), -1 !== e.indexOf("_cw") && 0 > o ? o = (o + 9999999999 * i) % i - (0 | o / i) * i : -1 !== e.indexOf("ccw") && o > 0 && (o = (o - 9999999999 * i) % i - (0 | o / i) * i)), u = t + o), a > u && u > -a && (u = 0), u
					},
					st = {
						aqua: [0, 255, 255],
						lime: [0, 255, 0],
						silver: [192, 192, 192],
						black: [0, 0, 0],
						maroon: [128, 0, 0],
						teal: [0, 128, 128],
						blue: [0, 0, 255],
						navy: [0, 0, 128],
						white: [255, 255, 255],
						fuchsia: [255, 0, 255],
						olive: [128, 128, 0],
						yellow: [255, 255, 0],
						orange: [255, 165, 0],
						gray: [128, 128, 128],
						purple: [128, 0, 128],
						green: [0, 128, 0],
						red: [255, 0, 0],
						pink: [255, 192, 203],
						cyan: [0, 255, 255],
						transparent: [255, 255, 255, 0]
					},
					ot = function(e, t, n) {
						return e = 0 > e ? e + 1 : e > 1 ? e - 1 : e, 0 | 255 * (1 > 6 * e ? t + 6 * (n - t) * e : .5 > e ? n : 2 > 3 * e ? t + 6 * (n - t) * (2 / 3 - e) : t) + .5
					},
					ut = function(e) {
						var t, n, r, i, s, o;
						return e && "" !== e ? "number" == typeof e ? [e >> 16, 255 & e >> 8, 255 & e] : ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), st[e] ? st[e] : "#" === e.charAt(0) ? (4 === e.length && (t = e.charAt(1), n = e.charAt(2), r = e.charAt(3), e = "#" + t + t + n + n + r + r), e = parseInt(e.substr(1), 16), [e >> 16, 255 & e >> 8, 255 & e]) : "hsl" === e.substr(0, 3) ? (e = e.match(v), i = Number(e[0]) % 360 / 360, s = Number(e[1]) / 100, o = Number(e[2]) / 100, n = .5 >= o ? o * (s + 1) : o + s - o * s, t = 2 * o - n, e.length > 3 && (e[3] = Number(e[3])), e[0] = ot(i + 1 / 3, t, n), e[1] = ot(i, t, n), e[2] = ot(i - 1 / 3, t, n), e) : (e = e.match(v) || st.transparent, e[0] = Number(e[0]), e[1] = Number(e[1]), e[2] = Number(e[2]), e.length > 3 && (e[3] = Number(e[3])), e)) : st.black
					},
					at = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
				for(a in st) at += "|" + a + "\\b";
				at = RegExp(at + ")", "gi");
				var ft = function(e, t, n, r) {
						if(null == e) return function(e) {
							return e
						};
						var i, s = t ? (e.match(at) || [""])[0] : "",
							o = e.split(s).join("").match(g) || [],
							u = e.substr(0, e.indexOf(o[0])),
							a = ")" === e.charAt(e.length - 1) ? ")" : "",
							f = -1 !== e.indexOf(" ") ? " " : ",",
							l = o.length,
							c = l > 0 ? o[0].replace(v, "") : "";
						return l ? i = t ? function(e) {
							var t, h, p, d;
							if("number" == typeof e) e += c;
							else if(r && M.test(e)) {
								for(d = e.replace(M, "|").split("|"), p = 0; d.length > p; p++) d[p] = i(d[p]);
								return d.join(",")
							}
							if(t = (e.match(at) || [s])[0], h = e.split(t).join("").match(g) || [], p = h.length, l > p--)
								for(; l > ++p;) h[p] = n ? h[0 | (p - 1) / 2] : o[p];
							return u + h.join(f) + f + t + a + (-1 !== e.indexOf("inset") ? " inset" : "")
						} : function(e) {
							var t, s, h;
							if("number" == typeof e) e += c;
							else if(r && M.test(e)) {
								for(s = e.replace(M, "|").split("|"), h = 0; s.length > h; h++) s[h] = i(s[h]);
								return s.join(",")
							}
							if(t = e.match(g) || [], h = t.length, l > h--)
								for(; l > ++h;) t[h] = n ? t[0 | (h - 1) / 2] : o[h];
							return u + t.join(f) + a
						} : function(e) {
							return e
						}
					},
					lt = function(e) {
						return e = e.split(","),
							function(t, n, r, i, s, o, u) {
								var a, f = (n + "").split(" ");
								for(u = {}, a = 0; 4 > a; a++) u[e[a]] = f[a] = f[a] || f[(a - 1) / 2 >> 0];
								return i.parse(t, u, s, o)
							}
					},
					ct = (F._setPluginRatio = function(e) {
						this.plugin.setRatio(e);
						for(var t, n, r, i, s = this.data, o = s.proxy, u = s.firstMPT, a = 1e-6; u;) t = o[u.v], u.r ? t = Math.round(t) : a > t && t > -a && (t = 0), u.t[u.p] = t, u = u._next;
						if(s.autoRotate && (s.autoRotate.rotation = o.rotation), 1 === e)
							for(u = s.firstMPT; u;) {
								if(n = u.t, n.type) {
									if(1 === n.type) {
										for(i = n.xs0 + n.s + n.xs1, r = 1; n.l > r; r++) i += n["xn" + r] + n["xs" + (r + 1)];
										n.e = i
									}
								} else n.e = n.s + n.xs0;
								u = u._next
							}
					}, function(e, t, n, r, i) {
						this.t = e, this.p = t, this.v = n, this.r = i, r && (r._prev = this, this._next = r)
					}),
					ht = (F._parseToProxy = function(e, t, n, r, i, s) {
						var o, u, a, f, l, c = r,
							h = {},
							p = {},
							d = n._transform,
							v = P;
						for(n._transform = null, P = t, r = l = n.parse(e, t, r, i), P = v, s && (n._transform = d, c && (c._prev = null, c._prev && (c._prev._next = null))); r && r !== c;) {
							if(1 >= r.type && (u = r.p, p[u] = r.s + r.c, h[u] = r.s, s || (f = new ct(r, "s", u, f, r.r), r.c = 0), 1 === r.type))
								for(o = r.l; --o > 0;) a = "xn" + o, u = r.p + "_" + a, p[u] = r.data[a], h[u] = r[a], s || (f = new ct(r, a, u, f, r.rxp[a]));
							r = r._next
						}
						return {
							proxy: h,
							end: p,
							firstMPT: f,
							pt: l
						}
					}, F.CSSPropTween = function(e, t, r, i, o, u, a, f, l, c, h) {
						this.t = e, this.p = t, this.s = r, this.c = i, this.n = a || t, e instanceof ht || s.push(this.n), this.r = f, this.type = u || 0, l && (this.pr = l, n = !0), this.b = void 0 === c ? r : c, this.e = void 0 === h ? r + i : h, o && (this._next = o, o._prev = this)
					}),
					pt = o.parseComplex = function(e, t, n, r, i, s, o, u, a, l) {
						n = n || s || "", o = new ht(e, t, 0, 0, o, l ? 2 : 1, null, !1, u, n, r), r += "";
						var c, h, p, d, g, y, b, w, E, S, T, N, C = n.split(", ").join(",").split(" "),
							k = r.split(", ").join(",").split(" "),
							L = C.length,
							A = f !== !1;
						for((-1 !== r.indexOf(",") || -1 !== n.indexOf(",")) && (C = C.join(" ").replace(M, ", ").split(" "), k = k.join(" ").replace(M, ", ").split(" "), L = C.length), L !== k.length && (C = (s || "").split(" "), L = C.length), o.plugin = a, o.setRatio = l, c = 0; L > c; c++)
							if(d = C[c], g = k[c], w = parseFloat(d), w || 0 === w) o.appendXtra("", w, nt(g, w), g.replace(m, ""), A && -1 !== g.indexOf("px"), !0);
							else if(i && ("#" === d.charAt(0) || st[d] || x.test(d))) N = "," === g.charAt(g.length - 1) ? ")," : ")", d = ut(d), g = ut(g), E = d.length + g.length > 6, E && !q && 0 === g[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent", o.e = o.e.split(k[c]).join("transparent")) : (q || (E = !1), o.appendXtra(E ? "rgba(" : "rgb(", d[0], g[0] - d[0], ",", !0, !0).appendXtra("", d[1], g[1] - d[1], ",", !0).appendXtra("", d[2], g[2] - d[2], E ? "," : N, !0), E && (d = 4 > d.length ? 1 : d[3], o.appendXtra("", d, (4 > g.length ? 1 : g[3]) - d, N, !1)));
						else if(y = d.match(v)) {
							if(b = g.match(m), !b || b.length !== y.length) return o;
							for(p = 0, h = 0; y.length > h; h++) T = y[h], S = d.indexOf(T, p), o.appendXtra(d.substr(p, S - p), Number(T), nt(b[h], T), "", A && "px" === d.substr(S + T.length, 2), 0 === h), p = S + T.length;
							o["xs" + o.l] += d.substr(p)
						} else o["xs" + o.l] += o.l ? " " + d : d;
						if(-1 !== r.indexOf("=") && o.data) {
							for(N = o.xs0 + o.data.s, c = 1; o.l > c; c++) N += o["xs" + c] + o.data["xn" + c];
							o.e = N + o["xs" + c]
						}
						return o.l || (o.type = -1, o.xs0 = o.e), o.xfirst || o
					},
					dt = 9;
				for(a = ht.prototype, a.l = a.pr = 0; --dt > 0;) a["xn" + dt] = 0, a["xs" + dt] = "";
				a.xs0 = "", a._next = a._prev = a.xfirst = a.data = a.plugin = a.setRatio = a.rxp = null, a.appendXtra = function(e, t, n, r, i, s) {
					var o = this,
						u = o.l;
					return o["xs" + u] += s && u ? " " + e : e || "", n || 0 === u || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = r || "", u > 0 ? (o.data["xn" + u] = t + n, o.rxp["xn" + u] = i, o["xn" + u] = t, o.plugin || (o.xfirst = new ht(o, "xn" + u, t, n, o.xfirst || o, 0, o.n, i, o.pr), o.xfirst.xs0 = 0), o) : (o.data = {
						s: t + n
					}, o.rxp = {}, o.s = t, o.c = n, o.r = i, o)) : (o["xs" + u] += t + (r || ""), o)
				};
				var vt = function(e, t) {
						t = t || {}, this.p = t.prefix ? X(e) || e : e, u[e] = u[this.p] = this, this.format = t.formatter || ft(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.pr = t.priority || 0
					},
					mt = F._registerComplexSpecialProp = function(e, t, n) {
						"object" != typeof t && (t = {
							parser: n
						});
						var r, i, s = e.split(","),
							o = t.defaultValue;
						for(n = n || [o], r = 0; s.length > r; r++) t.prefix = 0 === r && t.prefix, t.defaultValue = n[r] || o, i = new vt(s[r], t)
					},
					gt = function(e) {
						if(!u[e]) {
							var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
							mt(e, {
								parser: function(e, n, r, i, s, o, a) {
									var f = (_gsScope.GreenSockGlobals || _gsScope).com.greensock.plugins[t];
									return f ? (f._cssRegister(), u[r].parse(e, n, r, i, s, o, a)) : (U("Error: " + t + " js file not loaded."), s)
								}
							})
						}
					};
				a = vt.prototype, a.parseComplex = function(e, t, n, r, i, s) {
					var o, u, a, f, l, c, h = this.keyword;
					if(this.multi && (M.test(n) || M.test(t) ? (u = t.replace(M, "|").split("|"), a = n.replace(M, "|").split("|")) : h && (u = [t], a = [n])), a) {
						for(f = a.length > u.length ? a.length : u.length, o = 0; f > o; o++) t = u[o] = u[o] || this.dflt, n = a[o] = a[o] || this.dflt, h && (l = t.indexOf(h), c = n.indexOf(h), l !== c && (n = -1 === c ? a : u, n[o] += " " + h));
						t = u.join(", "), n = a.join(", ")
					}
					return pt(e, this.p, t, n, this.clrs, this.dflt, r, this.pr, i, s)
				}, a.parse = function(e, t, n, r, s, o) {
					return this.parseComplex(e.style, this.format($(e, this.p, i, !1, this.dflt)), this.format(t), s, o)
				}, o.registerSpecialProp = function(e, t, n) {
					mt(e, {
						parser: function(e, r, i, s, o, u) {
							var a = new ht(e, i, 0, 0, o, 2, i, !1, n);
							return a.plugin = u, a.setRatio = t(e, r, s._tween, i), a
						},
						priority: n
					})
				};
				var yt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
					bt = X("transform"),
					wt = z + "transform",
					Et = X("transformOrigin"),
					St = null !== X("perspective"),
					xt = F.Transform = function() {
						this.skewY = 0
					},
					Tt = F.getTransform = function(e, t, n, r) {
						if(e._gsTransform && n && !r) return e._gsTransform;
						var i, s, u, a, f, l, c, h, p, d, v, m, g, y = n ? e._gsTransform || new xt : new xt,
							b = 0 > y.scaleX,
							w = 2e-5,
							E = 1e5,
							S = 179.99,
							x = S * _,
							T = St ? parseFloat($(e, Et, t, !1, "0 0 0").split(" ")[2]) || y.zOrigin || 0 : 0;
						if(bt ? i = $(e, wt, t, !0) : e.currentStyle && (i = e.currentStyle.filter.match(A), i = i && 4 === i.length ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), y.x || 0, y.y || 0].join(",") : ""), i && "none" !== i && "matrix(1, 0, 0, 1, 0, 0)" !== i) {
							for(s = (i || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], u = s.length; --u > -1;) a = Number(s[u]), s[u] = (f = a - (a |= 0)) ? (0 | f * E + (0 > f ? -0.5 : .5)) / E + a : a;
							if(16 === s.length) {
								var N = s[8],
									C = s[9],
									k = s[10],
									L = s[12],
									O = s[13],
									M = s[14];
								if(y.zOrigin && (M = -y.zOrigin, L = N * M - s[12], O = C * M - s[13], M = k * M + y.zOrigin - s[14]), !n || r || null == y.rotationX) {
									var P, H, B, j, F, I, q, R = s[0],
										U = s[1],
										z = s[2],
										W = s[3],
										X = s[4],
										V = s[5],
										J = s[6],
										K = s[7],
										Q = s[11],
										G = Math.atan2(J, k),
										Y = -x > G || G > x;
									y.rotationX = G * D, G && (j = Math.cos(-G), F = Math.sin(-G), P = X * j + N * F, H = V * j + C * F, B = J * j + k * F, N = X * -F + N * j, C = V * -F + C * j, k = J * -F + k * j, Q = K * -F + Q * j, X = P, V = H, J = B), G = Math.atan2(N, R), y.rotationY = G * D, G && (I = -x > G || G > x, j = Math.cos(-G), F = Math.sin(-G), P = R * j - N * F, H = U * j - C * F, B = z * j - k * F, C = U * F + C * j, k = z * F + k * j, Q = W * F + Q * j, R = P, U = H, z = B), G = Math.atan2(U, V), y.rotation = G * D, G && (q = -x > G || G > x, j = Math.cos(-G), F = Math.sin(-G), R = R * j + X * F, H = U * j + V * F, V = U * -F + V * j, J = z * -F + J * j, U = H), q && Y ? y.rotation = y.rotationX = 0 : q && I ? y.rotation = y.rotationY = 0 : I && Y && (y.rotationY = y.rotationX = 0), y.scaleX = (0 | Math.sqrt(R * R + U * U) * E + .5) / E, y.scaleY = (0 | Math.sqrt(V * V + C * C) * E + .5) / E, y.scaleZ = (0 | Math.sqrt(J * J + k * k) * E + .5) / E, y.skewX = 0, y.perspective = Q ? 1 / (0 > Q ? -Q : Q) : 0, y.x = L, y.y = O, y.z = M
								}
							} else if(!(St && !r && s.length && y.x === s[4] && y.y === s[5] && (y.rotationX || y.rotationY) || void 0 !== y.x && "none" === $(e, "display", t))) {
								var Z = s.length >= 6,
									et = Z ? s[0] : 1,
									tt = s[1] || 0,
									nt = s[2] || 0,
									rt = Z ? s[3] : 1;
								y.x = s[4] || 0, y.y = s[5] || 0, l = Math.sqrt(et * et + tt * tt), c = Math.sqrt(rt * rt + nt * nt), h = et || tt ? Math.atan2(tt, et) * D : y.rotation || 0, p = nt || rt ? Math.atan2(nt, rt) * D + h : y.skewX || 0, d = l - Math.abs(y.scaleX || 0), v = c - Math.abs(y.scaleY || 0), Math.abs(p) > 90 && 270 > Math.abs(p) && (b ? (l *= -1, p += 0 >= h ? 180 : -180, h += 0 >= h ? 180 : -180) : (c *= -1, p += 0 >= p ? 180 : -180)), m = (h - y.rotation) % 180, g = (p - y.skewX) % 180, (void 0 === y.skewX || d > w || -w > d || v > w || -w > v || m > -S && S > m && !1 | m * E || g > -S && S > g && !1 | g * E) && (y.scaleX = l, y.scaleY = c, y.rotation = h, y.skewX = p), St && (y.rotationX = y.rotationY = y.z = 0, y.perspective = parseFloat(o.defaultTransformPerspective) || 0, y.scaleZ = 1)
							}
							y.zOrigin = T;
							for(u in y) w > y[u] && y[u] > -w && (y[u] = 0)
						} else y = {
							x: 0,
							y: 0,
							z: 0,
							scaleX: 1,
							scaleY: 1,
							scaleZ: 1,
							skewX: 0,
							perspective: 0,
							rotation: 0,
							rotationX: 0,
							rotationY: 0,
							zOrigin: 0
						};
						return n && (e._gsTransform = y), y.xPercent = y.yPercent = 0, y
					},
					Nt = function(e) {
						var t, n, r = this.data,
							i = -r.rotation * _,
							s = i + r.skewX * _,
							o = 1e5,
							u = (0 | Math.cos(i) * r.scaleX * o) / o,
							a = (0 | Math.sin(i) * r.scaleX * o) / o,
							f = (0 | Math.sin(s) * -r.scaleY * o) / o,
							l = (0 | Math.cos(s) * r.scaleY * o) / o,
							c = this.t.style,
							h = this.t.currentStyle;
						if(h) {
							n = a, a = -f, f = -n, t = h.filter, c.filter = "";
							var p, v, m = this.t.offsetWidth,
								g = this.t.offsetHeight,
								y = "absolute" !== h.position,
								E = "progid:DXImageTransform.Microsoft.Matrix(M11=" + u + ", M12=" + a + ", M21=" + f + ", M22=" + l,
								S = r.x + m * r.xPercent / 100,
								x = r.y + g * r.yPercent / 100;
							if(null != r.ox && (p = (r.oxp ? .01 * m * r.ox : r.ox) - m / 2, v = (r.oyp ? .01 * g * r.oy : r.oy) - g / 2, S += p - (p * u + v * a), x += v - (p * f + v * l)), y ? (p = m / 2, v = g / 2, E += ", Dx=" + (p - (p * u + v * a) + S) + ", Dy=" + (v - (p * f + v * l) + x) + ")") : E += ", sizingMethod='auto expand')", c.filter = -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? t.replace(O, E) : E + " " + t, (0 === e || 1 === e) && 1 === u && 0 === a && 0 === f && 1 === l && (y && -1 === E.indexOf("Dx=0, Dy=0") || w.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && c.removeAttribute("filter")), !y) {
								var T, N, C, k = 8 > d ? 1 : -1;
								for(p = r.ieOffsetX || 0, v = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((0 > u ? -u : u) * m + (0 > a ? -a : a) * g)) / 2 + S), r.ieOffsetY = Math.round((g - ((0 > l ? -l : l) * g + (0 > f ? -f : f) * m)) / 2 + x), dt = 0; 4 > dt; dt++) N = Z[dt], T = h[N], n = -1 !== T.indexOf("px") ? parseFloat(T) : J(this.t, N, parseFloat(T), T.replace(b, "")) || 0, C = n !== r[N] ? 2 > dt ? -r.ieOffsetX : -r.ieOffsetY : 2 > dt ? p - r.ieOffsetX : v - r.ieOffsetY, c[N] = (r[N] = Math.round(n - C * (0 === dt || 2 === dt ? 1 : k))) + "px"
							}
						}
					},
					Ct = F.set3DTransformRatio = function(e) {
						var t, n, r, i, s, o, u, a, f, l, c, p, d, v, m, g, y, b, w, E, S, x, T, N = this.data,
							C = this.t.style,
							k = N.rotation * _,
							L = N.scaleX,
							A = N.scaleY,
							O = N.scaleZ,
							M = N.x,
							D = N.y,
							P = N.z,
							H = N.perspective;
						if(!(1 !== e && 0 !== e || "auto" !== N.force3D || N.rotationY || N.rotationX || 1 !== O || H || P)) return kt.call(this, e), void 0;
						if(h) {
							var B = 1e-4;
							B > L && L > -B && (L = O = 2e-5), B > A && A > -B && (A = O = 2e-5), !H || N.z || N.rotationX || N.rotationY || (H = 0)
						}
						if(k || N.skewX) b = Math.cos(k), w = Math.sin(k), t = b, s = w, N.skewX && (k -= N.skewX * _, b = Math.cos(k), w = Math.sin(k), "simple" === N.skewType && (E = Math.tan(N.skewX * _), E = Math.sqrt(1 + E * E), b *= E, w *= E)), n = -w, o = b;
						else {
							if(!(N.rotationY || N.rotationX || 1 !== O || H)) return C[bt] = (N.xPercent || N.yPercent ? "translate(" + N.xPercent + "%," + N.yPercent + "%) translate3d(" : "translate3d(") + M + "px," + D + "px," + P + "px)" + (1 !== L || 1 !== A ? " scale(" + L + "," + A + ")" : ""), void 0;
							t = o = 1, n = s = 0
						}
						c = 1, r = i = u = a = f = l = p = d = v = 0, m = H ? -1 / H : 0, g = N.zOrigin, y = 1e5, k = N.rotationY * _, k && (b = Math.cos(k), w = Math.sin(k), f = c * -w, d = m * -w, r = t * w, u = s * w, c *= b, m *= b, t *= b, s *= b), k = N.rotationX * _, k && (b = Math.cos(k), w = Math.sin(k), E = n * b + r * w, S = o * b + u * w, x = l * b + c * w, T = v * b + m * w, r = n * -w + r * b, u = o * -w + u * b, c = l * -w + c * b, m = v * -w + m * b, n = E, o = S, l = x, v = T), 1 !== O && (r *= O, u *= O, c *= O, m *= O), 1 !== A && (n *= A, o *= A, l *= A, v *= A), 1 !== L && (t *= L, s *= L, f *= L, d *= L), g && (p -= g, i = r * p, a = u * p, p = c * p + g), i = (E = (i += M) - (i |= 0)) ? (0 | E * y + (0 > E ? -0.5 : .5)) / y + i : i, a = (E = (a += D) - (a |= 0)) ? (0 | E * y + (0 > E ? -0.5 : .5)) / y + a : a, p = (E = (p += P) - (p |= 0)) ? (0 | E * y + (0 > E ? -0.5 : .5)) / y + p : p, C[bt] = (N.xPercent || N.yPercent ? "translate(" + N.xPercent + "%," + N.yPercent + "%) matrix3d(" : "matrix3d(") + [(0 | t * y) / y, (0 | s * y) / y, (0 | f * y) / y, (0 | d * y) / y, (0 | n * y) / y, (0 | o * y) / y, (0 | l * y) / y, (0 | v * y) / y, (0 | r * y) / y, (0 | u * y) / y, (0 | c * y) / y, (0 | m * y) / y, i, a, p, H ? 1 + -p / H : 1].join(",") + ")"
					},
					kt = F.set2DTransformRatio = function(e) {
						var t, n, r, i, s, o = this.data,
							u = this.t,
							a = u.style,
							f = o.x,
							l = o.y;
						return o.rotationX || o.rotationY || o.z || o.force3D === !0 || "auto" === o.force3D && 1 !== e && 0 !== e ? (this.setRatio = Ct, Ct.call(this, e), void 0) : (o.rotation || o.skewX ? (t = o.rotation * _, n = t - o.skewX * _, r = 1e5, i = o.scaleX * r, s = o.scaleY * r, a[bt] = (o.xPercent || o.yPercent ? "translate(" + o.xPercent + "%," + o.yPercent + "%) matrix(" : "matrix(") + (0 | Math.cos(t) * i) / r + "," + (0 | Math.sin(t) * i) / r + "," + (0 | Math.sin(n) * -s) / r + "," + (0 | Math.cos(n) * s) / r + "," + f + "," + l + ")") : a[bt] = (o.xPercent || o.yPercent ? "translate(" + o.xPercent + "%," + o.yPercent + "%) matrix(" : "matrix(") + o.scaleX + ",0,0," + o.scaleY + "," + f + "," + l + ")", void 0)
					};
				mt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {
					parser: function(e, t, n, r, s, u, a) {
						if(r._transform) return s;
						var f, l, c, h, p, d, v, m = r._transform = Tt(e, i, !0, a.parseTransform),
							g = e.style,
							y = 1e-6,
							b = yt.length,
							w = a,
							E = {};
						if("string" == typeof w.transform && bt) c = B.style, c[bt] = w.transform, c.display = "block", c.position = "absolute", H.body.appendChild(B), f = Tt(B, null, !1), H.body.removeChild(B);
						else if("object" == typeof w) {
							if(f = {
									scaleX: rt(null != w.scaleX ? w.scaleX : w.scale, m.scaleX),
									scaleY: rt(null != w.scaleY ? w.scaleY : w.scale, m.scaleY),
									scaleZ: rt(w.scaleZ, m.scaleZ),
									x: rt(w.x, m.x),
									y: rt(w.y, m.y),
									z: rt(w.z, m.z),
									xPercent: rt(w.xPercent, m.xPercent),
									yPercent: rt(w.yPercent, m.yPercent),
									perspective: rt(w.transformPerspective, m.perspective)
								}, v = w.directionalRotation, null != v)
								if("object" == typeof v)
									for(c in v) w[c] = v[c];
								else w.rotation = v;
							"string" == typeof w.x && -1 !== w.x.indexOf("%") && (f.x = 0, f.xPercent = rt(w.x, m.xPercent)), "string" == typeof w.y && -1 !== w.y.indexOf("%") && (f.y = 0, f.yPercent = rt(w.y, m.yPercent)), f.rotation = it("rotation" in w ? w.rotation : "shortRotation" in w ? w.shortRotation + "_short" : "rotationZ" in w ? w.rotationZ : m.rotation, m.rotation, "rotation", E), St && (f.rotationX = it("rotationX" in w ? w.rotationX : "shortRotationX" in w ? w.shortRotationX + "_short" : m.rotationX || 0, m.rotationX, "rotationX", E), f.rotationY = it("rotationY" in w ? w.rotationY : "shortRotationY" in w ? w.shortRotationY + "_short" : m.rotationY || 0, m.rotationY, "rotationY", E)), f.skewX = null == w.skewX ? m.skewX : it(w.skewX, m.skewX), f.skewY = null == w.skewY ? m.skewY : it(w.skewY, m.skewY), (l = f.skewY - m.skewY) && (f.skewX += l, f.rotation += l)
						}
						for(St && null != w.force3D && (m.force3D = w.force3D, d = !0), m.skewType = w.skewType || m.skewType || o.defaultSkewType, p = m.force3D || m.z || m.rotationX || m.rotationY || f.z || f.rotationX || f.rotationY || f.perspective, p || null == w.scale || (f.scaleZ = 1); --b > -1;) n = yt[b], h = f[n] - m[n], (h > y || -y > h || null != P[n]) && (d = !0, s = new ht(m, n, m[n], h, s), n in E && (s.e = E[n]), s.xs0 = 0, s.plugin = u, r._overwriteProps.push(s.n));
						return h = w.transformOrigin, (h || St && p && m.zOrigin) && (bt ? (d = !0, n = Et, h = (h || $(e, n, i, !1, "50% 50%")) + "", s = new ht(g, n, 0, 0, s, -1, "transformOrigin"), s.b = g[n], s.plugin = u, St ? (c = m.zOrigin, h = h.split(" "), m.zOrigin = (h.length > 2 && (0 === c || "0px" !== h[2]) ? parseFloat(h[2]) : c) || 0, s.xs0 = s.e = h[0] + " " + (h[1] || "50%") + " 0px", s = new ht(m, "zOrigin", 0, 0, s, -1, s.n), s.b = c, s.xs0 = s.e = m.zOrigin) : s.xs0 = s.e = h) : tt(h + "", m)), d && (r._transformType = p || 3 === this._transformType ? 3 : 2), s
					},
					prefix: !0
				}), mt("boxShadow", {
					defaultValue: "0px 0px 0px 0px #999",
					prefix: !0,
					color: !0,
					multi: !0,
					keyword: "inset"
				}), mt("borderRadius", {
					defaultValue: "0px",
					parser: function(e, t, n, s, o) {
						t = this.format(t);
						var u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
							T = e.style;
						for(v = parseFloat(e.offsetWidth), m = parseFloat(e.offsetHeight), u = t.split(" "), a = 0; x.length > a; a++) this.p.indexOf("border") && (x[a] = X(x[a])), c = l = $(e, x[a], i, !1, "0px"), -1 !== c.indexOf(" ") && (l = c.split(" "), c = l[0], l = l[1]), h = f = u[a], p = parseFloat(c), y = c.substr((p + "").length), b = "=" === h.charAt(1), b ? (d = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), d *= parseFloat(h), g = h.substr((d + "").length - (0 > d ? 1 : 0)) || "") : (d = parseFloat(h), g = h.substr((d + "").length)), "" === g && (g = r[n] || y), g !== y && (w = J(e, "borderLeft", p, y), E = J(e, "borderTop", p, y), "%" === g ? (c = 100 * (w / v) + "%", l = 100 * (E / m) + "%") : "em" === g ? (S = J(e, "borderLeft", 1, "em"), c = w / S + "em", l = E / S + "em") : (c = w + "px", l = E + "px"), b && (h = parseFloat(c) + d + g, f = parseFloat(l) + d + g)), o = pt(T, x[a], c + " " + l, h + " " + f, !1, "0px", o);
						return o
					},
					prefix: !0,
					formatter: ft("0px 0px 0px 0px", !1, !0)
				}), mt("backgroundPosition", {
					defaultValue: "0 0",
					parser: function(e, t, n, r, s, o) {
						var u, a, f, l, c, h, p = "background-position",
							v = i || V(e, null),
							m = this.format((v ? d ? v.getPropertyValue(p + "-x") + " " + v.getPropertyValue(p + "-y") : v.getPropertyValue(p) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
							g = this.format(t);
						if(-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && (h = $(e, "backgroundImage").replace(C, ""), h && "none" !== h)) {
							for(u = m.split(" "), a = g.split(" "), j.setAttribute("src", h), f = 2; --f > -1;) m = u[f], l = -1 !== m.indexOf("%"), l !== (-1 !== a[f].indexOf("%")) && (c = 0 === f ? e.offsetWidth - j.width : e.offsetHeight - j.height, u[f] = l ? parseFloat(m) / 100 * c + "px" : 100 * (parseFloat(m) / c) + "%");
							m = u.join(" ")
						}
						return this.parseComplex(e.style, m, g, s, o)
					},
					formatter: tt
				}), mt("backgroundSize", {
					defaultValue: "0 0",
					formatter: tt
				}), mt("perspective", {
					defaultValue: "0px",
					prefix: !0
				}), mt("perspectiveOrigin", {
					defaultValue: "50% 50%",
					prefix: !0
				}), mt("transformStyle", {
					prefix: !0
				}), mt("backfaceVisibility", {
					prefix: !0
				}), mt("userSelect", {
					prefix: !0
				}), mt("margin", {
					parser: lt("marginTop,marginRight,marginBottom,marginLeft")
				}), mt("padding", {
					parser: lt("paddingTop,paddingRight,paddingBottom,paddingLeft")
				}), mt("clip", {
					defaultValue: "rect(0px,0px,0px,0px)",
					parser: function(e, t, n, r, s, o) {
						var u, a, f;
						return 9 > d ? (a = e.currentStyle, f = 8 > d ? " " : ",", u = "rect(" + a.clipTop + f + a.clipRight + f + a.clipBottom + f + a.clipLeft + ")", t = this.format(t).split(",").join(f)) : (u = this.format($(e, this.p, i, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, u, t, s, o)
					}
				}), mt("textShadow", {
					defaultValue: "0px 0px 0px #999",
					color: !0,
					multi: !0
				}), mt("autoRound,strictUnits", {
					parser: function(e, t, n, r, i) {
						return i
					}
				}), mt("border", {
					defaultValue: "0px solid #000",
					parser: function(e, t, n, r, s, o) {
						return this.parseComplex(e.style, this.format($(e, "borderTopWidth", i, !1, "0px") + " " + $(e, "borderTopStyle", i, !1, "solid") + " " + $(e, "borderTopColor", i, !1, "#000")), this.format(t), s, o)
					},
					color: !0,
					formatter: function(e) {
						var t = e.split(" ");
						return t[0] + " " + (t[1] || "solid") + " " + (e.match(at) || ["#000"])[0]
					}
				}), mt("borderWidth", {
					parser: lt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
				}), mt("float,cssFloat,styleFloat", {
					parser: function(e, t, n, r, i) {
						var s = e.style,
							o = "cssFloat" in s ? "cssFloat" : "styleFloat";
						return new ht(s, o, 0, 0, i, -1, n, !1, 0, s[o], t)
					}
				});
				var Lt = function(e) {
					var t, n = this.t,
						r = n.filter || $(this.data, "filter"),
						i = 0 | this.s + this.c * e;
					100 === i && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (n.removeAttribute("filter"), t = !$(this.data, "filter")) : (n.filter = r.replace(S, ""), t = !0)), t || (this.xn1 && (n.filter = r = r || "alpha(opacity=" + i + ")"), -1 === r.indexOf("pacity") ? 0 === i && this.xn1 || (n.filter = r + " alpha(opacity=" + i + ")") : n.filter = r.replace(w, "opacity=" + i))
				};
				mt("opacity,alpha,autoAlpha", {
					defaultValue: "1",
					parser: function(e, t, n, r, s, o) {
						var u = parseFloat($(e, "opacity", i, !1, "1")),
							a = e.style,
							f = "autoAlpha" === n;
						return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + u), f && 1 === u && "hidden" === $(e, "visibility", i) && 0 !== t && (u = 0), q ? s = new ht(a, "opacity", u, t - u, s) : (s = new ht(a, "opacity", 100 * u, 100 * (t - u), s), s.xn1 = f ? 1 : 0, a.zoom = 1, s.type = 2, s.b = "alpha(opacity=" + s.s + ")", s.e = "alpha(opacity=" + (s.s + s.c) + ")", s.data = e, s.plugin = o, s.setRatio = Lt), f && (s = new ht(a, "visibility", 0, 0, s, -1, null, !1, 0, 0 !== u ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit"), s.xs0 = "inherit", r._overwriteProps.push(s.n), r._overwriteProps.push(n)), s
					}
				});
				var At = function(e, t) {
						t && (e.removeProperty ? ("ms" === t.substr(0, 2) && (t = "M" + t.substr(1)), e.removeProperty(t.replace(T, "-$1").toLowerCase())) : e.removeAttribute(t))
					},
					Ot = function(e) {
						if(this.t._gsClassPT = this, 1 === e || 0 === e) {
							this.t.setAttribute("class", 0 === e ? this.b : this.e);
							for(var t = this.data, n = this.t.style; t;) t.v ? n[t.p] = t.v : At(n, t.p), t = t._next;
							1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
						} else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
					};
				mt("className", {
					parser: function(e, t, r, s, o, u, a) {
						var f, l, c, h, p, d = e.getAttribute("class") || "",
							v = e.style.cssText;
						if(o = s._classNamePT = new ht(e, r, 0, 0, o, 2), o.setRatio = Ot, o.pr = -11, n = !0, o.b = d, l = Q(e, i), c = e._gsClassPT) {
							for(h = {}, p = c.data; p;) h[p.p] = 1, p = p._next;
							c.setRatio(1)
						}
						return e._gsClassPT = o, o.e = "=" !== t.charAt(1) ? t : d.replace(RegExp("\\s*\\b" + t.substr(2) + "\\b"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), s._tween._duration && (e.setAttribute("class", o.e), f = G(e, l, Q(e), a, h), e.setAttribute("class", d), o.data = f.firstMPT, e.style.cssText = v, o = o.xfirst = s.parse(e, f.difs, o, u)), o
					}
				});
				var Mt = function(e) {
					if((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
						var t, n, r, i, s = this.t.style,
							o = u.transform.parse;
						if("all" === this.e) s.cssText = "", i = !0;
						else
							for(t = this.e.split(","), r = t.length; --r > -1;) n = t[r], u[n] && (u[n].parse === o ? i = !0 : n = "transformOrigin" === n ? Et : u[n].p), At(s, n);
						i && (At(s, bt), this.t._gsTransform && delete this.t._gsTransform)
					}
				};
				for(mt("clearProps", {
						parser: function(e, t, r, i, s) {
							return s = new ht(e, r, 0, 0, s, 2), s.setRatio = Mt, s.e = t, s.pr = -10, s.data = i._tween, n = !0, s
						}
					}), a = "bezier,throwProps,physicsProps,physics2D".split(","), dt = a.length; dt--;) gt(a[dt]);
				a = o.prototype, a._firstPT = null, a._onInitTween = function(e, t, u) {
					if(!e.nodeType) return !1;
					this._target = e, this._tween = u, this._vars = t, f = t.autoRound, n = !1, r = t.suffixMap || o.suffixMap, i = V(e, ""), s = this._overwriteProps;
					var a, h, d, v, m, g, y, b, w, S = e.style;
					if(l && "" === S.zIndex && (a = $(e, "zIndex", i), ("auto" === a || "" === a) && this._addLazySet(S, "zIndex", 0)), "string" == typeof t && (v = S.cssText, a = Q(e, i), S.cssText = v + ";" + t, a = G(e, a, Q(e)).difs, !q && E.test(t) && (a.opacity = parseFloat(RegExp.$1)), t = a, S.cssText = v), this._firstPT = h = this.parse(e, t, null), this._transformType) {
						for(w = 3 === this._transformType, bt ? c && (l = !0, "" === S.zIndex && (y = $(e, "zIndex", i), ("auto" === y || "" === y) && this._addLazySet(S, "zIndex", 0)), p && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (w ? "visible" : "hidden"))) : S.zoom = 1, d = h; d && d._next;) d = d._next;
						b = new ht(e, "transform", 0, 0, null, 2), this._linkCSSP(b, null, d), b.setRatio = w && St ? Ct : bt ? kt : Nt, b.data = this._transform || Tt(e, i, !0), s.pop()
					}
					if(n) {
						for(; h;) {
							for(g = h._next, d = v; d && d.pr > h.pr;) d = d._next;
							(h._prev = d ? d._prev : m) ? h._prev._next = h: v = h, (h._next = d) ? d._prev = h : m = h, h = g
						}
						this._firstPT = v
					}
					return !0
				}, a.parse = function(e, t, n, s) {
					var o, a, l, c, h, p, d, v, m, g, y = e.style;
					for(o in t) p = t[o], a = u[o], a ? n = a.parse(e, p, o, this, n, s, t) : (h = $(e, o, i) + "", m = "string" == typeof p, "color" === o || "fill" === o || "stroke" === o || -1 !== o.indexOf("Color") || m && x.test(p) ? (m || (p = ut(p), p = (p.length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), n = pt(y, o, h, p, !0, "transparent", n, 0, s)) : !m || -1 === p.indexOf(" ") && -1 === p.indexOf(",") ? (l = parseFloat(h), d = l || 0 === l ? h.substr((l + "").length) : "", ("" === h || "auto" === h) && ("width" === o || "height" === o ? (l = et(e, o, i), d = "px") : "left" === o || "top" === o ? (l = K(e, o, i), d = "px") : (l = "opacity" !== o ? 0 : 1, d = "")), g = m && "=" === p.charAt(1), g ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), v = p.replace(b, "")) : (c = parseFloat(p), v = m ? p.substr((c + "").length) || "" : ""), "" === v && (v = o in r ? r[o] : d), p = c || 0 === c ? (g ? c + l : c) + v : t[o], d !== v && "" !== v && (c || 0 === c) && l && (l = J(e, o, l, d), "%" === v ? (l /= J(e, o, 100, "%") / 100, t.strictUnits !== !0 && (h = l + "%")) : "em" === v ? l /= J(e, o, 1, "em") : "px" !== v && (c = J(e, o, c, v), v = "px"), g && (c || 0 === c) && (p = c + l + v)), g && (c += l), !l && 0 !== l || !c && 0 !== c ? void 0 !== y[o] && (p || "NaN" != p + "" && null != p) ? (n = new ht(y, o, c || l || 0, 0, n, -1, o, !1, 0, h, p), n.xs0 = "none" !== p || "display" !== o && -1 === o.indexOf("Style") ? p : h) : U("invalid " + o + " tween value: " + t[o]) : (n = new ht(y, o, l, c - l, n, 0, o, f !== !1 && ("px" === v || "zIndex" === o), 0, h, p), n.xs0 = v)) : n = pt(y, o, h, p, !0, null, n, 0, s)), s && n && !n.plugin && (n.plugin = s);
					return n
				}, a.setRatio = function(e) {
					var t, n, r, i = this._firstPT,
						s = 1e-6;
					if(1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
						if(e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -0.000001)
							for(; i;) {
								if(t = i.c * e + i.s, i.r ? t = Math.round(t) : s > t && t > -s && (t = 0), i.type)
									if(1 === i.type)
										if(r = i.l, 2 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2;
										else if(3 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3;
								else if(4 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4;
								else if(5 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4 + i.xn4 + i.xs5;
								else {
									for(n = i.xs0 + t + i.xs1, r = 1; i.l > r; r++) n += i["xn" + r] + i["xs" + (r + 1)];
									i.t[i.p] = n
								} else -1 === i.type ? i.t[i.p] = i.xs0 : i.setRatio && i.setRatio(e);
								else i.t[i.p] = t + i.xs0;
								i = i._next
							} else
								for(; i;) 2 !== i.type ? i.t[i.p] = i.b : i.setRatio(e), i = i._next;
						else
							for(; i;) 2 !== i.type ? i.t[i.p] = i.e : i.setRatio(e), i = i._next
				}, a._enableTransforms = function(e) {
					this._transformType = e || 3 === this._transformType ? 3 : 2, this._transform = this._transform || Tt(this._target, i, !0)
				};
				var _t = function() {
					this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
				};
				a._addLazySet = function(e, t, n) {
					var r = this._firstPT = new ht(e, t, 0, 0, this._firstPT, 2);
					r.e = n, r.setRatio = _t, r.data = this
				}, a._linkCSSP = function(e, t, n, r) {
					return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, r = !0), n ? n._next = e : r || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = n), e
				}, a._kill = function(t) {
					var n, r, i, s = t;
					if(t.autoAlpha || t.alpha) {
						s = {};
						for(r in t) s[r] = t[r];
						s.opacity = 1, s.autoAlpha && (s.visibility = 1)
					}
					return t.className && (n = this._classNamePT) && (i = n.xfirst, i && i._prev ? this._linkCSSP(i._prev, n._next, i._prev._prev) : i === this._firstPT && (this._firstPT = n._next), n._next && this._linkCSSP(n._next, n._next._next, i._prev), this._classNamePT = null), e.prototype._kill.call(this, s)
				};
				var Dt = function(e, t, n) {
					var r, i, s, o;
					if(e.slice)
						for(i = e.length; --i > -1;) Dt(e[i], t, n);
					else
						for(r = e.childNodes, i = r.length; --i > -1;) s = r[i], o = s.type, s.style && (t.push(Q(s)), n && n.push(s)), 1 !== o && 9 !== o && 11 !== o || !s.childNodes.length || Dt(s, t, n)
				};
				return o.cascadeTo = function(e, n, r) {
					var i, s, o, u = t.to(e, n, r),
						a = [u],
						f = [],
						l = [],
						c = [],
						h = t._internals.reservedProps;
					for(e = u._targets || u.target, Dt(e, f, c), u.render(n, !0), Dt(e, l), u.render(0, !0), u._enabled(!0), i = c.length; --i > -1;)
						if(s = G(c[i], f[i], l[i]), s.firstMPT) {
							s = s.difs;
							for(o in r) h[o] && (s[o] = r[o]);
							a.push(t.to(c[i], n, s))
						}
					return a
				}, e.activate([o]), o
			}, !0),
			function() {
				var e = _gsScope._gsDefine.plugin({
						propName: "roundProps",
						priority: -1,
						API: 2,
						init: function(e, t, n) {
							return this._tween = n, !0
						}
					}),
					t = e.prototype;
				t._onInitAllProps = function() {
					for(var e, t, n, r = this._tween, i = r.vars.roundProps instanceof Array ? r.vars.roundProps : r.vars.roundProps.split(","), s = i.length, o = {}, u = r._propLookup.roundProps; --s > -1;) o[i[s]] = 1;
					for(s = i.length; --s > -1;)
						for(e = i[s], t = r._firstPT; t;) n = t._next, t.pg ? t.t._roundProps(o, !0) : t.n === e && (this._add(t.t, e, t.s, t.c), n && (n._prev = t._prev), t._prev ? t._prev._next = n : r._firstPT === t && (r._firstPT = n), t._next = t._prev = null, r._propLookup[e] = u), t = n;
					return !1
				}, t._add = function(e, t, n, r) {
					this._addTween(e, t, n, n + r, t, !0), this._overwriteProps.push(t)
				}
			}(), _gsScope._gsDefine.plugin({
				propName: "attr",
				API: 2,
				version: "0.3.3",
				init: function(e, t) {
					var n, r, i;
					if("function" != typeof e.setAttribute) return !1;
					this._target = e, this._proxy = {}, this._start = {}, this._end = {};
					for(n in t) this._start[n] = this._proxy[n] = r = e.getAttribute(n), i = this._addTween(this._proxy, n, parseFloat(r), t[n], n), this._end[n] = i ? i.s + i.c : t[n], this._overwriteProps.push(n);
					return !0
				},
				set: function(e) {
					this._super.setRatio.call(this, e);
					for(var t, n = this._overwriteProps, r = n.length, i = 1 === e ? this._end : e ? this._proxy : this._start; --r > -1;) t = n[r], this._target.setAttribute(t, i[t] + "")
				}
			}), _gsScope._gsDefine.plugin({
				propName: "directionalRotation",
				version: "0.2.1",
				API: 2,
				init: function(e, t) {
					"object" != typeof t && (t = {
						rotation: t
					}), this.finals = {};
					var n, r, i, s, o, u, a = t.useRadians === !0 ? 2 * Math.PI : 360,
						f = 1e-6;
					for(n in t) "useRadians" !== n && (u = (t[n] + "").split("_"), r = u[0], i = parseFloat("function" != typeof e[n] ? e[n] : e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]()), s = this.finals[n] = "string" == typeof r && "=" === r.charAt(1) ? i + parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2)) : Number(r) || 0, o = s - i, u.length && (r = u.join("_"), -1 !== r.indexOf("short") && (o %= a, o !== o % (a / 2) && (o = 0 > o ? o + a : o - a)), -1 !== r.indexOf("_cw") && 0 > o ? o = (o + 9999999999 * a) % a - (0 | o / a) * a : -1 !== r.indexOf("ccw") && o > 0 && (o = (o - 9999999999 * a) % a - (0 | o / a) * a)), (o > f || -f > o) && (this._addTween(e, n, i, i + o, n), this._overwriteProps.push(n)));
					return !0
				},
				set: function(e) {
					var t;
					if(1 !== e) this._super.setRatio.call(this, e);
					else
						for(t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next
				}
			})._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(e) {
				var t, n, r, i = _gsScope.GreenSockGlobals || _gsScope,
					s = i.com.greensock,
					o = 2 * Math.PI,
					u = Math.PI / 2,
					a = s._class,
					f = function(t, n) {
						var r = a("easing." + t, function() {}, !0),
							i = r.prototype = new e;
						return i.constructor = r, i.getRatio = n, r
					},
					l = e.register || function() {},
					c = function(e, t, n, r) {
						var i = a("easing." + e, {
							easeOut: new t,
							easeIn: new n,
							easeInOut: new r
						}, !0);
						return l(i, e), i
					},
					h = function(e, t, n) {
						this.t = e, this.v = t, n && (this.next = n, n.prev = this, this.c = n.v - t, this.gap = n.t - e)
					},
					p = function(t, n) {
						var r = a("easing." + t, function(e) {
								this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
							}, !0),
							i = r.prototype = new e;
						return i.constructor = r, i.getRatio = n, i.config = function(e) {
							return new r(e)
						}, r
					},
					d = c("Back", p("BackOut", function(e) {
						return(e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
					}), p("BackIn", function(e) {
						return e * e * ((this._p1 + 1) * e - this._p1)
					}), p("BackInOut", function(e) {
						return 1 > (e *= 2) ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
					})),
					v = a("easing.SlowMo", function(e, t, n) {
						t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = n === !0
					}, !0),
					m = v.prototype = new e;
				return m.constructor = v, m.getRatio = function(e) {
					var t = e + (.5 - e) * this._p;
					return this._p1 > e ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
				}, v.ease = new v(.7, .7), m.config = v.config = function(e, t, n) {
					return new v(e, t, n)
				}, t = a("easing.SteppedEase", function(e) {
					e = e || 1, this._p1 = 1 / e, this._p2 = e + 1
				}, !0), m = t.prototype = new e, m.constructor = t, m.getRatio = function(e) {
					return 0 > e ? e = 0 : e >= 1 && (e = .999999999), (this._p2 * e >> 0) * this._p1
				}, m.config = t.config = function(e) {
					return new t(e)
				}, n = a("easing.RoughEase", function(t) {
					t = t || {};
					for(var n, r, i, s, o, u, a = t.taper || "none", f = [], l = 0, c = 0 | (t.points || 20), p = c, d = t.randomize !== !1, v = t.clamp === !0, m = t.template instanceof e ? t.template : null, g = "number" == typeof t.strength ? .4 * t.strength : .4; --p > -1;) n = d ? Math.random() : 1 / c * p, r = m ? m.getRatio(n) : n, "none" === a ? i = g : "out" === a ? (s = 1 - n, i = s * s * g) : "in" === a ? i = n * n * g : .5 > n ? (s = 2 * n, i = .5 * s * s * g) : (s = 2 * (1 - n), i = .5 * s * s * g), d ? r += Math.random() * i - .5 * i : p % 2 ? r += .5 * i : r -= .5 * i, v && (r > 1 ? r = 1 : 0 > r && (r = 0)), f[l++] = {
						x: n,
						y: r
					};
					for(f.sort(function(e, t) {
							return e.x - t.x
						}), u = new h(1, 1, null), p = c; --p > -1;) o = f[p], u = new h(o.x, o.y, u);
					this._prev = new h(0, 0, 0 !== u.t ? u : u.next)
				}, !0), m = n.prototype = new e, m.constructor = n, m.getRatio = function(e) {
					var t = this._prev;
					if(e > t.t) {
						for(; t.next && e >= t.t;) t = t.next;
						t = t.prev
					} else
						for(; t.prev && t.t >= e;) t = t.prev;
					return this._prev = t, t.v + (e - t.t) / t.gap * t.c
				}, m.config = function(e) {
					return new n(e)
				}, n.ease = new n, c("Bounce", f("BounceOut", function(e) {
					return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
				}), f("BounceIn", function(e) {
					return 1 / 2.75 > (e = 1 - e) ? 1 - 7.5625 * e * e : 2 / 2.75 > e ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : 2.5 / 2.75 > e ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
				}), f("BounceInOut", function(e) {
					var t = .5 > e;
					return e = t ? 1 - 2 * e : 2 * e - 1, e = 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
				})), c("Circ", f("CircOut", function(e) {
					return Math.sqrt(1 - (e -= 1) * e)
				}), f("CircIn", function(e) {
					return -(Math.sqrt(1 - e * e) - 1)
				}), f("CircInOut", function(e) {
					return 1 > (e *= 2) ? -0.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
				})), r = function(t, n, r) {
					var i = a("easing." + t, function(e, t) {
							this._p1 = e || 1, this._p2 = t || r, this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0)
						}, !0),
						s = i.prototype = new e;
					return s.constructor = i, s.getRatio = n, s.config = function(e, t) {
						return new i(e, t)
					}, i
				}, c("Elastic", r("ElasticOut", function(e) {
					return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * o / this._p2) + 1
				}, .3), r("ElasticIn", function(e) {
					return -(this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * o / this._p2))
				}, .3), r("ElasticInOut", function(e) {
					return 1 > (e *= 2) ? -0.5 * this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * o / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * o / this._p2) + 1
				}, .45)), c("Expo", f("ExpoOut", function(e) {
					return 1 - Math.pow(2, -10 * e)
				}), f("ExpoIn", function(e) {
					return Math.pow(2, 10 * (e - 1)) - .001
				}), f("ExpoInOut", function(e) {
					return 1 > (e *= 2) ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
				})), c("Sine", f("SineOut", function(e) {
					return Math.sin(e * u)
				}), f("SineIn", function(e) {
					return -Math.cos(e * u) + 1
				}), f("SineInOut", function(e) {
					return -0.5 * (Math.cos(Math.PI * e) - 1)
				})), a("easing.EaseLookup", {
					find: function(t) {
						return e.map[t]
					}
				}, !0), l(i.SlowMo, "SlowMo", "ease,"), l(n, "RoughEase", "ease,"), l(t, "SteppedEase", "ease,"), d
			}, !0)
	}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
	function(e, t) {
		var n = e.GreenSockGlobals = e.GreenSockGlobals || e;
		if(!n.TweenLite) {
			var r, i, s, o, u, a = function(e) {
					var t, r = e.split("."),
						i = n;
					for(t = 0; r.length > t; t++) i[r[t]] = i = i[r[t]] || {};
					return i
				},
				f = a("com.greensock"),
				l = 1e-10,
				c = function(e) {
					var t, n = [],
						r = e.length;
					for(t = 0; t !== r; n.push(e[t++]));
					return n
				},
				h = function() {},
				p = function() {
					var e = Object.prototype.toString,
						t = e.call([]);
					return function(n) {
						return null != n && (n instanceof Array || "object" == typeof n && !!n.push && e.call(n) === t)
					}
				}(),
				d = {},
				v = function(r, i, s, o) {
					this.sc = d[r] ? d[r].sc : [], d[r] = this, this.gsClass = null, this.func = s;
					var u = [];
					this.check = function(f) {
						for(var l, c, h, p, m = i.length, g = m; --m > -1;)(l = d[i[m]] || new v(i[m], [])).gsClass ? (u[m] = l.gsClass, g--) : f && l.sc.push(this);
						if(0 === g && s)
							for(c = ("com.greensock." + r).split("."), h = c.pop(), p = a(c.join("."))[h] = this.gsClass = s.apply(s, u), o && (n[h] = p, "function" == typeof define && define.amd ? define((e.GreenSockAMDPath ? e.GreenSockAMDPath + "/" : "") + r.split(".").pop(), [], function() {
									return p
								}) : r === t && "undefined" != typeof module && module.exports && (module.exports = p)), m = 0; this.sc.length > m; m++) this.sc[m].check()
					}, this.check(!0)
				},
				m = e._gsDefine = function(e, t, n, r) {
					return new v(e, t, n, r)
				},
				g = f._class = function(e, t, n) {
					return t = t || function() {}, m(e, [], function() {
						return t
					}, n), t
				};
			m.globals = n;
			var y = [0, 0, 1, 1],
				b = [],
				w = g("easing.Ease", function(e, t, n, r) {
					this._func = e, this._type = n || 0, this._power = r || 0, this._params = t ? y.concat(t) : y
				}, !0),
				E = w.map = {},
				S = w.register = function(e, t, n, r) {
					for(var i, s, o, u, a = t.split(","), l = a.length, c = (n || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
						for(s = a[l], i = r ? g("easing." + s, null, !0) : f.easing[s] || {}, o = c.length; --o > -1;) u = c[o], E[s + "." + u] = E[u + s] = i[u] = e.getRatio ? e : e[u] || new e
				};
			for(s = w.prototype, s._calcEnd = !1, s.getRatio = function(e) {
					if(this._func) return this._params[0] = e, this._func.apply(null, this._params);
					var t = this._type,
						n = this._power,
						r = 1 === t ? 1 - e : 2 === t ? e : .5 > e ? 2 * e : 2 * (1 - e);
					return 1 === n ? r *= r : 2 === n ? r *= r * r : 3 === n ? r *= r * r * r : 4 === n && (r *= r * r * r * r), 1 === t ? 1 - r : 2 === t ? r : .5 > e ? r / 2 : 1 - r / 2
				}, r = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], i = r.length; --i > -1;) s = r[i] + ",Power" + i, S(new w(null, null, 1, i), s, "easeOut", !0), S(new w(null, null, 2, i), s, "easeIn" + (0 === i ? ",easeNone" : "")), S(new w(null, null, 3, i), s, "easeInOut");
			E.linear = f.easing.Linear.easeIn, E.swing = f.easing.Quad.easeInOut;
			var x = g("events.EventDispatcher", function(e) {
				this._listeners = {}, this._eventTarget = e || this
			});
			s = x.prototype, s.addEventListener = function(e, t, n, r, i) {
				i = i || 0;
				var s, a, f = this._listeners[e],
					l = 0;
				for(null == f && (this._listeners[e] = f = []), a = f.length; --a > -1;) s = f[a], s.c === t && s.s === n ? f.splice(a, 1) : 0 === l && i > s.pr && (l = a + 1);
				f.splice(l, 0, {
					c: t,
					s: n,
					up: r,
					pr: i
				}), this !== o || u || o.wake()
			}, s.removeEventListener = function(e, t) {
				var n, r = this._listeners[e];
				if(r)
					for(n = r.length; --n > -1;)
						if(r[n].c === t) return r.splice(n, 1), void 0
			}, s.dispatchEvent = function(e) {
				var t, n, r, i = this._listeners[e];
				if(i)
					for(t = i.length, n = this._eventTarget; --t > -1;) r = i[t], r.up ? r.c.call(r.s || n, {
						type: e,
						target: n
					}) : r.c.call(r.s || n)
			};
			var T = e.requestAnimationFrame,
				N = e.cancelAnimationFrame,
				C = Date.now || function() {
					return(new Date).getTime()
				},
				k = C();
			for(r = ["ms", "moz", "webkit", "o"], i = r.length; --i > -1 && !T;) T = e[r[i] + "RequestAnimationFrame"], N = e[r[i] + "CancelAnimationFrame"] || e[r[i] + "CancelRequestAnimationFrame"];
			g("Ticker", function(e, t) {
				var n, r, i, s, a, f = this,
					c = C(),
					p = t !== !1 && T,
					d = 500,
					v = 33,
					m = function(e) {
						var t, o, u = C() - k;
						u > d && (c += u - v), k += u, f.time = (k - c) / 1e3, t = f.time - a, (!n || t > 0 || e === !0) && (f.frame++, a += t + (t >= s ? .004 : s - t), o = !0), e !== !0 && (i = r(m)), o && f.dispatchEvent("tick")
					};
				x.call(f), f.time = f.frame = 0, f.tick = function() {
					m(!0)
				}, f.lagSmoothing = function(e, t) {
					d = e || 1 / l, v = Math.min(t, d, 0)
				}, f.sleep = function() {
					null != i && (p && N ? N(i) : clearTimeout(i), r = h, i = null, f === o && (u = !1))
				}, f.wake = function() {
					null !== i ? f.sleep() : f.frame > 10 && (k = C() - d + 5), r = 0 === n ? h : p && T ? T : function(e) {
						return setTimeout(e, 0 | 1e3 * (a - f.time) + 1)
					}, f === o && (u = !0), m(2)
				}, f.fps = function(e) {
					return arguments.length ? (n = e, s = 1 / (n || 60), a = this.time + s, f.wake(), void 0) : n
				}, f.useRAF = function(e) {
					return arguments.length ? (f.sleep(), p = e, f.fps(n), void 0) : p
				}, f.fps(e), setTimeout(function() {
					p && (!i || 5 > f.frame) && f.useRAF(!1)
				}, 1500)
			}), s = f.Ticker.prototype = new f.events.EventDispatcher, s.constructor = f.Ticker;
			var L = g("core.Animation", function(e, t) {
				if(this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = t.immediateRender === !0, this.data = t.data, this._reversed = t.reversed === !0, z) {
					u || o.wake();
					var n = this.vars.useFrames ? U : z;
					n.add(this, n._time), this.vars.paused && this.paused(!0)
				}
			});
			o = L.ticker = new f.Ticker, s = L.prototype, s._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1;
			var A = function() {
				u && C() - k > 2e3 && o.wake(), setTimeout(A, 2e3)
			};
			A(), s.play = function(e, t) {
				return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
			}, s.pause = function(e, t) {
				return null != e && this.seek(e, t), this.paused(!0)
			}, s.resume = function(e, t) {
				return null != e && this.seek(e, t), this.paused(!1)
			}, s.seek = function(e, t) {
				return this.totalTime(Number(e), t !== !1)
			}, s.restart = function(e, t) {
				return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, t !== !1, !0)
			}, s.reverse = function(e, t) {
				return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
			}, s.render = function() {}, s.invalidate = function() {
				return this
			}, s.isActive = function() {
				var e, t = this._timeline,
					n = this._startTime;
				return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime()) >= n && n + this.totalDuration() / this._timeScale > e
			}, s._enabled = function(e, t) {
				return u || o.wake(), this._gc = !e, this._active = this.isActive(), t !== !0 && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
			}, s._kill = function() {
				return this._enabled(!1, !1)
			}, s.kill = function(e, t) {
				return this._kill(e, t), this
			}, s._uncache = function(e) {
				for(var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
				return this
			}, s._swapSelfInParams = function(e) {
				for(var t = e.length, n = e.concat(); --t > -1;) "{self}" === e[t] && (n[t] = this);
				return n
			}, s.eventCallback = function(e, t, n, r) {
				if("on" === (e || "").substr(0, 2)) {
					var i = this.vars;
					if(1 === arguments.length) return i[e];
					null == t ? delete i[e] : (i[e] = t, i[e + "Params"] = p(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, i[e + "Scope"] = r), "onUpdate" === e && (this._onUpdate = t)
				}
				return this
			}, s.delay = function(e) {
				return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
			}, s.duration = function(e) {
				return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
			}, s.totalDuration = function(e) {
				return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
			}, s.time = function(e, t) {
				return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
			}, s.totalTime = function(e, t, n) {
				if(u || o.wake(), !arguments.length) return this._totalTime;
				if(this._timeline) {
					if(0 > e && !n && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
						this._dirty && this.totalDuration();
						var r = this._totalDuration,
							i = this._timeline;
						if(e > r && !n && (e = r), this._startTime = (this._paused ? this._pauseTime : i._time) - (this._reversed ? r - e : e) / this._timeScale, i._dirty || this._uncache(!1), i._timeline)
							for(; i._timeline;) i._timeline._time !== (i._startTime + i._totalTime) / i._timeScale && i.totalTime(i._totalTime, !0), i = i._timeline
					}
					this._gc && this._enabled(!0, !1), (this._totalTime !== e || 0 === this._duration) && (this.render(e, t, !1), P.length && W())
				}
				return this
			}, s.progress = s.totalProgress = function(e, t) {
				return arguments.length ? this.totalTime(this.duration() * e, t) : this._time / this.duration()
			}, s.startTime = function(e) {
				return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
			}, s.timeScale = function(e) {
				if(!arguments.length) return this._timeScale;
				if(e = e || l, this._timeline && this._timeline.smoothChildTiming) {
					var t = this._pauseTime,
						n = t || 0 === t ? t : this._timeline.totalTime();
					this._startTime = n - (n - this._startTime) * this._timeScale / e
				}
				return this._timeScale = e, this._uncache(!1)
			}, s.reversed = function(e) {
				return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
			}, s.paused = function(e) {
				if(!arguments.length) return this._paused;
				if(e != this._paused && this._timeline) {
					u || e || o.wake();
					var t = this._timeline,
						n = t.rawTime(),
						r = n - this._pauseTime;
					!e && t.smoothChildTiming && (this._startTime += r, this._uncache(!1)), this._pauseTime = e ? n : null, this._paused = e, this._active = this.isActive(), !e && 0 !== r && this._initted && this.duration() && this.render(t.smoothChildTiming ? this._totalTime : (n - this._startTime) / this._timeScale, !0, !0)
				}
				return this._gc && !e && this._enabled(!0, !1), this
			};
			var O = g("core.SimpleTimeline", function(e) {
				L.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
			});
			s = O.prototype = new L, s.constructor = O, s.kill()._gc = !1, s._first = s._last = null, s._sortChildren = !1, s.add = s.insert = function(e, t) {
				var n, r;
				if(e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = e._startTime + (this.rawTime() - e._startTime) / e._timeScale), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), n = this._last, this._sortChildren)
					for(r = e._startTime; n && n._startTime > r;) n = n._prev;
				return n ? (e._next = n._next, n._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = n, this._timeline && this._uncache(!0), this
			}, s._remove = function(e, t) {
				return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, this._timeline && this._uncache(!0)), this
			}, s.render = function(e, t, n) {
				var r, i = this._first;
				for(this._totalTime = this._time = this._rawPrevTime = e; i;) r = i._next, (i._active || e >= i._startTime && !i._paused) && (i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)), i = r
			}, s.rawTime = function() {
				return u || o.wake(), this._totalTime
			};
			var M = g("TweenLite", function(t, n, r) {
					if(L.call(this, n, r), this.render = M.prototype.render, null == t) throw "Cannot tween a null target.";
					this.target = t = "string" != typeof t ? t : M.selector(t) || t;
					var i, s, o, u = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
						a = this.vars.overwrite;
					if(this._overwrite = a = null == a ? R[M.defaultOverwrite] : "number" == typeof a ? a >> 0 : R[a], (u || t instanceof Array || t.push && p(t)) && "number" != typeof t[0])
						for(this._targets = o = c(t), this._propLookup = [], this._siblings = [], i = 0; o.length > i; i++) s = o[i], s ? "string" != typeof s ? s.length && s !== e && s[0] && (s[0] === e || s[0].nodeType && s[0].style && !s.nodeType) ? (o.splice(i--, 1), this._targets = o = o.concat(c(s))) : (this._siblings[i] = X(s, this, !1), 1 === a && this._siblings[i].length > 1 && V(s, this, null, 1, this._siblings[i])) : (s = o[i--] = M.selector(s), "string" == typeof s && o.splice(i + 1, 1)) : o.splice(i--, 1);
					else this._propLookup = {}, this._siblings = X(t, this, !1), 1 === a && this._siblings.length > 1 && V(t, this, null, 1, this._siblings);
					(this.vars.immediateRender || 0 === n && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -l, this.render(-this._delay))
				}, !0),
				_ = function(t) {
					return t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
				},
				D = function(e, t) {
					var n, r = {};
					for(n in e) q[n] || n in t && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!j[n] || j[n] && j[n]._autoCSS) || (r[n] = e[n], delete e[n]);
					e.css = r
				};
			s = M.prototype = new L, s.constructor = M, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = s._lazy = !1, M.version = "1.13.1", M.defaultEase = s._ease = new w(null, null, 1, 1), M.defaultOverwrite = "auto", M.ticker = o, M.autoSleep = !0, M.lagSmoothing = function(e, t) {
				o.lagSmoothing(e, t)
			}, M.selector = e.$ || e.jQuery || function(t) {
				var n = e.$ || e.jQuery;
				return n ? (M.selector = n, n(t)) : "undefined" == typeof document ? t : document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
			};
			var P = [],
				H = {},
				B = M._internals = {
					isArray: p,
					isSelector: _,
					lazyTweens: P
				},
				j = M._plugins = {},
				F = B.tweenLookup = {},
				I = 0,
				q = B.reservedProps = {
					ease: 1,
					delay: 1,
					overwrite: 1,
					onComplete: 1,
					onCompleteParams: 1,
					onCompleteScope: 1,
					useFrames: 1,
					runBackwards: 1,
					startAt: 1,
					onUpdate: 1,
					onUpdateParams: 1,
					onUpdateScope: 1,
					onStart: 1,
					onStartParams: 1,
					onStartScope: 1,
					onReverseComplete: 1,
					onReverseCompleteParams: 1,
					onReverseCompleteScope: 1,
					onRepeat: 1,
					onRepeatParams: 1,
					onRepeatScope: 1,
					easeParams: 1,
					yoyo: 1,
					immediateRender: 1,
					repeat: 1,
					repeatDelay: 1,
					data: 1,
					paused: 1,
					reversed: 1,
					autoCSS: 1,
					lazy: 1
				},
				R = {
					none: 0,
					all: 1,
					auto: 2,
					concurrent: 3,
					allOnStart: 4,
					preexisting: 5,
					"true": 1,
					"false": 0
				},
				U = L._rootFramesTimeline = new O,
				z = L._rootTimeline = new O,
				W = B.lazyRender = function() {
					var e = P.length;
					for(H = {}; --e > -1;) r = P[e], r && r._lazy !== !1 && (r.render(r._lazy, !1, !0), r._lazy = !1);
					P.length = 0
				};
			z._startTime = o.time, U._startTime = o.frame, z._active = U._active = !0, setTimeout(W, 1), L._updateRoot = M.render = function() {
				var e, t, n;
				if(P.length && W(), z.render((o.time - z._startTime) * z._timeScale, !1, !1), U.render((o.frame - U._startTime) * U._timeScale, !1, !1), P.length && W(), !(o.frame % 120)) {
					for(n in F) {
						for(t = F[n].tweens, e = t.length; --e > -1;) t[e]._gc && t.splice(e, 1);
						0 === t.length && delete F[n]
					}
					if(n = z._first, (!n || n._paused) && M.autoSleep && !U._first && 1 === o._listeners.tick.length) {
						for(; n && n._paused;) n = n._next;
						n || o.sleep()
					}
				}
			}, o.addEventListener("tick", L._updateRoot);
			var X = function(e, t, n) {
					var r, i, s = e._gsTweenID;
					if(F[s || (e._gsTweenID = s = "t" + I++)] || (F[s] = {
							target: e,
							tweens: []
						}), t && (r = F[s].tweens, r[i = r.length] = t, n))
						for(; --i > -1;) r[i] === t && r.splice(i, 1);
					return F[s].tweens
				},
				V = function(e, t, n, r, i) {
					var s, o, u, a;
					if(1 === r || r >= 4) {
						for(a = i.length, s = 0; a > s; s++)
							if((u = i[s]) !== t) u._gc || u._enabled(!1, !1) && (o = !0);
							else if(5 === r) break;
						return o
					}
					var f, c = t._startTime + l,
						h = [],
						p = 0,
						d = 0 === t._duration;
					for(s = i.length; --s > -1;)(u = i[s]) === t || u._gc || u._paused || (u._timeline !== t._timeline ? (f = f || $(t, 0, d), 0 === $(u, f, d) && (h[p++] = u)) : c >= u._startTime && u._startTime + u.totalDuration() / u._timeScale > c && ((d || !u._initted) && 2e-10 >= c - u._startTime || (h[p++] = u)));
					for(s = p; --s > -1;) u = h[s], 2 === r && u._kill(n, e) && (o = !0), (2 !== r || !u._firstPT && u._initted) && u._enabled(!1, !1) && (o = !0);
					return o
				},
				$ = function(e, t, n) {
					for(var r = e._timeline, i = r._timeScale, s = e._startTime; r._timeline;) {
						if(s += r._startTime, i *= r._timeScale, r._paused) return -100;
						r = r._timeline
					}
					return s /= i, s > t ? s - t : n && s === t || !e._initted && 2 * l > s - t ? l : (s += e.totalDuration() / e._timeScale / i) > t + l ? 0 : s - t - l
				};
			s._init = function() {
				var e, t, n, r, i, s = this.vars,
					o = this._overwrittenProps,
					u = this._duration,
					a = !!s.immediateRender,
					f = s.ease;
				if(s.startAt) {
					this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), i = {};
					for(r in s.startAt) i[r] = s.startAt[r];
					if(i.overwrite = !1, i.immediateRender = !0, i.lazy = a && s.lazy !== !1, i.startAt = i.delay = null, this._startAt = M.to(this.target, 0, i), a)
						if(this._time > 0) this._startAt = null;
						else if(0 !== u) return
				} else if(s.runBackwards && 0 !== u)
					if(this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
					else {
						n = {};
						for(r in s) q[r] && "autoCSS" !== r || (n[r] = s[r]);
						if(n.overwrite = 0, n.data = "isFromStart", n.lazy = a && s.lazy !== !1, n.immediateRender = a, this._startAt = M.to(this.target, 0, n), a) {
							if(0 === this._time) return
						} else this._startAt._init(), this._startAt._enabled(!1)
					}
				if(this._ease = f = f ? f instanceof w ? f : "function" == typeof f ? new w(f, s.easeParams) : E[f] || M.defaultEase : M.defaultEase, s.easeParams instanceof Array && f.config && (this._ease = f.config.apply(f, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
					for(e = this._targets.length; --e > -1;) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], o ? o[e] : null) && (t = !0);
				else t = this._initProps(this.target, this._propLookup, this._siblings, o);
				if(t && M._onPluginEvent("_onInitAllProps", this), o && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards)
					for(n = this._firstPT; n;) n.s += n.c, n.c = -n.c, n = n._next;
				this._onUpdate = s.onUpdate, this._initted = !0
			}, s._initProps = function(t, n, r, i) {
				var s, o, u, a, f, l;
				if(null == t) return !1;
				H[t._gsTweenID] && W(), this.vars.css || t.style && t !== e && t.nodeType && j.css && this.vars.autoCSS !== !1 && D(this.vars, t);
				for(s in this.vars) {
					if(l = this.vars[s], q[s]) l && (l instanceof Array || l.push && p(l)) && -1 !== l.join("").indexOf("{self}") && (this.vars[s] = l = this._swapSelfInParams(l, this));
					else if(j[s] && (a = new j[s])._onInitTween(t, this.vars[s], this)) {
						for(this._firstPT = f = {
								_next: this._firstPT,
								t: a,
								p: "setRatio",
								s: 0,
								c: 1,
								f: !0,
								n: s,
								pg: !0,
								pr: a._priority
							}, o = a._overwriteProps.length; --o > -1;) n[a._overwriteProps[o]] = this._firstPT;
						(a._priority || a._onInitAllProps) && (u = !0), (a._onDisable || a._onEnable) && (this._notifyPluginsOfEnabled = !0)
					} else this._firstPT = n[s] = f = {
						_next: this._firstPT,
						t: t,
						p: s,
						f: "function" == typeof t[s],
						n: s,
						pg: !1,
						pr: 0
					}, f.s = f.f ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), f.c = "string" == typeof l && "=" === l.charAt(1) ? parseInt(l.charAt(0) + "1", 10) * Number(l.substr(2)) : Number(l) - f.s || 0;
					f && f._next && (f._next._prev = f)
				}
				return i && this._kill(i, t) ? this._initProps(t, n, r, i) : this._overwrite > 1 && this._firstPT && r.length > 1 && V(t, this, n, this._overwrite, r) ? (this._kill(n, t), this._initProps(t, n, r, i)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (H[t._gsTweenID] = !0), u)
			}, s.render = function(e, t, n) {
				var r, i, s, o, u = this._time,
					a = this._duration,
					f = this._rawPrevTime;
				if(e >= a) this._totalTime = this._time = a, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (r = !0, i = "onComplete"), 0 === a && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (0 === e || 0 > f || f === l) && f !== e && (n = !0, f > l && (i = "onReverseComplete")), this._rawPrevTime = o = !t || e || f === e ? e : l);
				else if(1e-7 > e) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== u || 0 === a && f > 0 && f !== l) && (i = "onReverseComplete", r = this._reversed), 0 > e ? (this._active = !1, 0 === a && (this._initted || !this.vars.lazy || n) && (f >= 0 && (n = !0), this._rawPrevTime = o = !t || e || f === e ? e : l)) : this._initted || (n = !0);
				else if(this._totalTime = this._time = e, this._easeType) {
					var c = e / a,
						h = this._easeType,
						p = this._easePower;
					(1 === h || 3 === h && c >= .5) && (c = 1 - c), 3 === h && (c *= 2), 1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c), this.ratio = 1 === h ? 1 - c : 2 === h ? c : .5 > e / a ? c / 2 : 1 - c / 2
				} else this.ratio = this._ease.getRatio(e / a);
				if(this._time !== u || n) {
					if(!this._initted) {
						if(this._init(), !this._initted || this._gc) return;
						if(!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = u, this._rawPrevTime = f, P.push(this), this._lazy = e, void 0;
						this._time && !r ? this.ratio = this._ease.getRatio(this._time / a) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
					}
					for(this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== u && e >= 0 && (this._active = !0), 0 === u && (this._startAt && (e >= 0 ? this._startAt.render(e, t, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === a) && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || b))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
					this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, n), t || (this._time !== u || r) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || b)), i && (!this._gc || n) && (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this.vars[i].apply(this.vars[i + "Scope"] || this, this.vars[i + "Params"] || b), 0 === a && this._rawPrevTime === l && o !== l && (this._rawPrevTime = 0))
				}
			}, s._kill = function(e, t) {
				if("all" === e && (e = null), null != e || null != t && t !== this.target) {
					t = "string" != typeof t ? t || this._targets || this.target : M.selector(t) || t;
					var n, r, i, s, o, u, a, f;
					if((p(t) || _(t)) && "number" != typeof t[0])
						for(n = t.length; --n > -1;) this._kill(e, t[n]) && (u = !0);
					else {
						if(this._targets) {
							for(n = this._targets.length; --n > -1;)
								if(t === this._targets[n]) {
									o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = e ? this._overwrittenProps[n] || {} : "all";
									break
								}
						} else {
							if(t !== this.target) return !1;
							o = this._propLookup, r = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
						}
						if(o) {
							a = e || o, f = e !== r && "all" !== r && e !== o && ("object" != typeof e || !e._tempKill);
							for(i in a)(s = o[i]) && (s.pg && s.t._kill(a) && (u = !0), s.pg && 0 !== s.t._overwriteProps.length || (s._prev ? s._prev._next = s._next : s === this._firstPT && (this._firstPT = s._next), s._next && (s._next._prev = s._prev), s._next = s._prev = null), delete o[i]), f && (r[i] = 1);
							!this._firstPT && this._initted && this._enabled(!1, !1)
						}
					}
					return u
				}
				return this._lazy = !1, this._enabled(!1, !1)
			}, s.invalidate = function() {
				return this._notifyPluginsOfEnabled && M._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = this._lazy = !1, this._propLookup = this._targets ? {} : [], this
			}, s._enabled = function(e, t) {
				if(u || o.wake(), e && this._gc) {
					var n, r = this._targets;
					if(r)
						for(n = r.length; --n > -1;) this._siblings[n] = X(r[n], this, !0);
					else this._siblings = X(this.target, this, !0)
				}
				return L.prototype._enabled.call(this, e, t), this._notifyPluginsOfEnabled && this._firstPT ? M._onPluginEvent(e ? "_onEnable" : "_onDisable", this) : !1
			}, M.to = function(e, t, n) {
				return new M(e, t, n)
			}, M.from = function(e, t, n) {
				return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new M(e, t, n)
			}, M.fromTo = function(e, t, n, r) {
				return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new M(e, t, r)
			}, M.delayedCall = function(e, t, n, r, i) {
				return new M(t, 0, {
					delay: e,
					onComplete: t,
					onCompleteParams: n,
					onCompleteScope: r,
					onReverseComplete: t,
					onReverseCompleteParams: n,
					onReverseCompleteScope: r,
					immediateRender: !1,
					useFrames: i,
					overwrite: 0
				})
			}, M.set = function(e, t) {
				return new M(e, 0, t)
			}, M.getTweensOf = function(e, t) {
				if(null == e) return [];
				e = "string" != typeof e ? e : M.selector(e) || e;
				var n, r, i, s;
				if((p(e) || _(e)) && "number" != typeof e[0]) {
					for(n = e.length, r = []; --n > -1;) r = r.concat(M.getTweensOf(e[n], t));
					for(n = r.length; --n > -1;)
						for(s = r[n], i = n; --i > -1;) s === r[i] && r.splice(n, 1)
				} else
					for(r = X(e).concat(), n = r.length; --n > -1;)(r[n]._gc || t && !r[n].isActive()) && r.splice(n, 1);
				return r
			}, M.killTweensOf = M.killDelayedCallsTo = function(e, t, n) {
				"object" == typeof t && (n = t, t = !1);
				for(var r = M.getTweensOf(e, t), i = r.length; --i > -1;) r[i]._kill(n, e)
			};
			var J = g("plugins.TweenPlugin", function(e, t) {
				this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = J.prototype
			}, !0);
			if(s = J.prototype, J.version = "1.10.1", J.API = 2, s._firstPT = null, s._addTween = function(e, t, n, r, i, s) {
					var o, u;
					return null != r && (o = "number" == typeof r || "=" !== r.charAt(1) ? Number(r) - n : parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2))) ? (this._firstPT = u = {
						_next: this._firstPT,
						t: e,
						p: t,
						s: n,
						c: o,
						f: "function" == typeof e[t],
						n: i || t,
						r: s
					}, u._next && (u._next._prev = u), u) : void 0
				}, s.setRatio = function(e) {
					for(var t, n = this._firstPT, r = 1e-6; n;) t = n.c * e + n.s, n.r ? t = Math.round(t) : r > t && t > -r && (t = 0), n.f ? n.t[n.p](t) : n.t[n.p] = t, n = n._next
				}, s._kill = function(e) {
					var t, n = this._overwriteProps,
						r = this._firstPT;
					if(null != e[this._propName]) this._overwriteProps = [];
					else
						for(t = n.length; --t > -1;) null != e[n[t]] && n.splice(t, 1);
					for(; r;) null != e[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)), r = r._next;
					return !1
				}, s._roundProps = function(e, t) {
					for(var n = this._firstPT; n;)(e[this._propName] || null != n.n && e[n.n.split(this._propName + "_").join("")]) && (n.r = t), n = n._next
				}, M._onPluginEvent = function(e, t) {
					var n, r, i, s, o, u = t._firstPT;
					if("_onInitAllProps" === e) {
						for(; u;) {
							for(o = u._next, r = i; r && r.pr > u.pr;) r = r._next;
							(u._prev = r ? r._prev : s) ? u._prev._next = u: i = u, (u._next = r) ? r._prev = u : s = u, u = o
						}
						u = t._firstPT = i
					}
					for(; u;) u.pg && "function" == typeof u.t[e] && u.t[e]() && (n = !0), u = u._next;
					return n
				}, J.activate = function(e) {
					for(var t = e.length; --t > -1;) e[t].API === J.API && (j[(new e[t])._propName] = e[t]);
					return !0
				}, m.plugin = function(e) {
					if(!(e && e.propName && e.init && e.API)) throw "illegal plugin definition.";
					var t, n = e.propName,
						r = e.priority || 0,
						i = e.overwriteProps,
						s = {
							init: "_onInitTween",
							set: "setRatio",
							kill: "_kill",
							round: "_roundProps",
							initAll: "_onInitAllProps"
						},
						o = g("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", function() {
							J.call(this, n, r), this._overwriteProps = i || []
						}, e.global === !0),
						u = o.prototype = new J(n);
					u.constructor = o, o.API = e.API;
					for(t in s) "function" == typeof e[t] && (u[s[t]] = e[t]);
					return o.version = e.version, J.activate([o]), o
				}, r = e._gsQueue) {
				for(i = 0; r.length > i; i++) r[i]();
				for(s in d) d[s].func || e.console.log("GSAP encountered missing dependency: com.greensock." + s)
			}
			u = !1
		}
	}("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax"), define("gsap", function() {}), ! function(e, t) {
		"object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
			if(!e.document) throw new Error("jQuery requires a window with a document");
			return t(e)
		} : t(e)
	}("undefined" != typeof window ? window : this, function(a, b) {
		function s(e) {
			var t = e.length,
				n = o.type(e);
			return "function" === n || o.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
		}

		function x(e, t, n) {
			if(o.isFunction(t)) return o.grep(e, function(e, r) {
				return !!t.call(e, r, e) !== n
			});
			if(t.nodeType) return o.grep(e, function(e) {
				return e === t !== n
			});
			if("string" == typeof t) {
				if(w.test(t)) return o.filter(t, e, n);
				t = o.filter(t, e)
			}
			return o.grep(e, function(e) {
				return g.call(t, e) >= 0 !== n
			})
		}

		function D(e, t) {
			while((e = e[t]) && 1 !== e.nodeType);
			return e
		}

		function G(e) {
			var t = F[e] = {};
			return o.each(e.match(E) || [], function(e, n) {
				t[n] = !0
			}), t
		}

		function I() {
			m.removeEventListener("DOMContentLoaded", I, !1), a.removeEventListener("load", I, !1), o.ready()
		}

		function K() {
			Object.defineProperty(this.cache = {}, 0, {
				get: function() {
					return {}
				}
			}), this.expando = o.expando + Math.random()
		}

		function P(e, t, n) {
			var r;
			if(void 0 === n && 1 === e.nodeType)
				if(r = "data-" + t.replace(O, "-$1").toLowerCase(), n = e.getAttribute(r), "string" == typeof n) {
					try {
						n = "true" === n ? !0 : "false" === n ? !1 : "null" === n ? null : +n + "" === n ? +n : N.test(n) ? o.parseJSON(n) : n
					} catch(i) {}
					M.set(e, t, n)
				} else n = void 0;
			return n
		}

		function Z() {
			return !0
		}

		function $() {
			return !1
		}

		function _() {
			try {
				return m.activeElement
			} catch(e) {}
		}

		function jb(e, t) {
			return o.nodeName(e, "table") && o.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
		}

		function kb(e) {
			return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
		}

		function lb(e) {
			var t = gb.exec(e.type);
			return t ? e.type = t[1] : e.removeAttribute("type"), e
		}

		function mb(e, t) {
			for(var n = 0, r = e.length; r > n; n++) L.set(e[n], "globalEval", !t || L.get(t[n], "globalEval"))
		}

		function nb(e, t) {
			var n, r, i, s, u, a, f, l;
			if(1 === t.nodeType) {
				if(L.hasData(e) && (s = L.access(e), u = L.set(t, s), l = s.events)) {
					delete u.handle, u.events = {};
					for(i in l)
						for(n = 0, r = l[i].length; r > n; n++) o.event.add(t, i, l[i][n])
				}
				M.hasData(e) && (a = M.access(e), f = o.extend({}, a), M.set(t, f))
			}
		}

		function ob(e, t) {
			var n = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
			return void 0 === t || t && o.nodeName(e, t) ? o.merge([e], n) : n
		}

		function pb(e, t) {
			var n = t.nodeName.toLowerCase();
			"input" === n && T.test(e.type) ? t.checked = e.checked : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
		}

		function sb(e, t) {
			var n = o(t.createElement(e)).appendTo(t.body),
				r = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(n[0]).display : o.css(n[0], "display");
			return n.detach(), r
		}

		function tb(e) {
			var t = m,
				n = rb[e];
			return n || (n = sb(e, t), "none" !== n && n || (qb = (qb || o("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = qb[0].contentDocument, t.write(), t.close(), n = sb(e, t), qb.detach()), rb[e] = n), n
		}

		function xb(e, t, n) {
			var r, i, s, u, a = e.style;
			return n = n || wb(e), n && (u = n.getPropertyValue(t) || n[t]), n && ("" !== u || o.contains(e.ownerDocument, e) || (u = o.style(e, t)), vb.test(u) && ub.test(t) && (r = a.width, i = a.minWidth, s = a.maxWidth, a.minWidth = a.maxWidth = a.width = u, u = n.width, a.width = r, a.minWidth = i, a.maxWidth = s)), void 0 !== u ? u + "" : u
		}

		function yb(e, t) {
			return {
				get: function() {
					return e() ? void delete this.get : (this.get = t).apply(this, arguments)
				}
			}
		}

		function Fb(e, t) {
			if(t in e) return t;
			var n = t[0].toUpperCase() + t.slice(1),
				r = t,
				i = Eb.length;
			while(i--)
				if(t = Eb[i] + n, t in e) return t;
			return r
		}

		function Gb(e, t, n) {
			var r = Ab.exec(t);
			return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
		}

		function Hb(e, t, n, r, i) {
			for(var s = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, u = 0; 4 > s; s += 2) "margin" === n && (u += o.css(e, n + R[s], !0, i)), r ? ("content" === n && (u -= o.css(e, "padding" + R[s], !0, i)), "margin" !== n && (u -= o.css(e, "border" + R[s] + "Width", !0, i))) : (u += o.css(e, "padding" + R[s], !0, i), "padding" !== n && (u += o.css(e, "border" + R[s] + "Width", !0, i)));
			return u
		}

		function Ib(e, t, n) {
			var r = !0,
				i = "width" === t ? e.offsetWidth : e.offsetHeight,
				s = wb(e),
				u = "border-box" === o.css(e, "boxSizing", !1, s);
			if(0 >= i || null == i) {
				if(i = xb(e, t, s), (0 > i || null == i) && (i = e.style[t]), vb.test(i)) return i;
				r = u && (l.boxSizingReliable() || i === e.style[t]), i = parseFloat(i) || 0
			}
			return i + Hb(e, t, n || (u ? "border" : "content"), r, s) + "px"
		}

		function Jb(e, t) {
			for(var n, r, i, s = [], u = 0, a = e.length; a > u; u++) r = e[u], r.style && (s[u] = L.get(r, "olddisplay"), n = r.style.display, t ? (s[u] || "none" !== n || (r.style.display = ""), "" === r.style.display && S(r) && (s[u] = L.access(r, "olddisplay", tb(r.nodeName)))) : s[u] || (i = S(r), (n && "none" !== n || !i) && L.set(r, "olddisplay", i ? n : o.css(r, "display"))));
			for(u = 0; a > u; u++) r = e[u], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? s[u] || "" : "none"));
			return e
		}

		function Kb(e, t, n, r, i) {
			return new Kb.prototype.init(e, t, n, r, i)
		}

		function Sb() {
			return setTimeout(function() {
				Lb = void 0
			}), Lb = o.now()
		}

		function Tb(e, t) {
			var n, r = 0,
				i = {
					height: e
				};
			for(t = t ? 1 : 0; 4 > r; r += 2 - t) n = R[r], i["margin" + n] = i["padding" + n] = e;
			return t && (i.opacity = i.width = e), i
		}

		function Ub(e, t, n) {
			for(var r, i = (Rb[t] || []).concat(Rb["*"]), s = 0, o = i.length; o > s; s++)
				if(r = i[s].call(n, t, e)) return r
		}

		function Vb(e, t, n) {
			var r, i, s, u, a, f, l, c = this,
				h = {},
				p = e.style,
				d = e.nodeType && S(e),
				v = L.get(e, "fxshow");
			n.queue || (a = o._queueHooks(e, "fx"), null == a.unqueued && (a.unqueued = 0, f = a.empty.fire, a.empty.fire = function() {
				a.unqueued || f()
			}), a.unqueued++, c.always(function() {
				c.always(function() {
					a.unqueued--, o.queue(e, "fx").length || a.empty.fire()
				})
			})), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], l = o.css(e, "display"), "none" === l && (l = tb(e.nodeName)), "inline" === l && "none" === o.css(e, "float") && (p.display = "inline-block")), n.overflow && (p.overflow = "hidden", c.always(function() {
				p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]
			}));
			for(r in t)
				if(i = t[r], Nb.exec(i)) {
					if(delete t[r], s = s || "toggle" === i, i === (d ? "hide" : "show")) {
						if("show" !== i || !v || void 0 === v[r]) continue;
						d = !0
					}
					h[r] = v && v[r] || o.style(e, r)
				}
			if(!o.isEmptyObject(h)) {
				v ? "hidden" in v && (d = v.hidden) : v = L.access(e, "fxshow", {}), s && (v.hidden = !d), d ? o(e).show() : c.done(function() {
					o(e).hide()
				}), c.done(function() {
					var t;
					L.remove(e, "fxshow");
					for(t in h) o.style(e, t, h[t])
				});
				for(r in h) u = Ub(d ? v[r] : 0, r, c), r in v || (v[r] = u.start, d && (u.end = u.start, u.start = "width" === r || "height" === r ? 1 : 0))
			}
		}

		function Wb(e, t) {
			var n, r, i, s, u;
			for(n in e)
				if(r = o.camelCase(n), i = t[r], s = e[n], o.isArray(s) && (i = s[1], s = e[n] = s[0]), n !== r && (e[r] = s, delete e[n]), u = o.cssHooks[r], u && "expand" in u) {
					s = u.expand(s), delete e[r];
					for(n in s) n in e || (e[n] = s[n], t[n] = i)
				} else t[r] = i
		}

		function Xb(e, t, n) {
			var r, i, s = 0,
				u = Qb.length,
				a = o.Deferred().always(function() {
					delete f.elem
				}),
				f = function() {
					if(i) return !1;
					for(var t = Lb || Sb(), n = Math.max(0, l.startTime + l.duration - t), r = n / l.duration || 0, s = 1 - r, o = 0, u = l.tweens.length; u > o; o++) l.tweens[o].run(s);
					return a.notifyWith(e, [l, s, n]), 1 > s && u ? n : (a.resolveWith(e, [l]), !1)
				},
				l = a.promise({
					elem: e,
					props: o.extend({}, t),
					opts: o.extend(!0, {
						specialEasing: {}
					}, n),
					originalProperties: t,
					originalOptions: n,
					startTime: Lb || Sb(),
					duration: n.duration,
					tweens: [],
					createTween: function(t, n) {
						var r = o.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
						return l.tweens.push(r), r
					},
					stop: function(t) {
						var n = 0,
							r = t ? l.tweens.length : 0;
						if(i) return this;
						for(i = !0; r > n; n++) l.tweens[n].run(1);
						return t ? a.resolveWith(e, [l, t]) : a.rejectWith(e, [l, t]), this
					}
				}),
				c = l.props;
			for(Wb(c, l.opts.specialEasing); u > s; s++)
				if(r = Qb[s].call(l, e, c, l.opts)) return r;
			return o.map(c, Ub, l), o.isFunction(l.opts.start) && l.opts.start.call(e, l), o.fx.timer(o.extend(f, {
				elem: e,
				anim: l,
				queue: l.opts.queue
			})), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always)
		}

		function rc(e) {
			return function(t, n) {
				"string" != typeof t && (n = t, t = "*");
				var r, i = 0,
					s = t.toLowerCase().match(E) || [];
				if(o.isFunction(n))
					while(r = s[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)
			}
		}

		function sc(e, t, n, r) {
			function u(l) {
				var h;
				return i[l] = !0, o.each(e[l] || [], function(e, o) {
					var a = o(t, n, r);
					return "string" != typeof a || s || i[a] ? s ? !(h = a) : void 0 : (t.dataTypes.unshift(a), u(a), !1)
				}), h
			}
			var i = {},
				s = e === oc;
			return u(t.dataTypes[0]) || !i["*"] && u("*")
		}

		function tc(e, t) {
			var n, r, i = o.ajaxSettings.flatOptions || {};
			for(n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
			return r && o.extend(!0, e, r), e
		}

		function uc(e, t, n) {
			var r, i, s, o, u = e.contents,
				a = e.dataTypes;
			while("*" === a[0]) a.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
			if(r)
				for(i in u)
					if(u[i] && u[i].test(r)) {
						a.unshift(i);
						break
					}
			if(a[0] in n) s = a[0];
			else {
				for(i in n) {
					if(!a[0] || e.converters[i + " " + a[0]]) {
						s = i;
						break
					}
					o || (o = i)
				}
				s = s || o
			}
			return s ? (s !== a[0] && a.unshift(s), n[s]) : void 0
		}

		function vc(e, t, n, r) {
			var i, s, o, u, a, f = {},
				l = e.dataTypes.slice();
			if(l[1])
				for(o in e.converters) f[o.toLowerCase()] = e.converters[o];
			s = l.shift();
			while(s)
				if(e.responseFields[s] && (n[e.responseFields[s]] = t), !a && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), a = s, s = l.shift())
					if("*" === s) s = a;
					else if("*" !== a && a !== s) {
				if(o = f[a + " " + s] || f["* " + s], !o)
					for(i in f)
						if(u = i.split(" "), u[1] === s && (o = f[a + " " + u[0]] || f["* " + u[0]])) {
							o === !0 ? o = f[i] : f[i] !== !0 && (s = u[0], l.unshift(u[1]));
							break
						}
				if(o !== !0)
					if(o && e["throws"]) t = o(t);
					else try {
						t = o(t)
					} catch(c) {
						return {
							state: "parsererror",
							error: o ? c : "No conversion from " + a + " to " + s
						}
					}
			}
			return {
				state: "success",
				data: t
			}
		}

		function Bc(e, t, n, r) {
			var i;
			if(o.isArray(t)) o.each(t, function(t, i) {
				n || xc.test(e) ? r(e, i) : Bc(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)
			});
			else if(n || "object" !== o.type(t)) r(e, t);
			else
				for(i in t) Bc(e + "[" + i + "]", t[i], n, r)
		}

		function Kc(e) {
			return o.isWindow(e) ? e : 9 === e.nodeType && e.defaultView
		}
		var c = [],
			d = c.slice,
			e = c.concat,
			f = c.push,
			g = c.indexOf,
			h = {},
			i = h.toString,
			j = h.hasOwnProperty,
			k = "".trim,
			l = {},
			m = a.document,
			n = "2.1.0",
			o = function(e, t) {
				return new o.fn.init(e, t)
			},
			p = /^-ms-/,
			q = /-([\da-z])/gi,
			r = function(e, t) {
				return t.toUpperCase()
			};
		o.fn = o.prototype = {
			jquery: n,
			constructor: o,
			selector: "",
			length: 0,
			toArray: function() {
				return d.call(this)
			},
			get: function(e) {
				return null != e ? 0 > e ? this[e + this.length] : this[e] : d.call(this)
			},
			pushStack: function(e) {
				var t = o.merge(this.constructor(), e);
				return t.prevObject = this, t.context = this.context, t
			},
			each: function(e, t) {
				return o.each(this, e, t)
			},
			map: function(e) {
				return this.pushStack(o.map(this, function(t, n) {
					return e.call(t, n, t)
				}))
			},
			slice: function() {
				return this.pushStack(d.apply(this, arguments))
			},
			first: function() {
				return this.eq(0)
			},
			last: function() {
				return this.eq(-1)
			},
			eq: function(e) {
				var t = this.length,
					n = +e + (0 > e ? t : 0);
				return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
			},
			end: function() {
				return this.prevObject || this.constructor(null)
			},
			push: f,
			sort: c.sort,
			splice: c.splice
		}, o.extend = o.fn.extend = function() {
			var e, t, n, r, i, s, u = arguments[0] || {},
				a = 1,
				f = arguments.length,
				l = !1;
			for("boolean" == typeof u && (l = u, u = arguments[a] || {}, a++), "object" == typeof u || o.isFunction(u) || (u = {}), a === f && (u = this, a--); f > a; a++)
				if(null != (e = arguments[a]))
					for(t in e) n = u[t], r = e[t], u !== r && (l && r && (o.isPlainObject(r) || (i = o.isArray(r))) ? (i ? (i = !1, s = n && o.isArray(n) ? n : []) : s = n && o.isPlainObject(n) ? n : {}, u[t] = o.extend(l, s, r)) : void 0 !== r && (u[t] = r));
			return u
		}, o.extend({
			expando: "jQuery" + (n + Math.random()).replace(/\D/g, ""),
			isReady: !0,
			error: function(e) {
				throw new Error(e)
			},
			noop: function() {},
			isFunction: function(e) {
				return "function" === o.type(e)
			},
			isArray: Array.isArray,
			isWindow: function(e) {
				return null != e && e === e.window
			},
			isNumeric: function(e) {
				return e - parseFloat(e) >= 0
			},
			isPlainObject: function(e) {
				if("object" !== o.type(e) || e.nodeType || o.isWindow(e)) return !1;
				try {
					if(e.constructor && !j.call(e.constructor.prototype, "isPrototypeOf")) return !1
				} catch(t) {
					return !1
				}
				return !0
			},
			isEmptyObject: function(e) {
				var t;
				for(t in e) return !1;
				return !0
			},
			type: function(e) {
				return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? h[i.call(e)] || "object" : typeof e
			},
			globalEval: function(a) {
				var b, c = eval;
				a = o.trim(a), a && (1 === a.indexOf("use strict") ? (b = m.createElement("script"), b.text = a, m.head.appendChild(b).parentNode.removeChild(b)) : c(a))
			},
			camelCase: function(e) {
				return e.replace(p, "ms-").replace(q, r)
			},
			nodeName: function(e, t) {
				return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
			},
			each: function(e, t, n) {
				var r, i = 0,
					o = e.length,
					u = s(e);
				if(n) {
					if(u) {
						for(; o > i; i++)
							if(r = t.apply(e[i], n), r === !1) break
					} else
						for(i in e)
							if(r = t.apply(e[i], n), r === !1) break
				} else if(u) {
					for(; o > i; i++)
						if(r = t.call(e[i], i, e[i]), r === !1) break
				} else
					for(i in e)
						if(r = t.call(e[i], i, e[i]), r === !1) break;
				return e
			},
			trim: function(e) {
				return null == e ? "" : k.call(e)
			},
			makeArray: function(e, t) {
				var n = t || [];
				return null != e && (s(Object(e)) ? o.merge(n, "string" == typeof e ? [e] : e) : f.call(n, e)), n
			},
			inArray: function(e, t, n) {
				return null == t ? -1 : g.call(t, e, n)
			},
			merge: function(e, t) {
				for(var n = +t.length, r = 0, i = e.length; n > r; r++) e[i++] = t[r];
				return e.length = i, e
			},
			grep: function(e, t, n) {
				for(var r, i = [], s = 0, o = e.length, u = !n; o > s; s++) r = !t(e[s], s), r !== u && i.push(e[s]);
				return i
			},
			map: function(t, n, r) {
				var i, o = 0,
					u = t.length,
					a = s(t),
					f = [];
				if(a)
					for(; u > o; o++) i = n(t[o], o, r), null != i && f.push(i);
				else
					for(o in t) i = n(t[o], o, r), null != i && f.push(i);
				return e.apply([], f)
			},
			guid: 1,
			proxy: function(e, t) {
				var n, r, i;
				return "string" == typeof t && (n = e[t], t = e, e = n), o.isFunction(e) ? (r = d.call(arguments, 2), i = function() {
					return e.apply(t || this, r.concat(d.call(arguments)))
				}, i.guid = e.guid = e.guid || o.guid++, i) : void 0
			},
			now: Date.now,
			support: l
		}), o.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) {
			h["[object " + t + "]"] = t.toLowerCase()
		});
		var t = function(e) {
			function rt(e, t, r, i) {
				var s, o, u, a, f, h, v, m, w, E;
				if((t ? t.ownerDocument || t : b) !== c && l(t), t = t || c, r = r || [], !e || "string" != typeof e) return r;
				if(1 !== (a = t.nodeType) && 9 !== a) return [];
				if(p && !i) {
					if(s = G.exec(e))
						if(u = s[1]) {
							if(9 === a) {
								if(o = t.getElementById(u), !o || !o.parentNode) return r;
								if(o.id === u) return r.push(o), r
							} else if(t.ownerDocument && (o = t.ownerDocument.getElementById(u)) && g(t, o) && o.id === u) return r.push(o), r
						} else {
							if(s[2]) return _.apply(r, t.getElementsByTagName(e)), r;
							if((u = s[3]) && n.getElementsByClassName && t.getElementsByClassName) return _.apply(r, t.getElementsByClassName(u)), r
						}
					if(n.qsa && (!d || !d.test(e))) {
						if(m = v = y, w = t, E = 9 === a && e, 1 === a && "object" !== t.nodeName.toLowerCase()) {
							h = dt(e), (v = t.getAttribute("id")) ? m = v.replace(Z, "\\$&") : t.setAttribute("id", m), m = "[id='" + m + "'] ", f = h.length;
							while(f--) h[f] = m + vt(h[f]);
							w = Y.test(e) && ht(t.parentNode) || t, E = h.join(",")
						}
						if(E) try {
							return _.apply(r, w.querySelectorAll(E)), r
						} catch(S) {} finally {
							v || t.removeAttribute("id")
						}
					}
				}
				return xt(e.replace(R, "$1"), t, r, i)
			}

			function it() {
				function t(n, i) {
					return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i
				}
				var e = [];
				return t
			}

			function st(e) {
				return e[y] = !0, e
			}

			function ot(e) {
				var t = c.createElement("div");
				try {
					return !!e(t)
				} catch(n) {
					return !1
				} finally {
					t.parentNode && t.parentNode.removeChild(t), t = null
				}
			}

			function ut(e, t) {
				var n = e.split("|"),
					i = e.length;
				while(i--) r.attrHandle[n[i]] = t
			}

			function at(e, t) {
				var n = t && e,
					r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || k) - (~e.sourceIndex || k);
				if(r) return r;
				if(n)
					while(n = n.nextSibling)
						if(n === t) return -1;
				return e ? 1 : -1
			}

			function ft(e) {
				return function(t) {
					var n = t.nodeName.toLowerCase();
					return "input" === n && t.type === e
				}
			}

			function lt(e) {
				return function(t) {
					var n = t.nodeName.toLowerCase();
					return("input" === n || "button" === n) && t.type === e
				}
			}

			function ct(e) {
				return st(function(t) {
					return t = +t, st(function(n, r) {
						var i, s = e([], n.length, t),
							o = s.length;
						while(o--) n[i = s[o]] && (n[i] = !(r[i] = n[i]))
					})
				})
			}

			function ht(e) {
				return e && typeof e.getElementsByTagName !== C && e
			}

			function pt() {}

			function dt(e, t) {
				var n, i, s, o, u, a, f, l = x[e + " "];
				if(l) return t ? 0 : l.slice(0);
				u = e, a = [], f = r.preFilter;
				while(u) {
					(!n || (i = U.exec(u))) && (i && (u = u.slice(i[0].length) || u), a.push(s = [])), n = !1, (i = z.exec(u)) && (n = i.shift(), s.push({
						value: n,
						type: i[0].replace(R, " ")
					}), u = u.slice(n.length));
					for(o in r.filter) !(i = $[o].exec(u)) || f[o] && !(i = f[o](i)) || (n = i.shift(), s.push({
						value: n,
						type: o,
						matches: i
					}), u = u.slice(n.length));
					if(!n) break
				}
				return t ? u.length : u ? rt.error(e) : x(e, a).slice(0)
			}

			function vt(e) {
				for(var t = 0, n = e.length, r = ""; n > t; t++) r += e[t].value;
				return r
			}

			function mt(e, t, n) {
				var r = t.dir,
					i = n && "parentNode" === r,
					s = E++;
				return t.first ? function(t, n, s) {
					while(t = t[r])
						if(1 === t.nodeType || i) return e(t, n, s)
				} : function(t, n, o) {
					var u, a, f = [w, s];
					if(o) {
						while(t = t[r])
							if((1 === t.nodeType || i) && e(t, n, o)) return !0
					} else
						while(t = t[r])
							if(1 === t.nodeType || i) {
								if(a = t[y] || (t[y] = {}), (u = a[r]) && u[0] === w && u[1] === s) return f[2] = u[2];
								if(a[r] = f, f[2] = e(t, n, o)) return !0
							}
				}
			}

			function gt(e) {
				return e.length > 1 ? function(t, n, r) {
					var i = e.length;
					while(i--)
						if(!e[i](t, n, r)) return !1;
					return !0
				} : e[0]
			}

			function yt(e, t, n, r, i) {
				for(var s, o = [], u = 0, a = e.length, f = null != t; a > u; u++)(s = e[u]) && (!n || n(s, r, i)) && (o.push(s), f && t.push(u));
				return o
			}

			function bt(e, t, n, r, i, s) {
				return r && !r[y] && (r = bt(r)), i && !i[y] && (i = bt(i, s)), st(function(s, o, u, a) {
					var f, l, c, h = [],
						p = [],
						d = o.length,
						v = s || St(t || "*", u.nodeType ? [u] : u, []),
						m = !e || !s && t ? v : yt(v, h, e, u, a),
						g = n ? i || (s ? e : d || r) ? [] : o : m;
					if(n && n(m, g, u, a), r) {
						f = yt(g, p), r(f, [], u, a), l = f.length;
						while(l--)(c = f[l]) && (g[p[l]] = !(m[p[l]] = c))
					}
					if(s) {
						if(i || e) {
							if(i) {
								f = [], l = g.length;
								while(l--)(c = g[l]) && f.push(m[l] = c);
								i(null, g = [], f, a)
							}
							l = g.length;
							while(l--)(c = g[l]) && (f = i ? P.call(s, c) : h[l]) > -1 && (s[f] = !(o[f] = c))
						}
					} else g = yt(g === o ? g.splice(d, g.length) : g), i ? i(null, o, g, a) : _.apply(o, g)
				})
			}

			function wt(e) {
				for(var t, n, i, s = e.length, o = r.relative[e[0].type], a = o || r.relative[" "], f = o ? 1 : 0, l = mt(function(e) {
						return e === t
					}, a, !0), c = mt(function(e) {
						return P.call(t, e) > -1
					}, a, !0), h = [function(e, n, r) {
						return !o && (r || n !== u) || ((t = n).nodeType ? l(e, n, r) : c(e, n, r))
					}]; s > f; f++)
					if(n = r.relative[e[f].type]) h = [mt(gt(h), n)];
					else {
						if(n = r.filter[e[f].type].apply(null, e[f].matches), n[y]) {
							for(i = ++f; s > i; i++)
								if(r.relative[e[i].type]) break;
							return bt(f > 1 && gt(h), f > 1 && vt(e.slice(0, f - 1).concat({
								value: " " === e[f - 2].type ? "*" : ""
							})).replace(R, "$1"), n, i > f && wt(e.slice(f, i)), s > i && wt(e = e.slice(i)), s > i && vt(e))
						}
						h.push(n)
					}
				return gt(h)
			}

			function Et(e, t) {
				var n = t.length > 0,
					i = e.length > 0,
					s = function(s, o, a, f, l) {
						var h, p, d, v = 0,
							m = "0",
							g = s && [],
							y = [],
							b = u,
							E = s || i && r.find.TAG("*", l),
							S = w += null == b ? 1 : Math.random() || .1,
							x = E.length;
						for(l && (u = o !== c && o); m !== x && null != (h = E[m]); m++) {
							if(i && h) {
								p = 0;
								while(d = e[p++])
									if(d(h, o, a)) {
										f.push(h);
										break
									}
								l && (w = S)
							}
							n && ((h = !d && h) && v--, s && g.push(h))
						}
						if(v += m, n && m !== v) {
							p = 0;
							while(d = t[p++]) d(g, y, o, a);
							if(s) {
								if(v > 0)
									while(m--) g[m] || y[m] || (y[m] = O.call(f));
								y = yt(y)
							}
							_.apply(f, y), l && !s && y.length > 0 && v + t.length > 1 && rt.uniqueSort(f)
						}
						return l && (w = S, u = b), g
					};
				return n ? st(s) : s
			}

			function St(e, t, n) {
				for(var r = 0, i = t.length; i > r; r++) rt(e, t[r], n);
				return n
			}

			function xt(e, t, i, s) {
				var u, a, f, l, c, h = dt(e);
				if(!s && 1 === h.length) {
					if(a = h[0] = h[0].slice(0), a.length > 2 && "ID" === (f = a[0]).type && n.getById && 9 === t.nodeType && p && r.relative[a[1].type]) {
						if(t = (r.find.ID(f.matches[0].replace(et, tt), t) || [])[0], !t) return i;
						e = e.slice(a.shift().value.length)
					}
					u = $.needsContext.test(e) ? 0 : a.length;
					while(u--) {
						if(f = a[u], r.relative[l = f.type]) break;
						if((c = r.find[l]) && (s = c(f.matches[0].replace(et, tt), Y.test(a[0].type) && ht(t.parentNode) || t))) {
							if(a.splice(u, 1), e = s.length && vt(a), !e) return _.apply(i, s), i;
							break
						}
					}
				}
				return o(e, h)(s, t, !p, i, Y.test(e) && ht(t.parentNode) || t), i
			}
			var t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y = "sizzle" + -(new Date),
				b = e.document,
				w = 0,
				E = 0,
				S = it(),
				x = it(),
				T = it(),
				N = function(e, t) {
					return e === t && (f = !0), 0
				},
				C = "undefined",
				k = 1 << 31,
				L = {}.hasOwnProperty,
				A = [],
				O = A.pop,
				M = A.push,
				_ = A.push,
				D = A.slice,
				P = A.indexOf || function(e) {
					for(var t = 0, n = this.length; n > t; t++)
						if(this[t] === e) return t;
					return -1
				},
				H = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
				B = "[\\x20\\t\\r\\n\\f]",
				j = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
				F = j.replace("w", "w#"),
				I = "\\[" + B + "*(" + j + ")" + B + "*(?:([*^$|!~]?=)" + B + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + F + ")|)|)" + B + "*\\]",
				q = ":(" + j + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + I.replace(3, 8) + ")*)|.*)\\)|)",
				R = new RegExp("^" + B + "+|((?:^|[^\\\\])(?:\\\\.)*)" + B + "+$", "g"),
				U = new RegExp("^" + B + "*," + B + "*"),
				z = new RegExp("^" + B + "*([>+~]|" + B + ")" + B + "*"),
				W = new RegExp("=" + B + "*([^\\]'\"]*?)" + B + "*\\]", "g"),
				X = new RegExp(q),
				V = new RegExp("^" + F + "$"),
				$ = {
					ID: new RegExp("^#(" + j + ")"),
					CLASS: new RegExp("^\\.(" + j + ")"),
					TAG: new RegExp("^(" + j.replace("w", "w*") + ")"),
					ATTR: new RegExp("^" + I),
					PSEUDO: new RegExp("^" + q),
					CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + B + "*(even|odd|(([+-]|)(\\d*)n|)" + B + "*(?:([+-]|)" + B + "*(\\d+)|))" + B + "*\\)|)", "i"),
					bool: new RegExp("^(?:" + H + ")$", "i"),
					needsContext: new RegExp("^" + B + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + B + "*((?:-\\d)?\\d*)" + B + "*\\)|)(?=[^-]|$)", "i")
				},
				J = /^(?:input|select|textarea|button)$/i,
				K = /^h\d$/i,
				Q = /^[^{]+\{\s*\[native \w/,
				G = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
				Y = /[+~]/,
				Z = /'|\\/g,
				et = new RegExp("\\\\([\\da-f]{1,6}" + B + "?|(" + B + ")|.)", "ig"),
				tt = function(e, t, n) {
					var r = "0x" + t - 65536;
					return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
				};
			try {
				_.apply(A = D.call(b.childNodes), b.childNodes), A[b.childNodes.length].nodeType
			} catch(nt) {
				_ = {
					apply: A.length ? function(e, t) {
						M.apply(e, D.call(t))
					} : function(e, t) {
						var n = e.length,
							r = 0;
						while(e[n++] = t[r++]);
						e.length = n - 1
					}
				}
			}
			n = rt.support = {}, s = rt.isXML = function(e) {
				var t = e && (e.ownerDocument || e).documentElement;
				return t ? "HTML" !== t.nodeName : !1
			}, l = rt.setDocument = function(e) {
				var t, i = e ? e.ownerDocument || e : b,
					o = i.defaultView;
				return i !== c && 9 === i.nodeType && i.documentElement ? (c = i, h = i.documentElement, p = !s(i), o && o !== o.top && (o.addEventListener ? o.addEventListener("unload", function() {
					l()
				}, !1) : o.attachEvent && o.attachEvent("onunload", function() {
					l()
				})), n.attributes = ot(function(e) {
					return e.className = "i", !e.getAttribute("className")
				}), n.getElementsByTagName = ot(function(e) {
					return e.appendChild(i.createComment("")), !e.getElementsByTagName("*").length
				}), n.getElementsByClassName = Q.test(i.getElementsByClassName) && ot(function(e) {
					return e.innerHTML = "<div class='a'></div><div class='a i'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length
				}), n.getById = ot(function(e) {
					return h.appendChild(e).id = y, !i.getElementsByName || !i.getElementsByName(y).length
				}), n.getById ? (r.find.ID = function(e, t) {
					if(typeof t.getElementById !== C && p) {
						var n = t.getElementById(e);
						return n && n.parentNode ? [n] : []
					}
				}, r.filter.ID = function(e) {
					var t = e.replace(et, tt);
					return function(e) {
						return e.getAttribute("id") === t
					}
				}) : (delete r.find.ID, r.filter.ID = function(e) {
					var t = e.replace(et, tt);
					return function(e) {
						var n = typeof e.getAttributeNode !== C && e.getAttributeNode("id");
						return n && n.value === t
					}
				}), r.find.TAG = n.getElementsByTagName ? function(e, t) {
					return typeof t.getElementsByTagName !== C ? t.getElementsByTagName(e) : void 0
				} : function(e, t) {
					var n, r = [],
						i = 0,
						s = t.getElementsByTagName(e);
					if("*" === e) {
						while(n = s[i++]) 1 === n.nodeType && r.push(n);
						return r
					}
					return s
				}, r.find.CLASS = n.getElementsByClassName && function(e, t) {
					return typeof t.getElementsByClassName !== C && p ? t.getElementsByClassName(e) : void 0
				}, v = [], d = [], (n.qsa = Q.test(i.querySelectorAll)) && (ot(function(e) {
					e.innerHTML = "<select t=''><option selected=''></option></select>", e.querySelectorAll("[t^='']").length && d.push("[*^$]=" + B + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || d.push("\\[" + B + "*(?:value|" + H + ")"), e.querySelectorAll(":checked").length || d.push(":checked")
				}), ot(function(e) {
					var t = i.createElement("input");
					t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && d.push("name" + B + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || d.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), d.push(",.*:")
				})), (n.matchesSelector = Q.test(m = h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ot(function(e) {
					n.disconnectedMatch = m.call(e, "div"), m.call(e, "[s!='']:x"), v.push("!=", q)
				}), d = d.length && new RegExp(d.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(h.compareDocumentPosition), g = t || Q.test(h.contains) ? function(e, t) {
					var n = 9 === e.nodeType ? e.documentElement : e,
						r = t && t.parentNode;
					return e === r || !!r && 1 === r.nodeType && !!(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))
				} : function(e, t) {
					if(t)
						while(t = t.parentNode)
							if(t === e) return !0;
					return !1
				}, N = t ? function(e, t) {
					if(e === t) return f = !0, 0;
					var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
					return r ? r : (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & r || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === i || e.ownerDocument === b && g(b, e) ? -1 : t === i || t.ownerDocument === b && g(b, t) ? 1 : a ? P.call(a, e) - P.call(a, t) : 0 : 4 & r ? -1 : 1)
				} : function(e, t) {
					if(e === t) return f = !0, 0;
					var n, r = 0,
						s = e.parentNode,
						o = t.parentNode,
						u = [e],
						l = [t];
					if(!s || !o) return e === i ? -1 : t === i ? 1 : s ? -1 : o ? 1 : a ? P.call(a, e) - P.call(a, t) : 0;
					if(s === o) return at(e, t);
					n = e;
					while(n = n.parentNode) u.unshift(n);
					n = t;
					while(n = n.parentNode) l.unshift(n);
					while(u[r] === l[r]) r++;
					return r ? at(u[r], l[r]) : u[r] === b ? -1 : l[r] === b ? 1 : 0
				}, i) : c
			}, rt.matches = function(e, t) {
				return rt(e, null, null, t)
			}, rt.matchesSelector = function(e, t) {
				if((e.ownerDocument || e) !== c && l(e), t = t.replace(W, "='$1']"), !(!n.matchesSelector || !p || v && v.test(t) || d && d.test(t))) try {
					var r = m.call(e, t);
					if(r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
				} catch(i) {}
				return rt(t, c, null, [e]).length > 0
			}, rt.contains = function(e, t) {
				return(e.ownerDocument || e) !== c && l(e), g(e, t)
			}, rt.attr = function(e, t) {
				(e.ownerDocument || e) !== c && l(e);
				var i = r.attrHandle[t.toLowerCase()],
					s = i && L.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !p) : void 0;
				return void 0 !== s ? s : n.attributes || !p ? e.getAttribute(t) : (s = e.getAttributeNode(t)) && s.specified ? s.value : null
			}, rt.error = function(e) {
				throw new Error("Syntax error, unrecognized expression: " + e)
			}, rt.uniqueSort = function(e) {
				var t, r = [],
					i = 0,
					s = 0;
				if(f = !n.detectDuplicates, a = !n.sortStable && e.slice(0), e.sort(N), f) {
					while(t = e[s++]) t === e[s] && (i = r.push(s));
					while(i--) e.splice(r[i], 1)
				}
				return a = null, e
			}, i = rt.getText = function(e) {
				var t, n = "",
					r = 0,
					s = e.nodeType;
				if(s) {
					if(1 === s || 9 === s || 11 === s) {
						if("string" == typeof e.textContent) return e.textContent;
						for(e = e.firstChild; e; e = e.nextSibling) n += i(e)
					} else if(3 === s || 4 === s) return e.nodeValue
				} else
					while(t = e[r++]) n += i(t);
				return n
			}, r = rt.selectors = {
				cacheLength: 50,
				createPseudo: st,
				match: $,
				attrHandle: {},
				find: {},
				relative: {
					">": {
						dir: "parentNode",
						first: !0
					},
					" ": {
						dir: "parentNode"
					},
					"+": {
						dir: "previousSibling",
						first: !0
					},
					"~": {
						dir: "previousSibling"
					}
				},
				preFilter: {
					ATTR: function(e) {
						return e[1] = e[1].replace(et, tt), e[3] = (e[4] || e[5] || "").replace(et, tt), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
					},
					CHILD: function(e) {
						return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || rt.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && rt.error(e[0]), e
					},
					PSEUDO: function(e) {
						var t, n = !e[5] && e[2];
						return $.CHILD.test(e[0]) ? null : (e[3] && void 0 !== e[4] ? e[2] = e[4] : n && X.test(n) && (t = dt(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
					}
				},
				filter: {
					TAG: function(e) {
						var t = e.replace(et, tt).toLowerCase();
						return "*" === e ? function() {
							return !0
						} : function(e) {
							return e.nodeName && e.nodeName.toLowerCase() === t
						}
					},
					CLASS: function(e) {
						var t = S[e + " "];
						return t || (t = new RegExp("(^|" + B + ")" + e + "(" + B + "|$)")) && S(e, function(e) {
							return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== C && e.getAttribute("class") || "")
						})
					},
					ATTR: function(e, t, n) {
						return function(r) {
							var i = rt.attr(r, e);
							return null == i ? "!=" === t : t ? (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0
						}
					},
					CHILD: function(e, t, n, r, i) {
						var s = "nth" !== e.slice(0, 3),
							o = "last" !== e.slice(-4),
							u = "of-type" === t;
						return 1 === r && 0 === i ? function(e) {
							return !!e.parentNode
						} : function(t, n, a) {
							var f, l, c, h, p, d, v = s !== o ? "nextSibling" : "previousSibling",
								m = t.parentNode,
								g = u && t.nodeName.toLowerCase(),
								b = !a && !u;
							if(m) {
								if(s) {
									while(v) {
										c = t;
										while(c = c[v])
											if(u ? c.nodeName.toLowerCase() === g : 1 === c.nodeType) return !1;
										d = v = "only" === e && !d && "nextSibling"
									}
									return !0
								}
								if(d = [o ? m.firstChild : m.lastChild], o && b) {
									l = m[y] || (m[y] = {}), f = l[e] || [], p = f[0] === w && f[1], h = f[0] === w && f[2], c = p && m.childNodes[p];
									while(c = ++p && c && c[v] || (h = p = 0) || d.pop())
										if(1 === c.nodeType && ++h && c === t) {
											l[e] = [w, p, h];
											break
										}
								} else if(b && (f = (t[y] || (t[y] = {}))[e]) && f[0] === w) h = f[1];
								else
									while(c = ++p && c && c[v] || (h = p = 0) || d.pop())
										if((u ? c.nodeName.toLowerCase() === g : 1 === c.nodeType) && ++h && (b && ((c[y] || (c[y] = {}))[e] = [w, h]), c === t)) break;
								return h -= i, h === r || h % r === 0 && h / r >= 0
							}
						}
					},
					PSEUDO: function(e, t) {
						var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || rt.error("unsupported pseudo: " + e);
						return i[y] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? st(function(e, n) {
							var r, s = i(e, t),
								o = s.length;
							while(o--) r = P.call(e, s[o]), e[r] = !(n[r] = s[o])
						}) : function(e) {
							return i(e, 0, n)
						}) : i
					}
				},
				pseudos: {
					not: st(function(e) {
						var t = [],
							n = [],
							r = o(e.replace(R, "$1"));
						return r[y] ? st(function(e, t, n, i) {
							var s, o = r(e, null, i, []),
								u = e.length;
							while(u--)(s = o[u]) && (e[u] = !(t[u] = s))
						}) : function(e, i, s) {
							return t[0] = e, r(t, null, s, n), !n.pop()
						}
					}),
					has: st(function(e) {
						return function(t) {
							return rt(e, t).length > 0
						}
					}),
					contains: st(function(e) {
						return function(t) {
							return(t.textContent || t.innerText || i(t)).indexOf(e) > -1
						}
					}),
					lang: st(function(e) {
						return V.test(e || "") || rt.error("unsupported lang: " + e), e = e.replace(et, tt).toLowerCase(),
							function(t) {
								var n;
								do
									if(n = p ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
								return !1
							}
					}),
					target: function(t) {
						var n = e.location && e.location.hash;
						return n && n.slice(1) === t.id
					},
					root: function(e) {
						return e === h
					},
					focus: function(e) {
						return e === c.activeElement && (!c.hasFocus || c.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
					},
					enabled: function(e) {
						return e.disabled === !1
					},
					disabled: function(e) {
						return e.disabled === !0
					},
					checked: function(e) {
						var t = e.nodeName.toLowerCase();
						return "input" === t && !!e.checked || "option" === t && !!e.selected
					},
					selected: function(e) {
						return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
					},
					empty: function(e) {
						for(e = e.firstChild; e; e = e.nextSibling)
							if(e.nodeType < 6) return !1;
						return !0
					},
					parent: function(e) {
						return !r.pseudos.empty(e)
					},
					header: function(e) {
						return K.test(e.nodeName)
					},
					input: function(e) {
						return J.test(e.nodeName)
					},
					button: function(e) {
						var t = e.nodeName.toLowerCase();
						return "input" === t && "button" === e.type || "button" === t
					},
					text: function(e) {
						var t;
						return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
					},
					first: ct(function() {
						return [0]
					}),
					last: ct(function(e, t) {
						return [t - 1]
					}),
					eq: ct(function(e, t, n) {
						return [0 > n ? n + t : n]
					}),
					even: ct(function(e, t) {
						for(var n = 0; t > n; n += 2) e.push(n);
						return e
					}),
					odd: ct(function(e, t) {
						for(var n = 1; t > n; n += 2) e.push(n);
						return e
					}),
					lt: ct(function(e, t, n) {
						for(var r = 0 > n ? n + t : n; --r >= 0;) e.push(r);
						return e
					}),
					gt: ct(function(e, t, n) {
						for(var r = 0 > n ? n + t : n; ++r < t;) e.push(r);
						return e
					})
				}
			}, r.pseudos.nth = r.pseudos.eq;
			for(t in {
					radio: !0,
					checkbox: !0,
					file: !0,
					password: !0,
					image: !0
				}) r.pseudos[t] = ft(t);
			for(t in {
					submit: !0,
					reset: !0
				}) r.pseudos[t] = lt(t);
			return pt.prototype = r.filters = r.pseudos, r.setFilters = new pt, o = rt.compile = function(e, t) {
				var n, r = [],
					i = [],
					s = T[e + " "];
				if(!s) {
					t || (t = dt(e)), n = t.length;
					while(n--) s = wt(t[n]), s[y] ? r.push(s) : i.push(s);
					s = T(e, Et(i, r))
				}
				return s
			}, n.sortStable = y.split("").sort(N).join("") === y, n.detectDuplicates = !!f, l(), n.sortDetached = ot(function(e) {
				return 1 & e.compareDocumentPosition(c.createElement("div"))
			}), ot(function(e) {
				return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
			}) || ut("type|href|height|width", function(e, t, n) {
				return n ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
			}), n.attributes && ot(function(e) {
				return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
			}) || ut("value", function(e, t, n) {
				return n || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
			}), ot(function(e) {
				return null == e.getAttribute("disabled")
			}) || ut(H, function(e, t, n) {
				var r;
				return n ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
			}), rt
		}(a);
		o.find = t, o.expr = t.selectors, o.expr[":"] = o.expr.pseudos, o.unique = t.uniqueSort, o.text = t.getText, o.isXMLDoc = t.isXML, o.contains = t.contains;
		var u = o.expr.match.needsContext,
			v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
			w = /^.[^:#\[\.,]*$/;
		o.filter = function(e, t, n) {
			var r = t[0];
			return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? o.find.matchesSelector(r, e) ? [r] : [] : o.find.matches(e, o.grep(t, function(e) {
				return 1 === e.nodeType
			}))
		}, o.fn.extend({
			find: function(e) {
				var t, n = this.length,
					r = [],
					i = this;
				if("string" != typeof e) return this.pushStack(o(e).filter(function() {
					for(t = 0; n > t; t++)
						if(o.contains(i[t], this)) return !0
				}));
				for(t = 0; n > t; t++) o.find(e, i[t], r);
				return r = this.pushStack(n > 1 ? o.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, r
			},
			filter: function(e) {
				return this.pushStack(x(this, e || [], !1))
			},
			not: function(e) {
				return this.pushStack(x(this, e || [], !0))
			},
			is: function(e) {
				return !!x(this, "string" == typeof e && u.test(e) ? o(e) : e || [], !1).length
			}
		});
		var y, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
			A = o.fn.init = function(e, t) {
				var n, r;
				if(!e) return this;
				if("string" == typeof e) {
					if(n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : z.exec(e), !n || !n[1] && t) return !t || t.jquery ? (t || y).find(e) : this.constructor(t).find(e);
					if(n[1]) {
						if(t = t instanceof o ? t[0] : t, o.merge(this, o.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : m, !0)), v.test(n[1]) && o.isPlainObject(t))
							for(n in t) o.isFunction(this[n]) ? this[n](t[n]) : this.attr(n, t[n]);
						return this
					}
					return r = m.getElementById(n[2]), r && r.parentNode && (this.length = 1, this[0] = r), this.context = m, this.selector = e, this
				}
				return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : o.isFunction(e) ? "undefined" != typeof y.ready ? y.ready(e) : e(o) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), o.makeArray(e, this))
			};
		A.prototype = o.fn, y = o(m);
		var B = /^(?:parents|prev(?:Until|All))/,
			C = {
				children: !0,
				contents: !0,
				next: !0,
				prev: !0
			};
		o.extend({
			dir: function(e, t, n) {
				var r = [],
					i = void 0 !== n;
				while((e = e[t]) && 9 !== e.nodeType)
					if(1 === e.nodeType) {
						if(i && o(e).is(n)) break;
						r.push(e)
					}
				return r
			},
			sibling: function(e, t) {
				for(var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
				return n
			}
		}), o.fn.extend({
			has: function(e) {
				var t = o(e, this),
					n = t.length;
				return this.filter(function() {
					for(var e = 0; n > e; e++)
						if(o.contains(this, t[e])) return !0
				})
			},
			closest: function(e, t) {
				for(var n, r = 0, i = this.length, s = [], a = u.test(e) || "string" != typeof e ? o(e, t || this.context) : 0; i > r; r++)
					for(n = this[r]; n && n !== t; n = n.parentNode)
						if(n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && o.find.matchesSelector(n, e))) {
							s.push(n);
							break
						}
				return this.pushStack(s.length > 1 ? o.unique(s) : s)
			},
			index: function(e) {
				return e ? "string" == typeof e ? g.call(o(e), this[0]) : g.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
			},
			add: function(e, t) {
				return this.pushStack(o.unique(o.merge(this.get(), o(e, t))))
			},
			addBack: function(e) {
				return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
			}
		}), o.each({
			parent: function(e) {
				var t = e.parentNode;
				return t && 11 !== t.nodeType ? t : null
			},
			parents: function(e) {
				return o.dir(e, "parentNode")
			},
			parentsUntil: function(e, t, n) {
				return o.dir(e, "parentNode", n)
			},
			next: function(e) {
				return D(e, "nextSibling")
			},
			prev: function(e) {
				return D(e, "previousSibling")
			},
			nextAll: function(e) {
				return o.dir(e, "nextSibling")
			},
			prevAll: function(e) {
				return o.dir(e, "previousSibling")
			},
			nextUntil: function(e, t, n) {
				return o.dir(e, "nextSibling", n)
			},
			prevUntil: function(e, t, n) {
				return o.dir(e, "previousSibling", n)
			},
			siblings: function(e) {
				return o.sibling((e.parentNode || {}).firstChild, e)
			},
			children: function(e) {
				return o.sibling(e.firstChild)
			},
			contents: function(e) {
				return e.contentDocument || o.merge([], e.childNodes)
			}
		}, function(e, t) {
			o.fn[e] = function(n, r) {
				var i = o.map(this, t, n);
				return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = o.filter(r, i)), this.length > 1 && (C[e] || o.unique(i), B.test(e) && i.reverse()), this.pushStack(i)
			}
		});
		var E = /\S+/g,
			F = {};
		o.Callbacks = function(e) {
			e = "string" == typeof e ? F[e] || G(e) : o.extend({}, e);
			var t, n, r, i, s, u, a = [],
				f = !e.once && [],
				l = function(o) {
					for(t = e.memory && o, n = !0, u = i || 0, i = 0, s = a.length, r = !0; a && s > u; u++)
						if(a[u].apply(o[0], o[1]) === !1 && e.stopOnFalse) {
							t = !1;
							break
						}
					r = !1, a && (f ? f.length && l(f.shift()) : t ? a = [] : c.disable())
				},
				c = {
					add: function() {
						if(a) {
							var n = a.length;
							! function u(t) {
								o.each(t, function(t, n) {
									var r = o.type(n);
									"function" === r ? e.unique && c.has(n) || a.push(n) : n && n.length && "string" !== r && u(n)
								})
							}(arguments), r ? s = a.length : t && (i = n, l(t))
						}
						return this
					},
					remove: function() {
						return a && o.each(arguments, function(e, t) {
							var n;
							while((n = o.inArray(t, a, n)) > -1) a.splice(n, 1), r && (s >= n && s--, u >= n && u--)
						}), this
					},
					has: function(e) {
						return e ? o.inArray(e, a) > -1 : !!a && !!a.length
					},
					empty: function() {
						return a = [], s = 0, this
					},
					disable: function() {
						return a = f = t = void 0, this
					},
					disabled: function() {
						return !a
					},
					lock: function() {
						return f = void 0, t || c.disable(), this
					},
					locked: function() {
						return !f
					},
					fireWith: function(e, t) {
						return !a || n && !f || (t = t || [], t = [e, t.slice ? t.slice() : t], r ? f.push(t) : l(t)), this
					},
					fire: function() {
						return c.fireWith(this, arguments), this
					},
					fired: function() {
						return !!n
					}
				};
			return c
		}, o.extend({
			Deferred: function(e) {
				var t = [
						["resolve", "done", o.Callbacks("once memory"), "resolved"],
						["reject", "fail", o.Callbacks("once memory"), "rejected"],
						["notify", "progress", o.Callbacks("memory")]
					],
					n = "pending",
					r = {
						state: function() {
							return n
						},
						always: function() {
							return i.done(arguments).fail(arguments), this
						},
						then: function() {
							var e = arguments;
							return o.Deferred(function(n) {
								o.each(t, function(t, s) {
									var u = o.isFunction(e[t]) && e[t];
									i[s[1]](function() {
										var e = u && u.apply(this, arguments);
										e && o.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[s[0] + "With"](this === r ? n.promise() : this, u ? [e] : arguments)
									})
								}), e = null
							}).promise()
						},
						promise: function(e) {
							return null != e ? o.extend(e, r) : r
						}
					},
					i = {};
				return r.pipe = r.then, o.each(t, function(e, s) {
					var o = s[2],
						u = s[3];
					r[s[1]] = o.add, u && o.add(function() {
						n = u
					}, t[1 ^ e][2].disable, t[2][2].lock), i[s[0]] = function() {
						return i[s[0] + "With"](this === i ? r : this, arguments), this
					}, i[s[0] + "With"] = o.fireWith
				}), r.promise(i), e && e.call(i, i), i
			},
			when: function(e) {
				var t = 0,
					n = d.call(arguments),
					r = n.length,
					i = 1 !== r || e && o.isFunction(e.promise) ? r : 0,
					s = 1 === i ? e : o.Deferred(),
					u = function(e, t, n) {
						return function(r) {
							t[e] = this, n[e] = arguments.length > 1 ? d.call(arguments) : r, n === a ? s.notifyWith(t, n) : --i || s.resolveWith(t, n)
						}
					},
					a, f, l;
				if(r > 1)
					for(a = new Array(r), f = new Array(r), l = new Array(r); r > t; t++) n[t] && o.isFunction(n[t].promise) ? n[t].promise().done(u(t, l, n)).fail(s.reject).progress(u(t, f, a)) : --i;
				return i || s.resolveWith(l, n), s.promise()
			}
		});
		var H;
		o.fn.ready = function(e) {
			return o.ready.promise().done(e), this
		}, o.extend({
			isReady: !1,
			readyWait: 1,
			holdReady: function(e) {
				e ? o.readyWait++ : o.ready(!0)
			},
			ready: function(e) {
				(e === !0 ? --o.readyWait : o.isReady) || (o.isReady = !0, e !== !0 && --o.readyWait > 0 || (H.resolveWith(m, [o]), o.fn.trigger && o(m).trigger("ready").off("ready")))
			}
		}), o.ready.promise = function(e) {
			return H || (H = o.Deferred(), "complete" === m.readyState ? setTimeout(o.ready) : (m.addEventListener("DOMContentLoaded", I, !1), a.addEventListener("load", I, !1))), H.promise(e)
		}, o.ready.promise();
		var J = o.access = function(e, t, n, r, i, s, u) {
			var a = 0,
				f = e.length,
				l = null == n;
			if("object" === o.type(n)) {
				i = !0;
				for(a in n) o.access(e, t, a, n[a], !0, s, u)
			} else if(void 0 !== r && (i = !0, o.isFunction(r) || (u = !0), l && (u ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
					return l.call(o(e), n)
				})), t))
				for(; f > a; a++) t(e[a], n, u ? r : r.call(e[a], a, t(e[a], n)));
			return i ? e : l ? t.call(e) : f ? t(e[0], n) : s
		};
		o.acceptData = function(e) {
			return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
		}, K.uid = 1, K.accepts = o.acceptData, K.prototype = {
			key: function(e) {
				if(!K.accepts(e)) return 0;
				var t = {},
					n = e[this.expando];
				if(!n) {
					n = K.uid++;
					try {
						t[this.expando] = {
							value: n
						}, Object.defineProperties(e, t)
					} catch(r) {
						t[this.expando] = n, o.extend(e, t)
					}
				}
				return this.cache[n] || (this.cache[n] = {}), n
			},
			set: function(e, t, n) {
				var r, i = this.key(e),
					s = this.cache[i];
				if("string" == typeof t) s[t] = n;
				else if(o.isEmptyObject(s)) o.extend(this.cache[i], t);
				else
					for(r in t) s[r] = t[r];
				return s
			},
			get: function(e, t) {
				var n = this.cache[this.key(e)];
				return void 0 === t ? n : n[t]
			},
			access: function(e, t, n) {
				var r;
				return void 0 === t || t && "string" == typeof t && void 0 === n ? (r = this.get(e, t), void 0 !== r ? r : this.get(e, o.camelCase(t))) : (this.set(e, t, n), void 0 !== n ? n : t)
			},
			remove: function(e, t) {
				var n, r, i, s = this.key(e),
					u = this.cache[s];
				if(void 0 === t) this.cache[s] = {};
				else {
					o.isArray(t) ? r = t.concat(t.map(o.camelCase)) : (i = o.camelCase(t), t in u ? r = [t, i] : (r = i, r = r in u ? [r] : r.match(E) || [])), n = r.length;
					while(n--) delete u[r[n]]
				}
			},
			hasData: function(e) {
				return !o.isEmptyObject(this.cache[e[this.expando]] || {})
			},
			discard: function(e) {
				e[this.expando] && delete this.cache[e[this.expando]]
			}
		};
		var L = new K,
			M = new K,
			N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
			O = /([A-Z])/g;
		o.extend({
			hasData: function(e) {
				return M.hasData(e) || L.hasData(e)
			},
			data: function(e, t, n) {
				return M.access(e, t, n)
			},
			removeData: function(e, t) {
				M.remove(e, t)
			},
			_data: function(e, t, n) {
				return L.access(e, t, n)
			},
			_removeData: function(e, t) {
				L.remove(e, t)
			}
		}), o.fn.extend({
			data: function(e, t) {
				var n, r, i, s = this[0],
					u = s && s.attributes;
				if(void 0 === e) {
					if(this.length && (i = M.get(s), 1 === s.nodeType && !L.get(s, "hasDataAttrs"))) {
						n = u.length;
						while(n--) r = u[n].name, 0 === r.indexOf("data-") && (r = o.camelCase(r.slice(5)), P(s, r, i[r]));
						L.set(s, "hasDataAttrs", !0)
					}
					return i
				}
				return "object" == typeof e ? this.each(function() {
					M.set(this, e)
				}) : J(this, function(t) {
					var n, r = o.camelCase(e);
					if(s && void 0 === t) {
						if(n = M.get(s, e), void 0 !== n) return n;
						if(n = M.get(s, r), void 0 !== n) return n;
						if(n = P(s, r, void 0), void 0 !== n) return n
					} else this.each(function() {
						var n = M.get(this, r);
						M.set(this, r, t), -1 !== e.indexOf("-") && void 0 !== n && M.set(this, e, t)
					})
				}, null, t, arguments.length > 1, null, !0)
			},
			removeData: function(e) {
				return this.each(function() {
					M.remove(this, e)
				})
			}
		}), o.extend({
			queue: function(e, t, n) {
				var r;
				return e ? (t = (t || "fx") + "queue", r = L.get(e, t), n && (!r || o.isArray(n) ? r = L.access(e, t, o.makeArray(n)) : r.push(n)), r || []) : void 0
			},
			dequeue: function(e, t) {
				t = t || "fx";
				var n = o.queue(e, t),
					r = n.length,
					i = n.shift(),
					s = o._queueHooks(e, t),
					u = function() {
						o.dequeue(e, t)
					};
				"inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete s.stop, i.call(e, u, s)), !r && s && s.empty.fire()
			},
			_queueHooks: function(e, t) {
				var n = t + "queueHooks";
				return L.get(e, n) || L.access(e, n, {
					empty: o.Callbacks("once memory").add(function() {
						L.remove(e, [t + "queue", n])
					})
				})
			}
		}), o.fn.extend({
			queue: function(e, t) {
				var n = 2;
				return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? o.queue(this[0], e) : void 0 === t ? this : this.each(function() {
					var n = o.queue(this, e, t);
					o._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && o.dequeue(this, e)
				})
			},
			dequeue: function(e) {
				return this.each(function() {
					o.dequeue(this, e)
				})
			},
			clearQueue: function(e) {
				return this.queue(e || "fx", [])
			},
			promise: function(e, t) {
				var n, r = 1,
					i = o.Deferred(),
					s = this,
					u = this.length,
					a = function() {
						--r || i.resolveWith(s, [s])
					};
				"string" != typeof e && (t = e, e = void 0), e = e || "fx";
				while(u--) n = L.get(s[u], e + "queueHooks"), n && n.empty && (r++, n.empty.add(a));
				return a(), i.promise(t)
			}
		});
		var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
			R = ["Top", "Right", "Bottom", "Left"],
			S = function(e, t) {
				return e = t || e, "none" === o.css(e, "display") || !o.contains(e.ownerDocument, e)
			},
			T = /^(?:checkbox|radio)$/i;
		! function() {
			var e = m.createDocumentFragment(),
				t = e.appendChild(m.createElement("div"));
			t.innerHTML = "<input type='radio' checked='checked' name='t'/>", l.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
		}();
		var U = "undefined";
		l.focusinBubbles = "onfocusin" in a;
		var V = /^key/,
			W = /^(?:mouse|contextmenu)|click/,
			X = /^(?:focusinfocus|focusoutblur)$/,
			Y = /^([^.]*)(?:\.(.+)|)$/;
		o.event = {
			global: {},
			add: function(e, t, n, r, i) {
				var s, u, a, f, l, c, h, p, d, v, m, g = L.get(e);
				if(g) {
					n.handler && (s = n, n = s.handler, i = s.selector), n.guid || (n.guid = o.guid++), (f = g.events) || (f = g.events = {}), (u = g.handle) || (u = g.handle = function(t) {
						return typeof o !== U && o.event.triggered !== t.type ? o.event.dispatch.apply(e, arguments) : void 0
					}), t = (t || "").match(E) || [""], l = t.length;
					while(l--) a = Y.exec(t[l]) || [], d = m = a[1], v = (a[2] || "").split(".").sort(), d && (h = o.event.special[d] || {}, d = (i ? h.delegateType : h.bindType) || d, h = o.event.special[d] || {}, c = o.extend({
						type: d,
						origType: m,
						data: r,
						handler: n,
						guid: n.guid,
						selector: i,
						needsContext: i && o.expr.match.needsContext.test(i),
						namespace: v.join(".")
					}, s), (p = f[d]) || (p = f[d] = [], p.delegateCount = 0, h.setup && h.setup.call(e, r, v, u) !== !1 || e.addEventListener && e.addEventListener(d, u, !1)), h.add && (h.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), o.event.global[d] = !0)
				}
			},
			remove: function(e, t, n, r, i) {
				var s, u, a, f, l, c, h, p, d, v, m, g = L.hasData(e) && L.get(e);
				if(g && (f = g.events)) {
					t = (t || "").match(E) || [""], l = t.length;
					while(l--)
						if(a = Y.exec(t[l]) || [], d = m = a[1], v = (a[2] || "").split(".").sort(), d) {
							h = o.event.special[d] || {}, d = (r ? h.delegateType : h.bindType) || d, p = f[d] || [], a = a[2] && new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)"), u = s = p.length;
							while(s--) c = p[s], !i && m !== c.origType || n && n.guid !== c.guid || a && !a.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(s, 1), c.selector && p.delegateCount--, h.remove && h.remove.call(e, c));
							u && !p.length && (h.teardown && h.teardown.call(e, v, g.handle) !== !1 || o.removeEvent(e, d, g.handle), delete f[d])
						} else
							for(d in f) o.event.remove(e, d + t[l], n, r, !0);
					o.isEmptyObject(f) && (delete g.handle, L.remove(e, "events"))
				}
			},
			trigger: function(e, t, n, r) {
				var i, s, u, f, l, c, h, p = [n || m],
					d = j.call(e, "type") ? e.type : e,
					v = j.call(e, "namespace") ? e.namespace.split(".") : [];
				if(s = u = n = n || m, 3 !== n.nodeType && 8 !== n.nodeType && !X.test(d + o.event.triggered) && (d.indexOf(".") >= 0 && (v = d.split("."), d = v.shift(), v.sort()), l = d.indexOf(":") < 0 && "on" + d, e = e[o.expando] ? e : new o.Event(d, "object" == typeof e && e), e.isTrigger = r ? 2 : 3, e.namespace = v.join("."), e.namespace_re = e.namespace ? new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : o.makeArray(t, [e]), h = o.event.special[d] || {}, r || !h.trigger || h.trigger.apply(n, t) !== !1)) {
					if(!r && !h.noBubble && !o.isWindow(n)) {
						for(f = h.delegateType || d, X.test(f + d) || (s = s.parentNode); s; s = s.parentNode) p.push(s), u = s;
						u === (n.ownerDocument || m) && p.push(u.defaultView || u.parentWindow || a)
					}
					i = 0;
					while((s = p[i++]) && !e.isPropagationStopped()) e.type = i > 1 ? f : h.bindType || d, c = (L.get(s, "events") || {})[e.type] && L.get(s, "handle"), c && c.apply(s, t), c = l && s[l], c && c.apply && o.acceptData(s) && (e.result = c.apply(s, t), e.result === !1 && e.preventDefault());
					return e.type = d, r || e.isDefaultPrevented() || h._default && h._default.apply(p.pop(), t) !== !1 || !o.acceptData(n) || l && o.isFunction(n[d]) && !o.isWindow(n) && (u = n[l], u && (n[l] = null), o.event.triggered = d, n[d](), o.event.triggered = void 0, u && (n[l] = u)), e.result
				}
			},
			dispatch: function(e) {
				e = o.event.fix(e);
				var t, n, r, i, s, u = [],
					a = d.call(arguments),
					f = (L.get(this, "events") || {})[e.type] || [],
					l = o.event.special[e.type] || {};
				if(a[0] = e, e.delegateTarget = this, !l.preDispatch || l.preDispatch.call(this, e) !== !1) {
					u = o.event.handlers.call(this, e, f), t = 0;
					while((i = u[t++]) && !e.isPropagationStopped()) {
						e.currentTarget = i.elem, n = 0;
						while((s = i.handlers[n++]) && !e.isImmediatePropagationStopped())(!e.namespace_re || e.namespace_re.test(s.namespace)) && (e.handleObj = s, e.data = s.data, r = ((o.event.special[s.origType] || {}).handle || s.handler).apply(i.elem, a), void 0 !== r && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()))
					}
					return l.postDispatch && l.postDispatch.call(this, e), e.result
				}
			},
			handlers: function(e, t) {
				var n, r, i, s, u = [],
					a = t.delegateCount,
					f = e.target;
				if(a && f.nodeType && (!e.button || "click" !== e.type))
					for(; f !== this; f = f.parentNode || this)
						if(f.disabled !== !0 || "click" !== e.type) {
							for(r = [], n = 0; a > n; n++) s = t[n], i = s.selector + " ", void 0 === r[i] && (r[i] = s.needsContext ? o(i, this).index(f) >= 0 : o.find(i, this, null, [f]).length), r[i] && r.push(s);
							r.length && u.push({
								elem: f,
								handlers: r
							})
						}
				return a < t.length && u.push({
					elem: this,
					handlers: t.slice(a)
				}), u
			},
			props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
			fixHooks: {},
			keyHooks: {
				props: "char charCode key keyCode".split(" "),
				filter: function(e, t) {
					return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
				}
			},
			mouseHooks: {
				props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
				filter: function(e, t) {
					var n, r, i, s = t.button;
					return null == e.pageX && null != t.clientX && (n = e.target.ownerDocument || m, r = n.documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)), e.which || void 0 === s || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e
				}
			},
			fix: function(e) {
				if(e[o.expando]) return e;
				var t, n, r, i = e.type,
					s = e,
					u = this.fixHooks[i];
				u || (this.fixHooks[i] = u = W.test(i) ? this.mouseHooks : V.test(i) ? this.keyHooks : {}), r = u.props ? this.props.concat(u.props) : this.props, e = new o.Event(s), t = r.length;
				while(t--) n = r[t], e[n] = s[n];
				return e.target || (e.target = m), 3 === e.target.nodeType && (e.target = e.target.parentNode), u.filter ? u.filter(e, s) : e
			},
			special: {
				load: {
					noBubble: !0
				},
				focus: {
					trigger: function() {
						return this !== _() && this.focus ? (this.focus(), !1) : void 0
					},
					delegateType: "focusin"
				},
				blur: {
					trigger: function() {
						return this === _() && this.blur ? (this.blur(), !1) : void 0
					},
					delegateType: "focusout"
				},
				click: {
					trigger: function() {
						return "checkbox" === this.type && this.click && o.nodeName(this, "input") ? (this.click(), !1) : void 0
					},
					_default: function(e) {
						return o.nodeName(e.target, "a")
					}
				},
				beforeunload: {
					postDispatch: function(e) {
						void 0 !== e.result && (e.originalEvent.returnValue = e.result)
					}
				}
			},
			simulate: function(e, t, n, r) {
				var i = o.extend(new o.Event, n, {
					type: e,
					isSimulated: !0,
					originalEvent: {}
				});
				r ? o.event.trigger(i, null, t) : o.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()
			}
		}, o.removeEvent = function(e, t, n) {
			e.removeEventListener && e.removeEventListener(t, n, !1)
		}, o.Event = function(e, t) {
			return this instanceof o.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.getPreventDefault && e.getPreventDefault() ? Z : $) : this.type = e, t && o.extend(this, t), this.timeStamp = e && e.timeStamp || o.now(), void(this[o.expando] = !0)) : new o.Event(e, t)
		}, o.Event.prototype = {
			isDefaultPrevented: $,
			isPropagationStopped: $,
			isImmediatePropagationStopped: $,
			preventDefault: function() {
				var e = this.originalEvent;
				this.isDefaultPrevented = Z, e && e.preventDefault && e.preventDefault()
			},
			stopPropagation: function() {
				var e = this.originalEvent;
				this.isPropagationStopped = Z, e && e.stopPropagation && e.stopPropagation()
			},
			stopImmediatePropagation: function() {
				this.isImmediatePropagationStopped = Z, this.stopPropagation()
			}
		}, o.each({
			mouseenter: "mouseover",
			mouseleave: "mouseout"
		}, function(e, t) {
			o.event.special[e] = {
				delegateType: t,
				bindType: t,
				handle: function(e) {
					var n, r = this,
						i = e.relatedTarget,
						s = e.handleObj;
					return(!i || i !== r && !o.contains(r, i)) && (e.type = s.origType, n = s.handler.apply(this, arguments), e.type = t), n
				}
			}
		}), l.focusinBubbles || o.each({
			focus: "focusin",
			blur: "focusout"
		}, function(e, t) {
			var n = function(e) {
				o.event.simulate(t, e.target, o.event.fix(e), !0)
			};
			o.event.special[t] = {
				setup: function() {
					var r = this.ownerDocument || this,
						i = L.access(r, t);
					i || r.addEventListener(e, n, !0), L.access(r, t, (i || 0) + 1)
				},
				teardown: function() {
					var r = this.ownerDocument || this,
						i = L.access(r, t) - 1;
					i ? L.access(r, t, i) : (r.removeEventListener(e, n, !0), L.remove(r, t))
				}
			}
		}), o.fn.extend({
			on: function(e, t, n, r, i) {
				var s, u;
				if("object" == typeof e) {
					"string" != typeof t && (n = n || t, t = void 0);
					for(u in e) this.on(u, t, n, e[u], i);
					return this
				}
				if(null == n && null == r ? (r = t, n = t = void 0) : null == r && ("string" == typeof t ? (r = n, n = void 0) : (r = n, n = t, t = void 0)), r === !1) r = $;
				else if(!r) return this;
				return 1 === i && (s = r, r = function(e) {
					return o().off(e), s.apply(this, arguments)
				}, r.guid = s.guid || (s.guid = o.guid++)), this.each(function() {
					o.event.add(this, e, r, n, t)
				})
			},
			one: function(e, t, n, r) {
				return this.on(e, t, n, r, 1)
			},
			off: function(e, t, n) {
				var r, i;
				if(e && e.preventDefault && e.handleObj) return r = e.handleObj, o(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
				if("object" == typeof e) {
					for(i in e) this.off(i, t, e[i]);
					return this
				}
				return(t === !1 || "function" == typeof t) && (n = t, t = void 0), n === !1 && (n = $), this.each(function() {
					o.event.remove(this, e, n, t)
				})
			},
			trigger: function(e, t) {
				return this.each(function() {
					o.event.trigger(e, t, this)
				})
			},
			triggerHandler: function(e, t) {
				var n = this[0];
				return n ? o.event.trigger(e, t, n, !0) : void 0
			}
		});
		var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
			bb = /<([\w:]+)/,
			cb = /<|&#?\w+;/,
			db = /<(?:script|style|link)/i,
			eb = /checked\s*(?:[^=]|=\s*.checked.)/i,
			fb = /^$|\/(?:java|ecma)script/i,
			gb = /^true\/(.*)/,
			hb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
			ib = {
				option: [1, "<select multiple='multiple'>", "</select>"],
				thead: [1, "<table>", "</table>"],
				col: [2, "<table><colgroup>", "</colgroup></table>"],
				tr: [2, "<table><tbody>", "</tbody></table>"],
				td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
				_default: [0, "", ""]
			};
		ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td, o.extend({
			clone: function(e, t, n) {
				var r, i, s, u, a = e.cloneNode(!0),
					f = o.contains(e.ownerDocument, e);
				if(!(l.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || o.isXMLDoc(e)))
					for(u = ob(a), s = ob(e), r = 0, i = s.length; i > r; r++) pb(s[r], u[r]);
				if(t)
					if(n)
						for(s = s || ob(e), u = u || ob(a), r = 0, i = s.length; i > r; r++) nb(s[r], u[r]);
					else nb(e, a);
				return u = ob(a, "script"), u.length > 0 && mb(u, !f && ob(e, "script")), a
			},
			buildFragment: function(e, t, n, r) {
				for(var i, s, u, a, f, l, c = t.createDocumentFragment(), h = [], p = 0, d = e.length; d > p; p++)
					if(i = e[p], i || 0 === i)
						if("object" === o.type(i)) o.merge(h, i.nodeType ? [i] : i);
						else if(cb.test(i)) {
					s = s || c.appendChild(t.createElement("div")), u = (bb.exec(i) || ["", ""])[1].toLowerCase(), a = ib[u] || ib._default, s.innerHTML = a[1] + i.replace(ab, "<$1></$2>") + a[2], l = a[0];
					while(l--) s = s.lastChild;
					o.merge(h, s.childNodes), s = c.firstChild, s.textContent = ""
				} else h.push(t.createTextNode(i));
				c.textContent = "", p = 0;
				while(i = h[p++])
					if((!r || -1 === o.inArray(i, r)) && (f = o.contains(i.ownerDocument, i), s = ob(c.appendChild(i), "script"), f && mb(s), n)) {
						l = 0;
						while(i = s[l++]) fb.test(i.type || "") && n.push(i)
					}
				return c
			},
			cleanData: function(e) {
				for(var t, n, r, i, s, u, a = o.event.special, f = 0; void 0 !== (n = e[f]); f++) {
					if(o.acceptData(n) && (s = n[L.expando], s && (t = L.cache[s]))) {
						if(r = Object.keys(t.events || {}), r.length)
							for(u = 0; void 0 !== (i = r[u]); u++) a[i] ? o.event.remove(n, i) : o.removeEvent(n, i, t.handle);
						L.cache[s] && delete L.cache[s]
					}
					delete M.cache[n[M.expando]]
				}
			}
		}), o.fn.extend({
			text: function(e) {
				return J(this, function(e) {
					return void 0 === e ? o.text(this) : this.empty().each(function() {
						(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = e)
					})
				}, null, e, arguments.length)
			},
			append: function() {
				return this.domManip(arguments, function(e) {
					if(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
						var t = jb(this, e);
						t.appendChild(e)
					}
				})
			},
			prepend: function() {
				return this.domManip(arguments, function(e) {
					if(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
						var t = jb(this, e);
						t.insertBefore(e, t.firstChild)
					}
				})
			},
			before: function() {
				return this.domManip(arguments, function(e) {
					this.parentNode && this.parentNode.insertBefore(e, this)
				})
			},
			after: function() {
				return this.domManip(arguments, function(e) {
					this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
				})
			},
			remove: function(e, t) {
				for(var n, r = e ? o.filter(e, this) : this, i = 0; null != (n = r[i]); i++) t || 1 !== n.nodeType || o.cleanData(ob(n)), n.parentNode && (t && o.contains(n.ownerDocument, n) && mb(ob(n, "script")), n.parentNode.removeChild(n));
				return this
			},
			empty: function() {
				for(var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (o.cleanData(ob(e, !1)), e.textContent = "");
				return this
			},
			clone: function(e, t) {
				return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function() {
					return o.clone(this, e, t)
				})
			},
			html: function(e) {
				return J(this, function(e) {
					var t = this[0] || {},
						n = 0,
						r = this.length;
					if(void 0 === e && 1 === t.nodeType) return t.innerHTML;
					if("string" == typeof e && !db.test(e) && !ib[(bb.exec(e) || ["", ""])[1].toLowerCase()]) {
						e = e.replace(ab, "<$1></$2>");
						try {
							for(; r > n; n++) t = this[n] || {}, 1 === t.nodeType && (o.cleanData(ob(t, !1)), t.innerHTML = e);
							t = 0
						} catch(i) {}
					}
					t && this.empty().append(e)
				}, null, e, arguments.length)
			},
			replaceWith: function() {
				var e = arguments[0];
				return this.domManip(arguments, function(t) {
					e = this.parentNode, o.cleanData(ob(this)), e && e.replaceChild(t, this)
				}), e && (e.length || e.nodeType) ? this : this.remove()
			},
			detach: function(e) {
				return this.remove(e, !0)
			},
			domManip: function(t, n) {
				t = e.apply([], t);
				var r, i, s, u, a, f, c = 0,
					h = this.length,
					p = this,
					d = h - 1,
					v = t[0],
					m = o.isFunction(v);
				if(m || h > 1 && "string" == typeof v && !l.checkClone && eb.test(v)) return this.each(function(e) {
					var r = p.eq(e);
					m && (t[0] = v.call(this, e, r.html())), r.domManip(t, n)
				});
				if(h && (r = o.buildFragment(t, this[0].ownerDocument, !1, this), i = r.firstChild, 1 === r.childNodes.length && (r = i), i)) {
					for(s = o.map(ob(r, "script"), kb), u = s.length; h > c; c++) a = r, c !== d && (a = o.clone(a, !0, !0), u && o.merge(s, ob(a, "script"))), n.call(this[c], a, c);
					if(u)
						for(f = s[s.length - 1].ownerDocument, o.map(s, lb), c = 0; u > c; c++) a = s[c], fb.test(a.type || "") && !L.access(a, "globalEval") && o.contains(f, a) && (a.src ? o._evalUrl && o._evalUrl(a.src) : o.globalEval(a.textContent.replace(hb, "")))
				}
				return this
			}
		}), o.each({
			appendTo: "append",
			prependTo: "prepend",
			insertBefore: "before",
			insertAfter: "after",
			replaceAll: "replaceWith"
		}, function(e, t) {
			o.fn[e] = function(e) {
				for(var n, r = [], i = o(e), s = i.length - 1, u = 0; s >= u; u++) n = u === s ? this : this.clone(!0), o(i[u])[t](n), f.apply(r, n.get());
				return this.pushStack(r)
			}
		});
		var qb, rb = {},
			ub = /^margin/,
			vb = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
			wb = function(e) {
				return e.ownerDocument.defaultView.getComputedStyle(e, null)
			};
		! function() {
			function u() {
				s.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%", r.appendChild(i);
				var n = a.getComputedStyle(s, null);
				e = "1%" !== n.top, t = "4px" === n.width, r.removeChild(i)
			}
			var e, t, n = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",
				r = m.documentElement,
				i = m.createElement("div"),
				s = m.createElement("div");
			s.style.backgroundClip = "content-box", s.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === s.style.backgroundClip, i.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", i.appendChild(s), a.getComputedStyle && o.extend(l, {
				pixelPosition: function() {
					return u(), e
				},
				boxSizingReliable: function() {
					return null == t && u(), t
				},
				reliableMarginRight: function() {
					var e, t = s.appendChild(m.createElement("div"));
					return t.style.cssText = s.style.cssText = n, t.style.marginRight = t.style.width = "0", s.style.width = "1px", r.appendChild(i), e = !parseFloat(a.getComputedStyle(t, null).marginRight), r.removeChild(i), s.innerHTML = "", e
				}
			})
		}(), o.swap = function(e, t, n, r) {
			var i, s, o = {};
			for(s in t) o[s] = e.style[s], e.style[s] = t[s];
			i = n.apply(e, r || []);
			for(s in t) e.style[s] = o[s];
			return i
		};
		var zb = /^(none|table(?!-c[ea]).+)/,
			Ab = new RegExp("^(" + Q + ")(.*)$", "i"),
			Bb = new RegExp("^([+-])=(" + Q + ")", "i"),
			Cb = {
				position: "absolute",
				visibility: "hidden",
				display: "block"
			},
			Db = {
				letterSpacing: 0,
				fontWeight: 400
			},
			Eb = ["Webkit", "O", "Moz", "ms"];
		o.extend({
			cssHooks: {
				opacity: {
					get: function(e, t) {
						if(t) {
							var n = xb(e, "opacity");
							return "" === n ? "1" : n
						}
					}
				}
			},
			cssNumber: {
				columnCount: !0,
				fillOpacity: !0,
				fontWeight: !0,
				lineHeight: !0,
				opacity: !0,
				order: !0,
				orphans: !0,
				widows: !0,
				zIndex: !0,
				zoom: !0
			},
			cssProps: {
				"float": "cssFloat"
			},
			style: function(e, t, n, r) {
				if(e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
					var i, s, u, a = o.camelCase(t),
						f = e.style;
					return t = o.cssProps[a] || (o.cssProps[a] = Fb(f, a)), u = o.cssHooks[t] || o.cssHooks[a], void 0 === n ? u && "get" in u && void 0 !== (i = u.get(e, !1, r)) ? i : f[t] : (s = typeof n, "string" === s && (i = Bb.exec(n)) && (n = (i[1] + 1) * i[2] + parseFloat(o.css(e, t)), s = "number"), null != n && n === n && ("number" !== s || o.cssNumber[a] || (n += "px"), l.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (f[t] = "inherit"), u && "set" in u && void 0 === (n = u.set(e, n, r)) || (f[t] = "", f[t] = n)), void 0)
				}
			},
			css: function(e, t, n, r) {
				var i, s, u, a = o.camelCase(t);
				return t = o.cssProps[a] || (o.cssProps[a] = Fb(e.style, a)), u = o.cssHooks[t] || o.cssHooks[a], u && "get" in u && (i = u.get(e, !0, n)), void 0 === i && (i = xb(e, t, r)), "normal" === i && t in Db && (i = Db[t]), "" === n || n ? (s = parseFloat(i), n === !0 || o.isNumeric(s) ? s || 0 : i) : i
			}
		}), o.each(["height", "width"], function(e, t) {
			o.cssHooks[t] = {
				get: function(e, n, r) {
					return n ? 0 === e.offsetWidth && zb.test(o.css(e, "display")) ? o.swap(e, Cb, function() {
						return Ib(e, t, r)
					}) : Ib(e, t, r) : void 0
				},
				set: function(e, n, r) {
					var i = r && wb(e);
					return Gb(e, n, r ? Hb(e, t, r, "border-box" === o.css(e, "boxSizing", !1, i), i) : 0)
				}
			}
		}), o.cssHooks.marginRight = yb(l.reliableMarginRight, function(e, t) {
			return t ? o.swap(e, {
				display: "inline-block"
			}, xb, [e, "marginRight"]) : void 0
		}), o.each({
			margin: "",
			padding: "",
			border: "Width"
		}, function(e, t) {
			o.cssHooks[e + t] = {
				expand: function(n) {
					for(var r = 0, i = {}, s = "string" == typeof n ? n.split(" ") : [n]; 4 > r; r++) i[e + R[r] + t] = s[r] || s[r - 2] || s[0];
					return i
				}
			}, ub.test(e) || (o.cssHooks[e + t].set = Gb)
		}), o.fn.extend({
			css: function(e, t) {
				return J(this, function(e, t, n) {
					var r, i, s = {},
						u = 0;
					if(o.isArray(t)) {
						for(r = wb(e), i = t.length; i > u; u++) s[t[u]] = o.css(e, t[u], !1, r);
						return s
					}
					return void 0 !== n ? o.style(e, t, n) : o.css(e, t)
				}, e, t, arguments.length > 1)
			},
			show: function() {
				return Jb(this, !0)
			},
			hide: function() {
				return Jb(this)
			},
			toggle: function(e) {
				return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
					S(this) ? o(this).show() : o(this).hide()
				})
			}
		}), o.Tween = Kb, Kb.prototype = {
			constructor: Kb,
			init: function(e, t, n, r, i, s) {
				this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = s || (o.cssNumber[n] ? "" : "px")
			},
			cur: function() {
				var e = Kb.propHooks[this.prop];
				return e && e.get ? e.get(this) : Kb.propHooks._default.get(this)
			},
			run: function(e) {
				var t, n = Kb.propHooks[this.prop];
				return this.pos = t = this.options.duration ? o.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Kb.propHooks._default.set(this), this
			}
		}, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {
			_default: {
				get: function(e) {
					var t;
					return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = o.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
				},
				set: function(e) {
					o.fx.step[e.prop] ? o.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[o.cssProps[e.prop]] || o.cssHooks[e.prop]) ? o.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
				}
			}
		}, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {
			set: function(e) {
				e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
			}
		}, o.easing = {
			linear: function(e) {
				return e
			},
			swing: function(e) {
				return .5 - Math.cos(e * Math.PI) / 2
			}
		}, o.fx = Kb.prototype.init, o.fx.step = {};
		var Lb, Mb, Nb = /^(?:toggle|show|hide)$/,
			Ob = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
			Pb = /queueHooks$/,
			Qb = [Vb],
			Rb = {
				"*": [function(e, t) {
					var n = this.createTween(e, t),
						r = n.cur(),
						i = Ob.exec(t),
						s = i && i[3] || (o.cssNumber[e] ? "" : "px"),
						u = (o.cssNumber[e] || "px" !== s && +r) && Ob.exec(o.css(n.elem, e)),
						a = 1,
						f = 20;
					if(u && u[3] !== s) {
						s = s || u[3], i = i || [], u = +r || 1;
						do a = a || ".5", u /= a, o.style(n.elem, e, u + s); while (a !== (a = n.cur() / r) && 1 !== a && --f)
					}
					return i && (u = n.start = +u || +r || 0, n.unit = s, n.end = i[1] ? u + (i[1] + 1) * i[2] : +i[2]), n
				}]
			};
		o.Animation = o.extend(Xb, {
				tweener: function(e, t) {
					o.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
					for(var n, r = 0, i = e.length; i > r; r++) n = e[r], Rb[n] = Rb[n] || [], Rb[n].unshift(t)
				},
				prefilter: function(e, t) {
					t ? Qb.unshift(e) : Qb.push(e)
				}
			}), o.speed = function(e, t, n) {
				var r = e && "object" == typeof e ? o.extend({}, e) : {
					complete: n || !n && t || o.isFunction(e) && e,
					duration: e,
					easing: n && t || t && !o.isFunction(t) && t
				};
				return r.duration = o.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in o.fx.speeds ? o.fx.speeds[r.duration] : o.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function() {
					o.isFunction(r.old) && r.old.call(this), r.queue && o.dequeue(this, r.queue)
				}, r
			}, o.fn.extend({
				fadeTo: function(e, t, n, r) {
					return this.filter(S).css("opacity", 0).show().end().animate({
						opacity: t
					}, e, n, r)
				},
				animate: function(e, t, n, r) {
					var i = o.isEmptyObject(e),
						s = o.speed(t, n, r),
						u = function() {
							var t = Xb(this, o.extend({}, e), s);
							(i || L.get(this, "finish")) && t.stop(!0)
						};
					return u.finish = u, i || s.queue === !1 ? this.each(u) : this.queue(s.queue, u)
				},
				stop: function(e, t, n) {
					var r = function(e) {
						var t = e.stop;
						delete e.stop, t(n)
					};
					return "string" != typeof e && (n = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function() {
						var t = !0,
							i = null != e && e + "queueHooks",
							s = o.timers,
							u = L.get(this);
						if(i) u[i] && u[i].stop && r(u[i]);
						else
							for(i in u) u[i] && u[i].stop && Pb.test(i) && r(u[i]);
						for(i = s.length; i--;) s[i].elem !== this || null != e && s[i].queue !== e || (s[i].anim.stop(n), t = !1, s.splice(i, 1));
						(t || !n) && o.dequeue(this, e)
					})
				},
				finish: function(e) {
					return e !== !1 && (e = e || "fx"), this.each(function() {
						var t, n = L.get(this),
							r = n[e + "queue"],
							i = n[e + "queueHooks"],
							s = o.timers,
							u = r ? r.length : 0;
						for(n.finish = !0, o.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = s.length; t--;) s[t].elem === this && s[t].queue === e && (s[t].anim.stop(!0), s.splice(t, 1));
						for(t = 0; u > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
						delete n.finish
					})
				}
			}), o.each(["toggle", "show", "hide"], function(e, t) {
				var n = o.fn[t];
				o.fn[t] = function(e, r, i) {
					return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(Tb(t, !0), e, r, i)
				}
			}), o.each({
				slideDown: Tb("show"),
				slideUp: Tb("hide"),
				slideToggle: Tb("toggle"),
				fadeIn: {
					opacity: "show"
				},
				fadeOut: {
					opacity: "hide"
				},
				fadeToggle: {
					opacity: "toggle"
				}
			}, function(e, t) {
				o.fn[e] = function(e, n, r) {
					return this.animate(t, e, n, r)
				}
			}), o.timers = [], o.fx.tick = function() {
				var e, t = 0,
					n = o.timers;
				for(Lb = o.now(); t < n.length; t++) e = n[t], e() || n[t] !== e || n.splice(t--, 1);
				n.length || o.fx.stop(), Lb = void 0
			}, o.fx.timer = function(e) {
				o.timers.push(e), e() ? o.fx.start() : o.timers.pop()
			}, o.fx.interval = 13, o.fx.start = function() {
				Mb || (Mb = setInterval(o.fx.tick, o.fx.interval))
			}, o.fx.stop = function() {
				clearInterval(Mb), Mb = null
			}, o.fx.speeds = {
				slow: 600,
				fast: 200,
				_default: 400
			}, o.fn.delay = function(e, t) {
				return e = o.fx ? o.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, n) {
					var r = setTimeout(t, e);
					n.stop = function() {
						clearTimeout(r)
					}
				})
			},
			function() {
				var e = m.createElement("input"),
					t = m.createElement("select"),
					n = t.appendChild(m.createElement("option"));
				e.type = "checkbox", l.checkOn = "" !== e.value, l.optSelected = n.selected, t.disabled = !0, l.optDisabled = !n.disabled, e = m.createElement("input"), e.value = "t", e.type = "radio", l.radioValue = "t" === e.value
			}();
		var Yb, Zb, $b = o.expr.attrHandle;
		o.fn.extend({
			attr: function(e, t) {
				return J(this, o.attr, e, t, arguments.length > 1)
			},
			removeAttr: function(e) {
				return this.each(function() {
					o.removeAttr(this, e)
				})
			}
		}), o.extend({
			attr: function(e, t, n) {
				var r, i, s = e.nodeType;
				if(e && 3 !== s && 8 !== s && 2 !== s) return typeof e.getAttribute === U ? o.prop(e, t, n) : (1 === s && o.isXMLDoc(e) || (t = t.toLowerCase(), r = o.attrHooks[t] || (o.expr.match.bool.test(t) ? Zb : Yb)), void 0 === n ? r && "get" in r && null !== (i = r.get(e, t)) ? i : (i = o.find.attr(e, t), null == i ? void 0 : i) : null !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : void o.removeAttr(e, t))
			},
			removeAttr: function(e, t) {
				var n, r, i = 0,
					s = t && t.match(E);
				if(s && 1 === e.nodeType)
					while(n = s[i++]) r = o.propFix[n] || n, o.expr.match.bool.test(n) && (e[r] = !1), e.removeAttribute(n)
			},
			attrHooks: {
				type: {
					set: function(e, t) {
						if(!l.radioValue && "radio" === t && o.nodeName(e, "input")) {
							var n = e.value;
							return e.setAttribute("type", t), n && (e.value = n), t
						}
					}
				}
			}
		}), Zb = {
			set: function(e, t, n) {
				return t === !1 ? o.removeAttr(e, n) : e.setAttribute(n, n), n
			}
		}, o.each(o.expr.match.bool.source.match(/\w+/g), function(e, t) {
			var n = $b[t] || o.find.attr;
			$b[t] = function(e, t, r) {
				var i, s;
				return r || (s = $b[t], $b[t] = i, i = null != n(e, t, r) ? t.toLowerCase() : null, $b[t] = s), i
			}
		});
		var _b = /^(?:input|select|textarea|button)$/i;
		o.fn.extend({
			prop: function(e, t) {
				return J(this, o.prop, e, t, arguments.length > 1)
			},
			removeProp: function(e) {
				return this.each(function() {
					delete this[o.propFix[e] || e]
				})
			}
		}), o.extend({
			propFix: {
				"for": "htmlFor",
				"class": "className"
			},
			prop: function(e, t, n) {
				var r, i, s, u = e.nodeType;
				if(e && 3 !== u && 8 !== u && 2 !== u) return s = 1 !== u || !o.isXMLDoc(e), s && (t = o.propFix[t] || t, i = o.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
			},
			propHooks: {
				tabIndex: {
					get: function(e) {
						return e.hasAttribute("tabindex") || _b.test(e.nodeName) || e.href ? e.tabIndex : -1
					}
				}
			}
		}), l.optSelected || (o.propHooks.selected = {
			get: function(e) {
				var t = e.parentNode;
				return t && t.parentNode && t.parentNode.selectedIndex, null
			}
		}), o.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
			o.propFix[this.toLowerCase()] = this
		});
		var ac = /[\t\r\n\f]/g;
		o.fn.extend({
			addClass: function(e) {
				var t, n, r, i, s, u, a = "string" == typeof e && e,
					f = 0,
					l = this.length;
				if(o.isFunction(e)) return this.each(function(t) {
					o(this).addClass(e.call(this, t, this.className))
				});
				if(a)
					for(t = (e || "").match(E) || []; l > f; f++)
						if(n = this[f], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ac, " ") : " ")) {
							s = 0;
							while(i = t[s++]) r.indexOf(" " + i + " ") < 0 && (r += i + " ");
							u = o.trim(r), n.className !== u && (n.className = u)
						}
				return this
			},
			removeClass: function(e) {
				var t, n, r, i, s, u, a = 0 === arguments.length || "string" == typeof e && e,
					f = 0,
					l = this.length;
				if(o.isFunction(e)) return this.each(function(t) {
					o(this).removeClass(e.call(this, t, this.className))
				});
				if(a)
					for(t = (e || "").match(E) || []; l > f; f++)
						if(n = this[f], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ac, " ") : "")) {
							s = 0;
							while(i = t[s++])
								while(r.indexOf(" " + i + " ") >= 0) r = r.replace(" " + i + " ", " ");
							u = e ? o.trim(r) : "", n.className !== u && (n.className = u)
						}
				return this
			},
			toggleClass: function(e, t) {
				var n = typeof e;
				return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : this.each(o.isFunction(e) ? function(n) {
					o(this).toggleClass(e.call(this, n, this.className, t), t)
				} : function() {
					if("string" === n) {
						var t, r = 0,
							i = o(this),
							s = e.match(E) || [];
						while(t = s[r++]) i.hasClass(t) ? i.removeClass(t) : i.addClass(t)
					} else(n === U || "boolean" === n) && (this.className && L.set(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : L.get(this, "__className__") || "")
				})
			},
			hasClass: function(e) {
				for(var t = " " + e + " ", n = 0, r = this.length; r > n; n++)
					if(1 === this[n].nodeType && (" " + this[n].className + " ").replace(ac, " ").indexOf(t) >= 0) return !0;
				return !1
			}
		});
		var bc = /\r/g;
		o.fn.extend({
			val: function(e) {
				var t, n, r, i = this[0];
				if(arguments.length) return r = o.isFunction(e), this.each(function(n) {
					var i;
					1 === this.nodeType && (i = r ? e.call(this, n, o(this).val()) : e, null == i ? i = "" : "number" == typeof i ? i += "" : o.isArray(i) && (i = o.map(i, function(e) {
						return null == e ? "" : e + ""
					})), t = o.valHooks[this.type] || o.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i))
				});
				if(i) return t = o.valHooks[i.type] || o.valHooks[i.nodeName.toLowerCase()], t && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : (n = i.value, "string" == typeof n ? n.replace(bc, "") : null == n ? "" : n)
			}
		}), o.extend({
			valHooks: {
				select: {
					get: function(e) {
						for(var t, n, r = e.options, i = e.selectedIndex, s = "select-one" === e.type || 0 > i, u = s ? null : [], a = s ? i + 1 : r.length, f = 0 > i ? a : s ? i : 0; a > f; f++)
							if(n = r[f], !(!n.selected && f !== i || (l.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && o.nodeName(n.parentNode, "optgroup"))) {
								if(t = o(n).val(), s) return t;
								u.push(t)
							}
						return u
					},
					set: function(e, t) {
						var n, r, i = e.options,
							s = o.makeArray(t),
							u = i.length;
						while(u--) r = i[u], (r.selected = o.inArray(o(r).val(), s) >= 0) && (n = !0);
						return n || (e.selectedIndex = -1), s
					}
				}
			}
		}), o.each(["radio", "checkbox"], function() {
			o.valHooks[this] = {
				set: function(e, t) {
					return o.isArray(t) ? e.checked = o.inArray(o(e).val(), t) >= 0 : void 0
				}
			}, l.checkOn || (o.valHooks[this].get = function(e) {
				return null === e.getAttribute("value") ? "on" : e.value
			})
		}), o.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
			o.fn[t] = function(e, n) {
				return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
			}
		}), o.fn.extend({
			hover: function(e, t) {
				return this.mouseenter(e).mouseleave(t || e)
			},
			bind: function(e, t, n) {
				return this.on(e, null, t, n)
			},
			unbind: function(e, t) {
				return this.off(e, null, t)
			},
			delegate: function(e, t, n, r) {
				return this.on(t, e, n, r)
			},
			undelegate: function(e, t, n) {
				return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
			}
		});
		var cc = o.now(),
			dc = /\?/;
		o.parseJSON = function(e) {
			return JSON.parse(e + "")
		}, o.parseXML = function(e) {
			var t, n;
			if(!e || "string" != typeof e) return null;
			try {
				n = new DOMParser, t = n.parseFromString(e, "text/xml")
			} catch(r) {
				t = void 0
			}
			return(!t || t.getElementsByTagName("parsererror").length) && o.error("Invalid XML: " + e), t
		};
		var ec, fc, gc = /#.*$/,
			hc = /([?&])_=[^&]*/,
			ic = /^(.*?):[ \t]*([^\r\n]*)$/gm,
			jc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
			kc = /^(?:GET|HEAD)$/,
			lc = /^\/\//,
			mc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
			nc = {},
			oc = {},
			pc = "*/".concat("*");
		try {
			fc = location.href
		} catch(qc) {
			fc = m.createElement("a"), fc.href = "", fc = fc.href
		}
		ec = mc.exec(fc.toLowerCase()) || [], o.extend({
			active: 0,
			lastModified: {},
			etag: {},
			ajaxSettings: {
				url: fc,
				type: "GET",
				isLocal: jc.test(ec[1]),
				global: !0,
				processData: !0,
				async: !0,
				contentType: "application/x-www-form-urlencoded; charset=UTF-8",
				accepts: {
					"*": pc,
					text: "text/plain",
					html: "text/html",
					xml: "application/xml, text/xml",
					json: "application/json, text/javascript"
				},
				contents: {
					xml: /xml/,
					html: /html/,
					json: /json/
				},
				responseFields: {
					xml: "responseXML",
					text: "responseText",
					json: "responseJSON"
				},
				converters: {
					"* text": String,
					"text html": !0,
					"text json": o.parseJSON,
					"text xml": o.parseXML
				},
				flatOptions: {
					url: !0,
					context: !0
				}
			},
			ajaxSetup: function(e, t) {
				return t ? tc(tc(e, o.ajaxSettings), t) : tc(o.ajaxSettings, e)
			},
			ajaxPrefilter: rc(nc),
			ajaxTransport: rc(oc),
			ajax: function(e, t) {
				function T(e, t, s, a) {
					var l, g, y, w, E, x = t;
					2 !== b && (b = 2, u && clearTimeout(u), n = void 0, i = a || "", S.readyState = e > 0 ? 4 : 0, l = e >= 200 && 300 > e || 304 === e, s && (w = uc(c, S, s)), w = vc(c, w, S, l), l ? (c.ifModified && (E = S.getResponseHeader("Last-Modified"), E && (o.lastModified[r] = E), E = S.getResponseHeader("etag"), E && (o.etag[r] = E)), 204 === e || "HEAD" === c.type ? x = "nocontent" : 304 === e ? x = "notmodified" : (x = w.state, g = w.data, y = w.error, l = !y)) : (y = x, (e || !x) && (x = "error", 0 > e && (e = 0))), S.status = e, S.statusText = (t || x) + "", l ? d.resolveWith(h, [g, x, S]) : d.rejectWith(h, [S, x, y]), S.statusCode(m), m = void 0, f && p.trigger(l ? "ajaxSuccess" : "ajaxError", [S, c, l ? g : y]), v.fireWith(h, [S, x]), f && (p.trigger("ajaxComplete", [S, c]), --o.active || o.event.trigger("ajaxStop")))
				}
				"object" == typeof e && (t = e, e = void 0), t = t || {};
				var n, r, i, s, u, a, f, l, c = o.ajaxSetup({}, t),
					h = c.context || c,
					p = c.context && (h.nodeType || h.jquery) ? o(h) : o.event,
					d = o.Deferred(),
					v = o.Callbacks("once memory"),
					m = c.statusCode || {},
					g = {},
					y = {},
					b = 0,
					w = "canceled",
					S = {
						readyState: 0,
						getResponseHeader: function(e) {
							var t;
							if(2 === b) {
								if(!s) {
									s = {};
									while(t = ic.exec(i)) s[t[1].toLowerCase()] = t[2]
								}
								t = s[e.toLowerCase()]
							}
							return null == t ? null : t
						},
						getAllResponseHeaders: function() {
							return 2 === b ? i : null
						},
						setRequestHeader: function(e, t) {
							var n = e.toLowerCase();
							return b || (e = y[n] = y[n] || e, g[e] = t), this
						},
						overrideMimeType: function(e) {
							return b || (c.mimeType = e), this
						},
						statusCode: function(e) {
							var t;
							if(e)
								if(2 > b)
									for(t in e) m[t] = [m[t], e[t]];
								else S.always(e[S.status]);
							return this
						},
						abort: function(e) {
							var t = e || w;
							return n && n.abort(t), T(0, t), this
						}
					};
				if(d.promise(S).complete = v.add, S.success = S.done, S.error = S.fail, c.url = ((e || c.url || fc) + "").replace(gc, "").replace(lc, ec[1] + "//"), c.type = t.method || t.type || c.method || c.type, c.dataTypes = o.trim(c.dataType || "*").toLowerCase().match(E) || [""], null == c.crossDomain && (a = mc.exec(c.url.toLowerCase()), c.crossDomain = !(!a || a[1] === ec[1] && a[2] === ec[2] && (a[3] || ("http:" === a[1] ? "80" : "443")) === (ec[3] || ("http:" === ec[1] ? "80" : "443")))), c.data && c.processData && "string" != typeof c.data && (c.data = o.param(c.data, c.traditional)), sc(nc, c, t, S), 2 === b) return S;
				f = c.global, f && 0 === o.active++ && o.event.trigger("ajaxStart"), c.type = c.type.toUpperCase(), c.hasContent = !kc.test(c.type), r = c.url, c.hasContent || (c.data && (r = c.url += (dc.test(r) ? "&" : "?") + c.data, delete c.data), c.cache === !1 && (c.url = hc.test(r) ? r.replace(hc, "$1_=" + cc++) : r + (dc.test(r) ? "&" : "?") + "_=" + cc++)), c.ifModified && (o.lastModified[r] && S.setRequestHeader("If-Modified-Since", o.lastModified[r]), o.etag[r] && S.setRequestHeader("If-None-Match", o.etag[r])), (c.data && c.hasContent && c.contentType !== !1 || t.contentType) && S.setRequestHeader("Content-Type", c.contentType), S.setRequestHeader("Accept", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + ("*" !== c.dataTypes[0] ? ", " + pc + "; q=0.01" : "") : c.accepts["*"]);
				for(l in c.headers) S.setRequestHeader(l, c.headers[l]);
				if(!c.beforeSend || c.beforeSend.call(h, S, c) !== !1 && 2 !== b) {
					w = "abort";
					for(l in {
							success: 1,
							error: 1,
							complete: 1
						}) S[l](c[l]);
					if(n = sc(oc, c, t, S)) {
						S.readyState = 1, f && p.trigger("ajaxSend", [S, c]), c.async && c.timeout > 0 && (u = setTimeout(function() {
							S.abort("timeout")
						}, c.timeout));
						try {
							b = 1, n.send(g, T)
						} catch(x) {
							if(!(2 > b)) throw x;
							T(-1, x)
						}
					} else T(-1, "No Transport");
					return S
				}
				return S.abort()
			},
			getJSON: function(e, t, n) {
				return o.get(e, t, n, "json")
			},
			getScript: function(e, t) {
				return o.get(e, void 0, t, "script")
			}
		}), o.each(["get", "post"], function(e, t) {
			o[t] = function(e, n, r, i) {
				return o.isFunction(n) && (i = i || r, r = n, n = void 0), o.ajax({
					url: e,
					type: t,
					dataType: i,
					data: n,
					success: r
				})
			}
		}), o.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
			o.fn[t] = function(e) {
				return this.on(t, e)
			}
		}), o._evalUrl = function(e) {
			return o.ajax({
				url: e,
				type: "GET",
				dataType: "script",
				async: !1,
				global: !1,
				"throws": !0
			})
		}, o.fn.extend({
			wrapAll: function(e) {
				var t;
				return o.isFunction(e) ? this.each(function(t) {
					o(this).wrapAll(e.call(this, t))
				}) : (this[0] && (t = o(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
					var e = this;
					while(e.firstElementChild) e = e.firstElementChild;
					return e
				}).append(this)), this)
			},
			wrapInner: function(e) {
				return this.each(o.isFunction(e) ? function(t) {
					o(this).wrapInner(e.call(this, t))
				} : function() {
					var t = o(this),
						n = t.contents();
					n.length ? n.wrapAll(e) : t.append(e)
				})
			},
			wrap: function(e) {
				var t = o.isFunction(e);
				return this.each(function(n) {
					o(this).wrapAll(t ? e.call(this, n) : e)
				})
			},
			unwrap: function() {
				return this.parent().each(function() {
					o.nodeName(this, "body") || o(this).replaceWith(this.childNodes)
				}).end()
			}
		}), o.expr.filters.hidden = function(e) {
			return e.offsetWidth <= 0 && e.offsetHeight <= 0
		}, o.expr.filters.visible = function(e) {
			return !o.expr.filters.hidden(e)
		};
		var wc = /%20/g,
			xc = /\[\]$/,
			yc = /\r?\n/g,
			zc = /^(?:submit|button|image|reset|file)$/i,
			Ac = /^(?:input|select|textarea|keygen)/i;
		o.param = function(e, t) {
			var n, r = [],
				i = function(e, t) {
					t = o.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
				};
			if(void 0 === t && (t = o.ajaxSettings && o.ajaxSettings.traditional), o.isArray(e) || e.jquery && !o.isPlainObject(e)) o.each(e, function() {
				i(this.name, this.value)
			});
			else
				for(n in e) Bc(n, e[n], t, i);
			return r.join("&").replace(wc, "+")
		}, o.fn.extend({
			serialize: function() {
				return o.param(this.serializeArray())
			},
			serializeArray: function() {
				return this.map(function() {
					var e = o.prop(this, "elements");
					return e ? o.makeArray(e) : this
				}).filter(function() {
					var e = this.type;
					return this.name && !o(this).is(":disabled") && Ac.test(this.nodeName) && !zc.test(e) && (this.checked || !T.test(e))
				}).map(function(e, t) {
					var n = o(this).val();
					return null == n ? null : o.isArray(n) ? o.map(n, function(e) {
						return {
							name: t.name,
							value: e.replace(yc, "\r\n")
						}
					}) : {
						name: t.name,
						value: n.replace(yc, "\r\n")
					}
				}).get()
			}
		}), o.ajaxSettings.xhr = function() {
			try {
				return new XMLHttpRequest
			} catch(e) {}
		};
		var Cc = 0,
			Dc = {},
			Ec = {
				0: 200,
				1223: 204
			},
			Fc = o.ajaxSettings.xhr();
		a.ActiveXObject && o(a).on("unload", function() {
			for(var e in Dc) Dc[e]()
		}), l.cors = !!Fc && "withCredentials" in Fc, l.ajax = Fc = !!Fc, o.ajaxTransport(function(e) {
			var t;
			return l.cors || Fc && !e.crossDomain ? {
				send: function(n, r) {
					var i, s = e.xhr(),
						o = ++Cc;
					if(s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
						for(i in e.xhrFields) s[i] = e.xhrFields[i];
					e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
					for(i in n) s.setRequestHeader(i, n[i]);
					t = function(e) {
						return function() {
							t && (delete Dc[o], t = s.onload = s.onerror = null, "abort" === e ? s.abort() : "error" === e ? r(s.status, s.statusText) : r(Ec[s.status] || s.status, s.statusText, "string" == typeof s.responseText ? {
								text: s.responseText
							} : void 0, s.getAllResponseHeaders()))
						}
					}, s.onload = t(), s.onerror = t("error"), t = Dc[o] = t("abort"), s.send(e.hasContent && e.data || null)
				},
				abort: function() {
					t && t()
				}
			} : void 0
		}), o.ajaxSetup({
			accepts: {
				script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
			},
			contents: {
				script: /(?:java|ecma)script/
			},
			converters: {
				"text script": function(e) {
					return o.globalEval(e), e
				}
			}
		}), o.ajaxPrefilter("script", function(e) {
			void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
		}), o.ajaxTransport("script", function(e) {
			if(e.crossDomain) {
				var t, n;
				return {
					send: function(r, i) {
						t = o("<script>").prop({
							async: !0,
							charset: e.scriptCharset,
							src: e.url
						}).on("load error", n = function(e) {
							t.remove(), n = null, e && i("error" === e.type ? 404 : 200, e.type)
						}), m.head.appendChild(t[0])
					},
					abort: function() {
						n && n()
					}
				}
			}
		});
		var Gc = [],
			Hc = /(=)\?(?=&|$)|\?\?/;
		o.ajaxSetup({
			jsonp: "callback",
			jsonpCallback: function() {
				var e = Gc.pop() || o.expando + "_" + cc++;
				return this[e] = !0, e
			}
		}), o.ajaxPrefilter("json jsonp", function(e, t, n) {
			var r, i, s, u = e.jsonp !== !1 && (Hc.test(e.url) ? "url" : "string" == typeof e.data && !(e.contentType || "").indexOf("application/x-www-form-urlencoded") && Hc.test(e.data) && "data");
			return u || "jsonp" === e.dataTypes[0] ? (r = e.jsonpCallback = o.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, u ? e[u] = e[u].replace(Hc, "$1" + r) : e.jsonp !== !1 && (e.url += (dc.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() {
				return s || o.error(r + " was not called"), s[0]
			}, e.dataTypes[0] = "json", i = a[r], a[r] = function() {
				s = arguments
			}, n.always(function() {
				a[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Gc.push(r)), s && o.isFunction(i) && i(s[0]), s = i = void 0
			}), "script") : void 0
		}), o.parseHTML = function(e, t, n) {
			if(!e || "string" != typeof e) return null;
			"boolean" == typeof t && (n = t, t = !1), t = t || m;
			var r = v.exec(e),
				i = !n && [];
			return r ? [t.createElement(r[1])] : (r = o.buildFragment([e], t, i), i && i.length && o(i).remove(), o.merge([], r.childNodes))
		};
		var Ic = o.fn.load;
		o.fn.load = function(e, t, n) {
			if("string" != typeof e && Ic) return Ic.apply(this, arguments);
			var r, i, s, u = this,
				a = e.indexOf(" ");
			return a >= 0 && (r = e.slice(a), e = e.slice(0, a)), o.isFunction(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), u.length > 0 && o.ajax({
				url: e,
				type: i,
				dataType: "html",
				data: t
			}).done(function(e) {
				s = arguments, u.html(r ? o("<div>").append(o.parseHTML(e)).find(r) : e)
			}).complete(n && function(e, t) {
				u.each(n, s || [e.responseText, t, e])
			}), this
		}, o.expr.filters.animated = function(e) {
			return o.grep(o.timers, function(t) {
				return e === t.elem
			}).length
		};
		var Jc = a.document.documentElement;
		o.offset = {
			setOffset: function(e, t, n) {
				var r, i, s, u, a, f, l, c = o.css(e, "position"),
					h = o(e),
					p = {};
				"static" === c && (e.style.position = "relative"), a = h.offset(), s = o.css(e, "top"), f = o.css(e, "left"), l = ("absolute" === c || "fixed" === c) && (s + f).indexOf("auto") > -1, l ? (r = h.position(), u = r.top, i = r.left) : (u = parseFloat(s) || 0, i = parseFloat(f) || 0), o.isFunction(t) && (t = t.call(e, n, a)), null != t.top && (p.top = t.top - a.top + u), null != t.left && (p.left = t.left - a.left + i), "using" in t ? t.using.call(e, p) : h.css(p)
			}
		}, o.fn.extend({
			offset: function(e) {
				if(arguments.length) return void 0 === e ? this : this.each(function(t) {
					o.offset.setOffset(this, e, t)
				});
				var t, n, r = this[0],
					i = {
						top: 0,
						left: 0
					},
					s = r && r.ownerDocument;
				if(s) return t = s.documentElement, o.contains(t, r) ? (typeof r.getBoundingClientRect !== U && (i = r.getBoundingClientRect()), n = Kc(s), {
					top: i.top + n.pageYOffset - t.clientTop,
					left: i.left + n.pageXOffset - t.clientLeft
				}) : i
			},
			position: function() {
				if(this[0]) {
					var e, t, n = this[0],
						r = {
							top: 0,
							left: 0
						};
					return "fixed" === o.css(n, "position") ? t = n.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), o.nodeName(e[0], "html") || (r = e.offset()), r.top += o.css(e[0], "borderTopWidth", !0), r.left += o.css(e[0], "borderLeftWidth", !0)), {
						top: t.top - r.top - o.css(n, "marginTop", !0),
						left: t.left - r.left - o.css(n, "marginLeft", !0)
					}
				}
			},
			offsetParent: function() {
				return this.map(function() {
					var e = this.offsetParent || Jc;
					while(e && !o.nodeName(e, "html") && "static" === o.css(e, "position")) e = e.offsetParent;
					return e || Jc
				})
			}
		}), o.each({
			scrollLeft: "pageXOffset",
			scrollTop: "pageYOffset"
		}, function(e, t) {
			var n = "pageYOffset" === t;
			o.fn[e] = function(r) {
				return J(this, function(e, r, i) {
					var s = Kc(e);
					return void 0 === i ? s ? s[t] : e[r] : void(s ? s.scrollTo(n ? a.pageXOffset : i, n ? i : a.pageYOffset) : e[r] = i)
				}, e, r, arguments.length, null)
			}
		}), o.each(["top", "left"], function(e, t) {
			o.cssHooks[t] = yb(l.pixelPosition, function(e, n) {
				return n ? (n = xb(e, t), vb.test(n) ? o(e).position()[t] + "px" : n) : void 0
			})
		}), o.each({
			Height: "height",
			Width: "width"
		}, function(e, t) {
			o.each({
				padding: "inner" + e,
				content: t,
				"": "outer" + e
			}, function(n, r) {
				o.fn[r] = function(r, i) {
					var s = arguments.length && (n || "boolean" != typeof r),
						u = n || (r === !0 || i === !0 ? "margin" : "border");
					return J(this, function(t, n, r) {
						var i;
						return o.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (i = t.documentElement, Math.max(t.body["scroll" + e], i["scroll" + e], t.body["offset" + e], i["offset" + e], i["client" + e])) : void 0 === r ? o.css(t, n, u) : o.style(t, n, r, u)
					}, t, s ? r : void 0, s, null)
				}
			})
		}), o.fn.size = function() {
			return this.length
		}, o.fn.andSelf = o.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
			return o
		});
		var Lc = a.jQuery,
			Mc = a.$;
		return o.noConflict = function(e) {
			return a.$ === o && (a.$ = Mc), e && a.jQuery === o && (a.jQuery = Lc), o
		}, typeof b === U && (a.jQuery = a.$ = o), o
	}), define("app/loading", ["gsap", "jquery"], function() {
		var e = $(".loading"),
			t = $(".egg"),
			n = $(".egg-shadow"),
			r = $(".intro-logo"),
			i = $(".load-progress, .load-mobile-prompt"),
			s = $(".load-progress .red"),
			o = $("nav .prompt"),
			u = $(".logo"),
			a = $(".loader"),
			f = function() {
				l.kill(), c.kill(), e.remove(), l = null, c = null, e = null, t = null, n = null, r = null, i = null, s = null, o = null, u = null, a = null
			},
			l = new TimelineMax({
				yoyo: !0,
				repeat: -1
			}),
			c = new TimelineMax({
				paused: !0,
				onComplete: f
			});
		l.add([TweenLite.to(t, .17, {
			y: 20,
			rotation: 0,
			scaleY: .95,
			ease: Power1.easeIn
		}), TweenLite.to(n, .17, {
			opacity: 1,
			scale: 1,
			ease: Power1.easeIn
		})]), l.add([TweenLite.to(t, .22, {
			y: 5,
			rotation: 1,
			scaleY: 1,
			ease: Power1.easeOut,
			delay: .05
		}), TweenLite.to(n, .22, {
			opacity: .6,
			scale: .8,
			ease: Power1.easeOut,
			delay: .05
		})]), c.add([TweenLite.to(a, .7, {
			opacity: 0,
			scale: 1.05,
			ease: Power1.easeInOut,
			delay: 0
		}), TweenLite.to(r, .6, {
			opacity: 0,
			scale: 1.05,
			ease: Power1.easeInOut,
			delay: .4
		}), TweenLite.to(i, .2, {
			opacity: 0,
			y: 3,
			ease: Power1.easeOut,
			delay: .75
		}), TweenLite.to(t, .2, {
			y: 20,
			rotation: 0,
			scaleY: .95,
			ease: Power1.easeIn
		}), TweenLite.to(n, .2, {
			opacity: 1,
			scale: 1,
			ease: Power1.easeIn
		}), TweenLite.to(t, .3, {
			y: -80,
			scaleY: .92,
			ease: Power1.easeOut,
			delay: .25
		}), TweenLite.to(n, .3, {
			opacity: 0,
			scale: .5,
			ease: Power1.easeOut,
			delay: .25
		}), TweenLite.to(t, .35, {
			y: 260,
			scaleY: 1.7,
			ease: Power2.easeIn,
			delay: .55
		})]), c.add([TweenLite.set(o, {
			rotation: -110,
			x: -64,
			scale: 0
		}), TweenMax.staggerTo(o, 1.4, {
			rotation: 0,
			scale: 1,
			x: 0,
			ease: Elastic.easeOut
		}, .1), TweenLite.set(u, {
			display: "block",
			opacity: 0
		}), TweenLite.to(u, 2, {
			opacity: 1,
			ease: Power2.easeIn,
			delay: 0
		})]);
		var h = function() {
				l.pause(), c.resume()
			},
			p = function(e) {
				TweenLite.to(s, 1, {
					width: Math.round(130 * e)
				})
			};
		return TweenMax.to(a, .5, {
			rotation: "+=360",
			ease: Linear.easeNone,
			repeat: -1
		}), {
			exit: h,
			update: p
		}
	}),
	function() {
		var e = {},
			t = {};
		(function() {
			var e = 1;
			t.create = function(e) {
				var t = {
						id: d.nextId(),
						type: "body",
						label: "Body",
						angle: 0,
						vertices: N.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
						position: {
							x: 0,
							y: 0
						},
						force: {
							x: 0,
							y: 0
						},
						torque: 0,
						positionImpulse: {
							x: 0,
							y: 0
						},
						constraintImpulse: {
							x: 0,
							y: 0,
							angle: 0
						},
						speed: 0,
						angularSpeed: 0,
						velocity: {
							x: 0,
							y: 0
						},
						angularVelocity: 0,
						isStatic: !1,
						isSleeping: !1,
						motion: 0,
						sleepThreshold: 60,
						density: .001,
						restitution: 0,
						friction: .1,
						frictionAir: .01,
						groupId: 0,
						slop: .05,
						timeScale: 1,
						render: {
							visible: !0,
							sprite: {
								xScale: 1,
								yScale: 1
							},
							lineWidth: 1.5
						}
					},
					r = d.extend(t, e);
				return n(r), r
			}, t.nextGroupId = function() {
				return e++
			};
			var n = function(e) {
				e.axes = e.axes || S.fromVertices(e.vertices), e.area = N.area(e.vertices), e.bounds = x.create(e.vertices), e.mass = e.mass || e.density * e.area, e.inverseMass = 1 / e.mass, e.inertia = e.inertia || N.inertia(e.vertices, e.mass), e.inverseInertia = 1 / e.inertia, e.positionPrev = e.positionPrev || {
					x: e.position.x,
					y: e.position.y
				}, e.anglePrev = e.anglePrev || e.angle, e.render.fillStyle = e.render.fillStyle || (e.isStatic ? "#eeeeee" : d.choose(["#556270", "#4ECDC4", "#C7F464", "#FF6B6B", "#C44D58"])), e.render.strokeStyle = e.render.strokeStyle || d.shadeColor(e.render.fillStyle, -20), N.create(e.vertices, e);
				var n = N.centre(e.vertices);
				N.translate(e.vertices, e.position), N.translate(e.vertices, n, -1), N.rotate(e.vertices, e.angle, e.position), S.rotate(e.axes, e.angle), x.update(e.bounds, e.vertices, e.velocity), t.setStatic(e, e.isStatic), b.set(e, e.isSleeping)
			};
			t.setStatic = function(e, t) {
				e.isStatic = t, t && (e.restitution = 0, e.friction = 1, e.mass = e.inertia = e.density = Infinity, e.inverseMass = e.inverseInertia = 0, e.render.lineWidth = 1, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.angularVelocity = 0, e.speed = 0, e.angularSpeed = 0, e.motion = 0)
			}, t.resetForcesAll = function(e) {
				for(var t = 0; t < e.length; t++) {
					var n = e[t];
					n.force.x = 0, n.force.y = 0, n.torque = 0
				}
			}, t.applyGravityAll = function(e, t) {
				for(var n = 0; n < e.length; n++) {
					var r = e[n];
					if(r.isStatic || r.isSleeping) continue;
					r.force.y += r.mass * t.y * .001, r.force.x += r.mass * t.x * .001
				}
			}, t.updateAll = function(e, n, r, i, s) {
				for(var o = 0; o < e.length; o++) {
					var u = e[o];
					if(u.isStatic || u.isSleeping) continue;
					if(u.bounds.max.x < s.min.x || u.bounds.min.x > s.max.x || u.bounds.max.y < s.min.y || u.bounds.min.y > s.max.y) continue;
					t.update(u, n, r, i)
				}
			}, t.update = function(e, t, n, r) {
				var i = Math.pow(t * n * e.timeScale, 2),
					s = 1 - e.frictionAir * n * e.timeScale,
					o = e.position.x - e.positionPrev.x,
					u = e.position.y - e.positionPrev.y;
				e.velocity.x = o * s * r + e.force.x / e.mass * i, e.velocity.y = u * s * r + e.force.y / e.mass * i, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.angularVelocity = (e.angle - e.anglePrev) * s * r + e.torque / e.inertia * i, e.anglePrev = e.angle, e.angle += e.angularVelocity, e.speed = T.magnitude(e.velocity), e.angularSpeed = Math.abs(e.angularVelocity), N.translate(e.vertices, e.velocity), e.angularVelocity !== 0 && (N.rotate(e.vertices, e.angularVelocity, e.position), S.rotate(e.axes, e.angularVelocity)), x.update(e.bounds, e.vertices, e.velocity)
			}, t.applyForce = function(e, t, n) {
				e.force.x += n.x, e.force.y += n.y;
				var r = {
					x: t.x - e.position.x,
					y: t.y - e.position.y
				};
				e.torque += (r.x * n.y - r.y * n.x) * e.inverseInertia
			}, t.translate = function(e, t) {
				e.positionPrev.x += t.x, e.positionPrev.y += t.y, e.position.x += t.x, e.position.y += t.y, N.translate(e.vertices, t), x.update(e.bounds, e.vertices, e.velocity)
			}, t.rotate = function(e, t) {
				e.anglePrev += t, e.angle += t, N.rotate(e.vertices, t, e.position), S.rotate(e.axes, t), x.update(e.bounds, e.vertices, e.velocity)
			}, t.scale = function(e, t, n, r) {
				N.scale(e.vertices, t, n, r), e.axes = S.fromVertices(e.vertices), e.area = N.area(e.vertices), e.mass = e.density * e.area, e.inverseMass = 1 / e.mass, N.translate(e.vertices, {
					x: -e.position.x,
					y: -e.position.y
				}), e.inertia = N.inertia(e.vertices, e.mass), e.inverseInertia = 1 / e.inertia, N.translate(e.vertices, {
					x: e.position.x,
					y: e.position.y
				}), x.update(e.bounds, e.vertices, e.velocity)
			}
		})();
		var n = {};
		(function() {
			n.create = function(e) {
				return d.extend({
					id: d.nextId(),
					type: "composite",
					parent: null,
					isModified: !1,
					bodies: [],
					constraints: [],
					composites: [],
					label: "Composite"
				}, e)
			}, n.setModified = function(e, t, r, i) {
				e.isModified = t, r && e.parent && n.setModified(e.parent, t, r, i);
				if(i)
					for(var s = 0; s < e.composites.length; s++) {
						var o = e.composites[s];
						n.setModified(o, t, r, i)
					}
			}, n.add = function(e, t) {
				var r = [].concat(t);
				for(var i = 0; i < r.length; i++) {
					var s = r[i];
					switch(s.type) {
						case "body":
							n.addBody(e, s);
							break;
						case "constraint":
							n.addConstraint(e, s);
							break;
						case "composite":
							n.addComposite(e, s);
							break;
						case "mouseConstraint":
							n.addConstraint(e, s.constraint)
					}
				}
				return e
			}, n.remove = function(e, t, r) {
				var i = [].concat(t);
				for(var s = 0; s < i.length; s++) {
					var o = i[s];
					switch(o.type) {
						case "body":
							n.removeBody(e, o, r);
							break;
						case "constraint":
							n.removeConstraint(e, o, r);
							break;
						case "composite":
							n.removeComposite(e, o, r);
							break;
						case "mouseConstraint":
							n.removeConstraint(e, o.constraint)
					}
				}
				return e
			}, n.addComposite = function(e, t) {
				return e.composites.push(t), t.parent = e, n.setModified(e, !0, !0, !1), e
			}, n.removeComposite = function(e, t, r) {
				var i = e.composites.indexOf(t);
				i !== -1 && (n.removeCompositeAt(e, i), n.setModified(e, !0, !0, !1));
				if(r)
					for(var s = 0; s < e.composites.length; s++) n.removeComposite(e.composites[s], t, !0);
				return e
			}, n.removeCompositeAt = function(e, t) {
				return e.composites.splice(t, 1), n.setModified(e, !0, !0, !1), e
			}, n.addBody = function(e, t) {
				return e.bodies.push(t), n.setModified(e, !0, !0, !1), e
			}, n.removeBody = function(e, t, r) {
				var i = e.bodies.indexOf(t);
				i !== -1 && (n.removeBodyAt(e, i), n.setModified(e, !0, !0, !1));
				if(r)
					for(var s = 0; s < e.composites.length; s++) n.removeBody(e.composites[s], t, !0);
				return e
			}, n.removeBodyAt = function(e, t) {
				return e.bodies.splice(t, 1), n.setModified(e, !0, !0, !1), e
			}, n.addConstraint = function(e, t) {
				return e.constraints.push(t), n.setModified(e, !0, !0, !1), e
			}, n.removeConstraint = function(e, t, r) {
				var i = e.constraints.indexOf(t);
				i !== -1 && n.removeConstraintAt(e, i);
				if(r)
					for(var s = 0; s < e.composites.length; s++) n.removeConstraint(e.composites[s], t, !0);
				return e
			}, n.removeConstraintAt = function(e, t) {
				return e.constraints.splice(t, 1), n.setModified(e, !0, !0, !1), e
			}, n.clear = function(e, t, r) {
				if(r)
					for(var i = 0; i < e.composites.length; i++) n.clear(e.composites[i], t, !0);
				return t ? e.bodies = e.bodies.filter(function(e) {
					return e.isStatic
				}) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, n.setModified(e, !0, !0, !1), e
			}, n.allBodies = function(e) {
				var t = [].concat(e.bodies);
				for(var r = 0; r < e.composites.length; r++) t = t.concat(n.allBodies(e.composites[r]));
				return t
			}, n.allConstraints = function(e) {
				var t = [].concat(e.constraints);
				for(var r = 0; r < e.composites.length; r++) t = t.concat(n.allConstraints(e.composites[r]));
				return t
			}, n.allComposites = function(e) {
				var t = [].concat(e.composites);
				for(var r = 0; r < e.composites.length; r++) t = t.concat(n.allComposites(e.composites[r]));
				return t
			}, n.get = function(e, t, r) {
				var i, s;
				switch(r) {
					case "body":
						i = n.allBodies(e);
						break;
					case "constraint":
						i = n.allConstraints(e);
						break;
					case "composite":
						i = n.allComposites(e).concat(e)
				}
				return i ? (s = i.filter(function(e) {
					return e.id.toString() === t.toString()
				}), s.length === 0 ? null : s[0]) : null
			}, n.move = function(e, t, r) {
				return n.remove(e, t), n.add(r, t), e
			}, n.rebase = function(e) {
				var t = n.allBodies(e).concat(n.allConstraints(e)).concat(n.allComposites(e));
				for(var r = 0; r < t.length; r++) t[r].id = d.nextId();
				return n.setModified(e, !0, !0, !1), e
			}
		})();
		var r = {};
		(function() {
			r.create = function(e) {
				var t = n.create(),
					r = {
						label: "World",
						gravity: {
							x: 0,
							y: 1
						},
						bounds: {
							min: {
								x: 0,
								y: 0
							},
							max: {
								x: 800,
								y: 600
							}
						}
					};
				return d.extend(t, r, e)
			}
		})();
		var i = {};
		(function() {
			i.create = function(e) {
				return {
					id: i.id(e),
					vertex: e,
					normalImpulse: 0,
					tangentImpulse: 0
				}
			}, i.id = function(e) {
				return e.body.id + "_" + e.index
			}
		})();
		var s = {};
		(function() {
			s.collisions = function(e, t) {
				var n = [],
					r = t.metrics,
					i = t.pairs.table;
				for(var s = 0; s < e.length; s++) {
					var o = e[s][0],
						a = e[s][1];
					if(o.groupId && a.groupId && o.groupId === a.groupId) continue;
					if((o.isStatic || o.isSleeping) && (a.isStatic || a.isSleeping)) continue;
					r.midphaseTests += 1;
					if(x.overlaps(o.bounds, a.bounds)) {
						var f = u.id(o, a),
							l = i[f],
							h;
						l && l.isActive ? h = l.collision : h = null;
						var p = c.collides(o, a, h);
						r.narrowphaseTests += 1, p.reused && (r.narrowReuseCount += 1), p.collided && (n.push(p), r.narrowDetections += 1)
					}
				}
				return n
			}, s.bruteForce = function(e, t) {
				var n = [],
					r = t.metrics,
					i = t.pairs.table;
				for(var s = 0; s < e.length; s++)
					for(var o = s + 1; o < e.length; o++) {
						var a = e[s],
							f = e[o];
						if(a.groupId && f.groupId && a.groupId === f.groupId) continue;
						if((a.isStatic || a.isSleeping) && (f.isStatic || f.isSleeping)) continue;
						r.midphaseTests += 1;
						if(x.overlaps(a.bounds, f.bounds)) {
							var l = u.id(a, f),
								h = i[l],
								p;
							h && h.isActive ? p = h.collision : p = null;
							var d = c.collides(a, f, p);
							r.narrowphaseTests += 1, d.reused && (r.narrowReuseCount += 1), d.collided && (n.push(d), r.narrowDetections += 1)
						}
					}
				return n
			}
		})();
		var o = {};
		(function() {
			o.create = function(e, t) {
				return {
					buckets: {},
					pairs: {},
					pairsList: [],
					bucketWidth: e || 48,
					bucketHeight: t || 48
				}
			}, o.update = function(n, o, u, l) {
				var c, h, p, d = u.world,
					v = n.buckets,
					m, g, y = u.metrics,
					b = !1;
				y.broadphaseTests = 0;
				for(c = 0; c < o.length; c++) {
					var w = o[c];
					if(w.isSleeping && !l) continue;
					if(w.bounds.max.x < 0 || w.bounds.min.x > d.bounds.width || w.bounds.max.y < 0 || w.bounds.min.y > d.bounds.height) continue;
					var E = t(n, w);
					if(!w.region || E.id !== w.region.id || l) {
						y.broadphaseTests += 1;
						if(!w.region || l) w.region = E;
						var S = e(E, w.region);
						for(h = S.startCol; h <= S.endCol; h++)
							for(p = S.startRow; p <= S.endRow; p++) {
								g = r(h, p), m = v[g];
								var x = h >= E.startCol && h <= E.endCol && p >= E.startRow && p <= E.endRow,
									T = h >= w.region.startCol && h <= w.region.endCol && p >= w.region.startRow && p <= w.region.endRow;
								!x && T && T && m && a(n, m, w);
								if(w.region === E || x && !T || l) m || (m = i(v, g)), s(n, m, w)
							}
						w.region = E, b = !0
					}
				}
				b && (n.pairsList = f(n))
			}, o.clear = function(e) {
				e.buckets = {}, e.pairs = {}, e.pairsList = []
			};
			var e = function(e, t) {
					var r = Math.min(e.startCol, t.startCol),
						i = Math.max(e.endCol, t.endCol),
						s = Math.min(e.startRow, t.startRow),
						o = Math.max(e.endRow, t.endRow);
					return n(r, i, s, o)
				},
				t = function(e, t) {
					var r = t.bounds,
						i = Math.floor(r.min.x / e.bucketWidth),
						s = Math.floor(r.max.x / e.bucketWidth),
						o = Math.floor(r.min.y / e.bucketHeight),
						u = Math.floor(r.max.y / e.bucketHeight);
					return n(i, s, o, u)
				},
				n = function(e, t, n, r) {
					return {
						id: e + "," + t + "," + n + "," + r,
						startCol: e,
						endCol: t,
						startRow: n,
						endRow: r
					}
				},
				r = function(e, t) {
					return e + "," + t
				},
				i = function(e, t) {
					var n = e[t] = [];
					return n
				},
				s = function(e, t, n) {
					for(var r = 0; r < t.length; r++) {
						var i = t[r];
						if(n.id === i.id || n.isStatic && i.isStatic) continue;
						var s = u.id(n, i),
							o = e.pairs[s];
						o ? o[2] += 1 : e.pairs[s] = [n, i, 1]
					}
					t.push(n)
				},
				a = function(e, t, n) {
					t.splice(t.indexOf(n), 1);
					for(var r = 0; r < t.length; r++) {
						var i = t[r],
							s = u.id(n, i),
							o = e.pairs[s];
						o && (o[2] -= 1)
					}
				},
				f = function(e) {
					var t, n, r = [];
					t = d.keys(e.pairs);
					for(var i = 0; i < t.length; i++) n = e.pairs[t[i]], n[2] > 0 ? r.push(n) : delete e.pairs[t[i]];
					return r
				}
		})();
		var u = {};
		(function() {
			u.create = function(e, t) {
				var n = e.bodyA,
					r = e.bodyB,
					i = {
						id: u.id(n, r),
						bodyA: n,
						bodyB: r,
						contacts: {},
						activeContacts: [],
						separation: 0,
						isActive: !0,
						timeCreated: t,
						timeUpdated: t,
						inverseMass: n.inverseMass + r.inverseMass,
						friction: Math.min(n.friction, r.friction),
						restitution: Math.max(n.restitution, r.restitution),
						slop: Math.max(n.slop, r.slop)
					};
				return u.update(i, e, t), i
			}, u.update = function(e, t, n) {
				var r = e.contacts,
					s = t.supports,
					o = e.activeContacts;
				e.collision = t, o.length = 0;
				if(t.collided) {
					for(var a = 0; a < s.length; a++) {
						var f = s[a],
							l = i.id(f),
							c = r[l];
						c ? o.push(c) : o.push(r[l] = i.create(f))
					}
					e.separation = t.depth, u.setActive(e, !0, n)
				} else e.isActive === !0 && u.setActive(e, !1, n)
			}, u.setActive = function(e, t, n) {
				t ? (e.isActive = !0, e.timeUpdated = n) : (e.isActive = !1, e.activeContacts.length = 0)
			}, u.id = function(e, t) {
				return e.id < t.id ? e.id + "_" + t.id : t.id + "_" + e.id
			}
		})();
		var a = {};
		(function() {
			var e = 1e3;
			a.create = function(e) {
				return d.extend({
					table: {},
					list: [],
					collisionStart: [],
					collisionActive: [],
					collisionEnd: []
				}, e)
			}, a.update = function(e, t, n) {
				var r = e.list,
					i = e.table,
					s = e.collisionStart,
					o = e.collisionEnd,
					a = e.collisionActive,
					f = [],
					l, c, h, p;
				s.length = 0, o.length = 0, a.length = 0;
				for(p = 0; p < t.length; p++) l = t[p], l.collided && (c = u.id(l.bodyA, l.bodyB), f.push(c), h = i[c], h ? (h.isActive ? a.push(h) : s.push(h), u.update(h, l, n)) : (h = u.create(l, n), i[c] = h, s.push(h), r.push(h)));
				for(p = 0; p < r.length; p++) h = r[p], h.isActive && f.indexOf(h.id) === -1 && (u.setActive(h, !1, n), o.push(h))
			}, a.removeOld = function(t, n) {
				var r = t.list,
					i = t.table,
					s = [],
					o, u, a, f;
				for(f = 0; f < r.length; f++) {
					o = r[f], u = o.collision;
					if(u.bodyA.isSleeping || u.bodyB.isSleeping) {
						o.timeUpdated = n;
						continue
					}
					n - o.timeUpdated > e && s.push(f)
				}
				for(f = 0; f < s.length; f++) a = s[f] - f, o = r[a], delete i[o.id], r.splice(a, 1)
			}, a.clear = function(e) {
				return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e
			}
		})();
		var f = {};
		(function() {
			f.ray = function(e, t, n, r) {
				r = r || Number.MIN_VALUE;
				var i = T.angle(t, n),
					s = T.magnitude(T.sub(t, n)),
					o = (n.x + t.x) * .5,
					u = (n.y + t.y) * .5,
					a = w.rectangle(o, u, s, r, {
						angle: i
					}),
					f = [];
				for(var l = 0; l < e.length; l++) {
					var h = e[l];
					if(x.overlaps(h.bounds, a.bounds)) {
						var p = c.collides(h, a);
						p.collided && (p.body = p.bodyA = p.bodyB = h, f.push(p))
					}
				}
				return f
			}, f.region = function(e, t, n) {
				var r = [];
				for(var i = 0; i < e.length; i++) {
					var s = e[i],
						o = x.overlaps(s.bounds, t);
					(o && !n || !o && n) && r.push(s)
				}
				return r
			}
		})();
		var l = {};
		(function() {
			var e = 4,
				t = .2,
				n = .6;
			l.solvePosition = function(e, n) {
				var r, i, s, o, u, a, f, l, c;
				for(r = 0; r < e.length; r++) {
					i = e[r];
					if(!i.isActive) continue;
					s = i.collision, o = s.bodyA, u = s.bodyB, a = s.supports[0], f = s.supportCorrected, l = s.normal, c = T.sub(T.add(u.positionImpulse, a), T.add(o.positionImpulse, f)), i.separation = T.dot(l, c)
				}
				for(r = 0; r < e.length; r++) {
					i = e[r];
					if(!i.isActive) continue;
					s = i.collision, o = s.bodyA, u = s.bodyB, l = s.normal, positionImpulse = (i.separation * t - i.slop) * n;
					if(o.isStatic || u.isStatic) positionImpulse *= 2;
					!o.isStatic && !o.isSleeping && (o.positionImpulse.x += l.x * positionImpulse, o.positionImpulse.y += l.y * positionImpulse), !u.isStatic && !u.isSleeping && (u.positionImpulse.x -= l.x * positionImpulse, u.positionImpulse.y -= l.y * positionImpulse)
				}
			}, l.postSolvePosition = function(e) {
				for(var t = 0; t < e.length; t++) {
					var r = e[t];
					if(r.positionImpulse.x !== 0 || r.positionImpulse.y !== 0) r.position.x += r.positionImpulse.x, r.position.y += r.positionImpulse.y, r.positionPrev.x += r.positionImpulse.x, r.positionPrev.y += r.positionImpulse.y, N.translate(r.vertices, r.positionImpulse), x.update(r.bounds, r.vertices, r.velocity), r.positionImpulse.x *= n, r.positionImpulse.y *= n
				}
			}, l.preSolveVelocity = function(e) {
				var t = {},
					n, r, i, s, o, u, a, f, l, c, h, p, d, v;
				for(n = 0; n < e.length; n++) {
					i = e[n];
					if(!i.isActive) continue;
					s = i.activeContacts, o = i.collision, u = o.bodyA, a = o.bodyB, f = o.normal, l = o.tangent;
					for(r = 0; r < s.length; r++) c = s[r], h = c.vertex, p = c.normalImpulse, d = c.tangentImpulse, t.x = f.x * p + l.x * d, t.y = f.y * p + l.y * d, !u.isStatic && !u.isSleeping && (v = T.sub(h, u.position), u.positionPrev.x += t.x * u.inverseMass, u.positionPrev.y += t.y * u.inverseMass, u.anglePrev += T.cross(v, t) * u.inverseInertia), !a.isStatic && !a.isSleeping && (v = T.sub(h, a.position), a.positionPrev.x -= t.x * a.inverseMass, a.positionPrev.y -= t.y * a.inverseMass, a.anglePrev -= T.cross(v, t) * a.inverseInertia)
				}
			}, l.solveVelocity = function(t, n) {
				var r = {},
					i = n * n;
				for(var s = 0; s < t.length; s++) {
					var o = t[s];
					if(!o.isActive) continue;
					var u = o.collision,
						a = u.bodyA,
						f = u.bodyB,
						l = u.normal,
						c = u.tangent,
						h = o.activeContacts,
						p = 1 / h.length;
					a.velocity.x = a.position.x - a.positionPrev.x, a.velocity.y = a.position.y - a.positionPrev.y, f.velocity.x = f.position.x - f.positionPrev.x, f.velocity.y = f.position.y - f.positionPrev.y, a.angularVelocity = a.angle - a.anglePrev, f.angularVelocity = f.angle - f.anglePrev;
					for(var v = 0; v < h.length; v++) {
						var m = h[v],
							g = m.vertex,
							y = T.sub(g, a.position),
							b = T.sub(g, f.position),
							w = T.add(a.velocity, T.mult(T.perp(y), a.angularVelocity)),
							E = T.add(f.velocity, T.mult(T.perp(b), f.angularVelocity)),
							S = T.sub(w, E),
							x = T.dot(l, S),
							N = T.dot(c, S),
							C = Math.abs(N),
							k = d.sign(N),
							L = (1 + o.restitution) * x,
							A = d.clamp(o.separation + x, 0, 1),
							O = N;
						C > A * o.friction * i && (O = A * o.friction * i * k);
						var M = T.cross(y, l),
							_ = T.cross(b, l),
							D = p / (o.inverseMass + a.inverseInertia * M * M + f.inverseInertia * _ * _);
						L *= D, O *= D;
						if(x < 0 && x * x > e * i) m.normalImpulse = 0, m.tangentImpulse = 0;
						else {
							var P = m.normalImpulse;
							m.normalImpulse = Math.min(m.normalImpulse + L, 0), L = m.normalImpulse - P;
							var H = m.tangentImpulse;
							m.tangentImpulse = d.clamp(m.tangentImpulse + O, -C, C), O = m.tangentImpulse - H
						}
						r.x = l.x * L + c.x * O, r.y = l.y * L + c.y * O, !a.isStatic && !a.isSleeping && (a.positionPrev.x += r.x * a.inverseMass, a.positionPrev.y += r.y * a.inverseMass, a.anglePrev += T.cross(y, r) * a.inverseInertia), !f.isStatic && !f.isSleeping && (f.positionPrev.x -= r.x * f.inverseMass, f.positionPrev.y -= r.y * f.inverseMass, f.anglePrev -= T.cross(b, r) * f.inverseInertia)
					}
				}
			}
		})();
		var c = {};
		(function() {
			c.collides = function(t, r, i) {
				var s, o, u, a, f = i,
					l = !1;
				if(f) {
					var c = t.speed * t.speed + t.angularSpeed * t.angularSpeed + r.speed * r.speed + r.angularSpeed * r.angularSpeed;
					l = f && f.collided && c < .2, a = f
				} else a = {
					collided: !1,
					bodyA: t,
					bodyB: r
				};
				if(f && l) {
					var h = [f.bodyA.axes[f.axisNumber]];
					u = e(f.bodyA.vertices, f.bodyB.vertices, h), a.reused = !0;
					if(u.overlap <= 0) return a.collided = !1, a
				} else {
					s = e(t.vertices, r.vertices, t.axes);
					if(s.overlap <= 0) return a.collided = !1, a;
					o = e(r.vertices, t.vertices, r.axes);
					if(o.overlap <= 0) return a.collided = !1, a;
					s.overlap < o.overlap ? (u = s, a.bodyA = t, a.bodyB = r) : (u = o, a.bodyA = r, a.bodyB = t), a.axisNumber = u.axisNumber
				}
				a.collided = !0, a.normal = u.axis, a.depth = u.overlap, t = a.bodyA, r = a.bodyB, T.dot(a.normal, T.sub(r.position, t.position)) > 0 && (a.normal = T.neg(a.normal)), a.tangent = T.perp(a.normal), a.penetration = {
					x: a.normal.x * a.depth,
					y: a.normal.y * a.depth
				};
				var p = n(t, r, a.normal),
					d = [p[0]];
				if(N.contains(t.vertices, p[1])) d.push(p[1]);
				else {
					var v = n(r, t, T.neg(a.normal));
					N.contains(r.vertices, v[0]) && d.push(v[0]), d.length < 2 && N.contains(r.vertices, v[1]) && d.push(v[1])
				}
				return a.supports = d, a.supportCorrected = T.sub(p[0], a.penetration), a
			};
			var e = function(e, n, r) {
					var i = {},
						s = {},
						o = {
							overlap: Number.MAX_VALUE
						},
						u, a;
					for(var f = 0; f < r.length; f++) {
						a = r[f], t(i, e, a), t(s, n, a), u = i.min < s.min ? i.max - s.min : s.max - i.min;
						if(u <= 0) return o.overlap = u, o;
						u < o.overlap && (o.overlap = u, o.axis = a, o.axisNumber = f)
					}
					return o
				},
				t = function(e, t, n) {
					var r = T.dot(t[0], n),
						i = r;
					for(var s = 1; s < t.length; s += 1) {
						var o = T.dot(t[s], n);
						o > i ? i = o : o < r && (r = o)
					}
					e.min = r, e.max = i
				},
				n = function(e, t, n) {
					var r = Number.MAX_VALUE,
						i = {
							x: 0,
							y: 0
						},
						s = t.vertices,
						o = e.position,
						u, a, f = s[0],
						l = s[1];
					for(var c = 0; c < s.length; c++) a = s[c], i.x = a.x - o.x, i.y = a.y - o.y, u = -T.dot(n, i), u < r && (r = u, f = a);
					var h = f.index - 1 >= 0 ? f.index - 1 : s.length - 1;
					a = s[h], i.x = a.x - o.x, i.y = a.y - o.y, r = -T.dot(n, i), l = a;
					var p = (f.index + 1) % s.length;
					return a = s[p], i.x = a.x - o.x, i.y = a.y - o.y, u = -T.dot(n, i), u < r && (r = u, l = a), [f, l]
				}
		})();
		var h = {};
		(function() {
			var e = 1e-6,
				t = .001;
			h.create = function(t) {
				var n = t;
				n.bodyA && !n.pointA && (n.pointA = {
					x: 0,
					y: 0
				}), n.bodyB && !n.pointB && (n.pointB = {
					x: 0,
					y: 0
				});
				var r = n.bodyA ? T.add(n.bodyA.position, n.pointA) : n.pointA,
					i = n.bodyB ? T.add(n.bodyB.position, n.pointB) : n.pointB,
					s = T.magnitude(T.sub(r, i));
				n.length = n.length || s || e;
				var o = {
					visible: !0,
					lineWidth: 2,
					strokeStyle: "#666"
				};
				return n.render = d.extend(o, n.render), n.id = n.id || d.nextId(), n.label = n.label || "Constraint", n.type = "constraint", n.stiffness = n.stiffness || 1, n.angularStiffness = n.angularStiffness || 0, n.angleA = n.bodyA ? n.bodyA.angle : n.angleA, n.angleB = n.bodyB ? n.bodyB.angle : n.angleB, n
			}, h.solveAll = function(e, t) {
				for(var n = 0; n < e.length; n++) h.solve(e[n], t)
			}, h.solve = function(n, r) {
				var i = n.bodyA,
					s = n.bodyB,
					o = n.pointA,
					u = n.pointB;
				i && !i.isStatic && (n.pointA = T.rotate(o, i.angle - n.angleA), n.angleA = i.angle), s && !s.isStatic && (n.pointB = T.rotate(u, s.angle - n.angleB), n.angleB = s.angle);
				var a = o,
					f = u;
				i && (a = T.add(i.position, o)), s && (f = T.add(s.position, u));
				if(!a || !f) return;
				var l = T.sub(a, f),
					c = T.magnitude(l);
				c === 0 && (c = e);
				var h = (c - n.length) / c,
					p = T.div(l, c),
					v = T.mult(l, h * .5 * n.stiffness * r * r);
				if(Math.abs(1 - c / n.length) < t * r) return;
				var m, g, y, w, E, S, x, N;
				i && !i.isStatic ? (y = {
					x: a.x - i.position.x + v.x,
					y: a.y - i.position.y + v.y
				}, i.velocity.x = i.position.x - i.positionPrev.x, i.velocity.y = i.position.y - i.positionPrev.y, i.angularVelocity = i.angle - i.anglePrev, m = T.add(i.velocity, T.mult(T.perp(y), i.angularVelocity)), E = T.dot(y, p), x = i.inverseMass + i.inverseInertia * E * E) : (m = {
					x: 0,
					y: 0
				}, x = i ? i.inverseMass : 0), s && !s.isStatic ? (w = {
					x: f.x - s.position.x - v.x,
					y: f.y - s.position.y - v.y
				}, s.velocity.x = s.position.x - s.positionPrev.x, s.velocity.y = s.position.y - s.positionPrev.y, s.angularVelocity = s.angle - s.anglePrev, g = T.add(s.velocity, T.mult(T.perp(w), s.angularVelocity)), S = T.dot(w, p), N = s.inverseMass + s.inverseInertia * S * S) : (g = {
					x: 0,
					y: 0
				}, N = s ? s.inverseMass : 0);
				var C = T.sub(g, m),
					k = T.dot(p, C) / (x + N);
				k > 0 && (k = 0);
				var L = {
						x: p.x * k,
						y: p.y * k
					},
					A;
				i && !i.isStatic && (A = T.cross(y, L) * i.inverseInertia * (1 - n.angularStiffness), b.set(i, !1), A = d.clamp(A, -0.01, .01), i.constraintImpulse.x -= v.x, i.constraintImpulse.y -= v.y, i.constraintImpulse.angle += A, i.position.x -= v.x, i.position.y -= v.y, i.angle += A), s && !s.isStatic && (A = T.cross(w, L) * s.inverseInertia * (1 - n.angularStiffness), b.set(s, !1), A = d.clamp(A, -0.01, .01), s.constraintImpulse.x += v.x, s.constraintImpulse.y += v.y, s.constraintImpulse.angle -= A, s.position.x += v.x, s.position.y += v.y, s.angle -= A)
			}, h.postSolveAll = function(e) {
				for(var t = 0; t < e.length; t++) {
					var n = e[t],
						r = n.constraintImpulse;
					N.translate(n.vertices, r), r.angle !== 0 && (N.rotate(n.vertices, r.angle, n.position), S.rotate(n.axes, r.angle), r.angle = 0), x.update(n.bounds, n.vertices), r.x = 0, r.y = 0
				}
			}
		})();
		var p = {};
		(function() {
			p.create = function(e, t) {
				var r = e.input.mouse,
					i = h.create({
						label: "Mouse Constraint",
						pointA: r.position,
						pointB: {
							x: 0,
							y: 0
						},
						length: .01,
						stiffness: .1,
						angularStiffness: 1,
						render: {
							strokeStyle: "#90EE90",
							lineWidth: 3
						}
					}),
					s = {
						type: "mouseConstraint",
						mouse: r,
						dragBody: null,
						dragPoint: null,
						constraint: i
					},
					o = d.extend(s, t);
				return m.on(e, "tick", function(t) {
					var r = n.allBodies(e.world);
					p.update(o, r)
				}), o
			}, p.update = function(e, t) {
				var n = e.mouse,
					r = e.constraint;
				if(n.button === 0) {
					if(!r.bodyB)
						for(var i = 0; i < t.length; i++) {
							var s = t[i];
							x.contains(s.bounds, n.position) && N.contains(s.vertices, n.position) && (r.pointA = n.position, r.bodyB = s, r.pointB = {
								x: n.position.x - s.position.x,
								y: n.position.y - s.position.y
							}, r.angleB = s.angle, b.set(s, !1))
						}
				} else r.bodyB = null, r.pointB = null;
				r.bodyB && (b.set(r.bodyB, !1), r.pointA = n.position)
			}
		})();
		var d = {};
		(function() {
			d._nextId = 0, d.extend = function(e, t) {
				var n, r, i;
				typeof t == "boolean" ? (n = 2, i = t) : (n = 1, i = !0), r = Array.prototype.slice.call(arguments, n);
				for(var s = 0; s < r.length; s++) {
					var o = r[s];
					if(o)
						for(var u in o) i && o[u] && o[u].constructor === Object ? !e[u] || e[u].constructor === Object ? (e[u] = e[u] || {}, d.extend(e[u], i, o[u])) : e[u] = o[u] : e[u] = o[u]
				}
				return e
			}, d.clone = function(e, t) {
				return d.extend({}, t, e)
			}, d.keys = function(e) {
				if(Object.keys) return Object.keys(e);
				var t = [];
				for(var n in e) t.push(n);
				return t
			}, d.values = function(e) {
				var t = [];
				if(Object.keys) {
					var n = Object.keys(e);
					for(var r = 0; r < n.length; r++) t.push(e[n[r]]);
					return t
				}
				for(var i in e) t.push(e[i]);
				return t
			}, d.shadeColor = function(e, t) {
				var n = parseInt(e.slice(1), 16),
					r = Math.round(2.55 * t),
					i = (n >> 16) + r,
					s = (n >> 8 & 255) + r,
					o = (n & 255) + r;
				return "#" + (16777216 + (i < 255 ? i < 1 ? 0 : i : 255) * 65536 + (s < 255 ? s < 1 ? 0 : s : 255) * 256 + (o < 255 ? o < 1 ? 0 : o : 255)).toString(16).slice(1)
			}, d.shuffle = function(e) {
				for(var t = e.length - 1; t > 0; t--) {
					var n = Math.floor(Math.random() * (t + 1)),
						r = e[t];
					e[t] = e[n], e[n] = r
				}
				return e
			}, d.choose = function(e) {
				return e[Math.floor(Math.random() * e.length)]
			}, d.isElement = function(e) {
				try {
					return e instanceof HTMLElement
				} catch(t) {
					return typeof e == "object" && e.nodeType === 1 && typeof e.style == "object" && typeof e.ownerDocument == "object"
				}
			}, d.clamp = function(e, t, n) {
				return e < t ? t : e > n ? n : e
			}, d.sign = function(e) {
				return e < 0 ? -1 : 1
			}, d.now = function() {
				var e = window.performance;
				return e ? (e.now = e.now || e.webkitNow || e.msNow || e.oNow || e.mozNow, +e.now()) : +(new Date)
			}, d.random = function(e, t) {
				return e + Math.random() * (t - e)
			}, d.colorToNumber = function(e) {
				return e = e.replace("#", ""), e.length == 3 && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16)
			}, d.log = function(e, t) {
				if(!console || !console.log) return;
				var n;
				switch(t) {
					case "warn":
						n = "color: coral";
						break;
					case "error":
						n = "color: red"
				}
				console.log("%c [Matter] " + t + ": " + e, n)
			}, d.nextId = function() {
				return d._nextId++
			}
		})();
		var v = {};
		(function() {
			var e = 60,
				i = e,
				u = 1e3 / e,
				f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(e) {
					window.setTimeout(function() {
						e(d.now())
					}, u)
				};
			v.create = function(t, n) {
				n = d.isElement(t) ? n : t, t = d.isElement(t) ? t : null;
				var i = {
						enabled: !0,
						positionIterations: 6,
						velocityIterations: 4,
						constraintIterations: 2,
						enableSleeping: !1,
						timeScale: 1,
						input: {},
						events: [],
						timing: {
							fps: e,
							timestamp: 0,
							delta: u,
							correction: 1,
							deltaMin: 1e3 / e,
							deltaMax: 1e3 / (e * .5),
							timeScale: 1,
							isFixed: !1
						},
						render: {
							element: t,
							controller: C
						}
					},
					f = d.extend(i, n);
				return f.render = f.render.controller.create(f.render), f.world = r.create(f.world), f.pairs = a.create(), f.metrics = f.metrics || g.create(), f.input.mouse = f.input.mouse || y.create(f.render.canvas), f.broadphase = f.broadphase || {
					current: "grid",
					grid: {
						controller: o,
						instance: o.create(),
						detector: s.collisions
					},
					bruteForce: {
						detector: s.bruteForce
					}
				}, f
			}, v.run = function(e) {
				var t = 0,
					n = 0,
					r = [],
					s, o = 1;
				(function u(a) {
					f(u);
					if(!e.enabled) return;
					var l = e.timing,
						h, d, g = {
							timestamp: a
						};
					m.trigger(e, "beforeTick", g), l.isFixed ? h = l.delta : (h = a - s || l.delta, s = a, r.push(h), r = r.slice(-i), h = Math.min.apply(null, r), h = h < l.deltaMin ? l.deltaMin : h, h = h > l.deltaMax ? l.deltaMax : h, d = h / l.delta, l.delta = h), o !== 0 && (d *= l.timeScale / o), l.timeScale === 0 && (d = 0), o = l.timeScale, n += 1, a - t >= 1e3 && (l.fps = n * ((a - t) / 1e3), t = a, n = 0), m.trigger(e, "tick", g), e.world.isModified && e.render.controller.clear(e.render), v.update(e, h, d), p(e), c(e), v.render(e), m.trigger(e, "afterTick", g)
				})()
			}, v.update = function(e, r, i) {
				i = typeof i != "undefined" ? i : 1;
				var s = e.world,
					o = e.timing,
					u = e.broadphase[e.broadphase.current],
					f = [],
					c;
				o.timestamp += r * o.timeScale, o.correction = i;
				var p = {
					timestamp: e.timing.timestamp
				};
				m.trigger(e, "beforeUpdate", p);
				var d = n.allBodies(s),
					v = n.allConstraints(s);
				g.reset(e.metrics), e.enableSleeping && b.update(d), t.applyGravityAll(d, s.gravity), t.updateAll(d, r, o.timeScale, i, s.bounds);
				for(c = 0; c < e.constraintIterations; c++) h.solveAll(v, o.timeScale);
				h.postSolveAll(d), u.controller ? (s.isModified && u.controller.clear(u.instance), u.controller.update(u.instance, d, e, s.isModified), f = u.instance.pairsList) : f = d;
				var y = u.detector(f, e),
					w = e.pairs,
					E = o.timestamp;
				a.update(w, y, E), a.removeOld(w, E), e.enableSleeping && b.afterCollisions(w.list), l.preSolveVelocity(w.list);
				for(c = 0; c < e.velocityIterations; c++) l.solveVelocity(w.list, o.timeScale);
				for(c = 0; c < e.positionIterations; c++) l.solvePosition(w.list, o.timeScale);
				return l.postSolvePosition(d), g.update(e.metrics, e), t.resetForcesAll(d), s.isModified && n.setModified(s, !1, !1, !0), m.trigger(e, "afterUpdate", p), e
			}, v.render = function(e) {
				var t = {
					timestamp: e.timing.timestamp
				};
				m.trigger(e, "beforeRender", t), e.render.controller.world(e), m.trigger(e, "afterRender", t)
			}, v.merge = function(e, t) {
				d.extend(e, t);
				if(t.world) {
					e.world = t.world, v.clear(e);
					var r = n.allBodies(e.world);
					for(var i = 0; i < r.length; i++) {
						var s = r[i];
						b.set(s, !1), s.id = d.nextId()
					}
				}
			}, v.clear = function(e) {
				var t = e.world;
				a.clear(e.pairs);
				var r = e.broadphase[e.broadphase.current];
				if(r.controller) {
					var i = n.allBodies(t);
					r.controller.clear(r.instance), r.controller.update(r.instance, i, e, !0)
				}
			};
			var c = function(e) {
					var t = e.input.mouse,
						n = t.sourceEvents;
					n.mousemove && m.trigger(e, "mousemove", {
						mouse: t
					}), n.mousedown && m.trigger(e, "mousedown", {
						mouse: t
					}), n.mouseup && m.trigger(e, "mouseup", {
						mouse: t
					}), y.clearSourceEvents(t)
				},
				p = function(e) {
					var t = e.pairs;
					t.collisionStart.length > 0 && m.trigger(e, "collisionStart", {
						pairs: t.collisionStart
					}), t.collisionActive.length > 0 && m.trigger(e, "collisionActive", {
						pairs: t.collisionActive
					}), t.collisionEnd.length > 0 && m.trigger(e, "collisionEnd", {
						pairs: t.collisionEnd
					})
				}
		})();
		var m = {};
		(function() {
			m.on = function(e, t, n) {
				var r = t.split(" "),
					i;
				for(var s = 0; s < r.length; s++) i = r[s], e.events = e.events || {}, e.events[i] = e.events[i] || [], e.events[i].push(n);
				return n
			}, m.off = function(e, t, n) {
				if(!t) {
					e.events = {};
					return
				}
				typeof t == "function" && (n = t, t = d.keys(e.events).join(" "));
				var r = t.split(" ");
				for(var i = 0; i < r.length; i++) {
					var s = e.events[r[i]],
						o = [];
					if(n)
						for(var u = 0; u < s.length; u++) s[u] !== n && o.push(s[u]);
					e.events[r[i]] = o
				}
			}, m.trigger = function(e, t, n) {
				var r, i, s, o;
				if(e.events) {
					n || (n = {}), r = t.split(" ");
					for(var u = 0; u < r.length; u++) {
						i = r[u], s = e.events[i];
						if(s) {
							o = d.clone(n, !1), o.name = i, o.source = e;
							for(var a = 0; a < s.length; a++) s[a].apply(e, [o])
						}
					}
				}
			}
		})();
		var g = {};
		(function() {
			g.create = function() {
				return {
					extended: !1,
					narrowDetections: 0,
					narrowphaseTests: 0,
					narrowReuse: 0,
					narrowReuseCount: 0,
					midphaseTests: 0,
					broadphaseTests: 0,
					narrowEff: 1e-4,
					midEff: 1e-4,
					broadEff: 1e-4,
					collisions: 0,
					buckets: 0,
					bodies: 0,
					pairs: 0
				}
			}, g.reset = function(e) {
				e.extended && (e.narrowDetections = 0, e.narrowphaseTests = 0, e.narrowReuse = 0, e.narrowReuseCount = 0, e.midphaseTests = 0, e.broadphaseTests = 0, e.narrowEff = 0, e.midEff = 0, e.broadEff = 0, e.collisions = 0, e.buckets = 0, e.pairs = 0, e.bodies = 0)
			}, g.update = function(e, t) {
				if(e.extended) {
					var r = t.world,
						i = t.broadphase[t.broadphase.current],
						s = n.allBodies(r);
					e.collisions = e.narrowDetections, e.pairs = t.pairs.list.length, e.bodies = s.length, e.midEff = (e.narrowDetections / (e.midphaseTests || 1)).toFixed(2), e.narrowEff = (e.narrowDetections / (e.narrowphaseTests || 1)).toFixed(2), e.broadEff = (1 - e.broadphaseTests / (s.length || 1)).toFixed(2), e.narrowReuse = (e.narrowReuseCount / (e.narrowphaseTests || 1)).toFixed(2)
				}
			}
		})();
		var y;
		(function() {
			y = function(t) {
				var n = this;
				this.element = t || document.body, this.absolute = {
					x: 0,
					y: 0
				}, this.position = {
					x: 0,
					y: 0
				}, this.mousedownPosition = {
					x: 0,
					y: 0
				}, this.mouseupPosition = {
					x: 0,
					y: 0
				}, this.offset = {
					x: 0,
					y: 0
				}, this.scale = {
					x: 1,
					y: 1
				}, this.wheelDelta = 0, this.button = -1, this.sourceEvents = {
					mousemove: null,
					mousedown: null,
					mouseup: null,
					mousewheel: null
				}, this.mousemove = function(t) {
					var r = e(t, n.element),
						i = t.changedTouches;
					i && (n.button = 0, t.preventDefault()), n.absolute.x = r.x, n.absolute.y = r.y, n.position.x = n.absolute.x * n.scale.x + n.offset.x, n.position.y = n.absolute.y * n.scale.y + n.offset.y, n.sourceEvents.mousemove = t
				}, this.mousedown = function(t) {
					var r = e(t, n.element),
						i = t.changedTouches;
					i ? (n.button = 0, t.preventDefault()) : n.button = t.button, n.absolute.x = r.x, n.absolute.y = r.y, n.position.x = n.absolute.x * n.scale.x + n.offset.x, n.position.y = n.absolute.y * n.scale.y + n.offset.y, n.mousedownPosition.x = n.position.x, n.mousedownPosition.y = n.position.y, n.sourceEvents.mousedown = t
				}, this.mouseup = function(t) {
					var r = e(t, n.element),
						i = t.changedTouches;
					i && t.preventDefault(), n.button = -1, n.absolute.x = r.x, n.absolute.y = r.y, n.position.x = n.absolute.x * n.scale.x + n.offset.x, n.position.y = n.absolute.y * n.scale.y + n.offset.y, n.mouseupPosition.x = n.position.x, n.mouseupPosition.y = n.position.y, n.sourceEvents.mouseup = t
				}, this.mousewheel = function(e) {
					n.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault()
				}, y.setElement(n, n.element)
			}, y.create = function(e) {
				return new y(e)
			}, y.setElement = function(e, t) {
				e.element = t, t.addEventListener("mousemove", e.mousemove), t.addEventListener("mousedown", e.mousedown), t.addEventListener("mouseup", e.mouseup), t.addEventListener("mousewheel", e.mousewheel), t.addEventListener("DOMMouseScroll", e.mousewheel), t.addEventListener("touchmove", e.mousemove), t.addEventListener("touchstart", e.mousedown), t.addEventListener("touchend", e.mouseup)
			}, y.clearSourceEvents = function(e) {
				e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0
			}, y.setOffset = function(e, t) {
				e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y
			}, y.setScale = function(e, t) {
				e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y
			};
			var e = function(e, t) {
				var n = t.getBoundingClientRect(),
					r = document.documentElement || document.body.parentNode || document.body,
					i = window.pageXOffset !== undefined ? window.pageXOffset : r.scrollLeft,
					s = window.pageYOffset !== undefined ? window.pageYOffset : r.scrollTop,
					o = e.changedTouches,
					u, a;
				return o ? (u = o[0].pageX - n.left - i, a = o[0].pageY - n.top - s) : (u = e.pageX - n.left - i, a = e.pageY - n.top - s), {
					x: u / (t.clientWidth / t.width),
					y: a / (t.clientHeight / t.height)
				}
			}
		})();
		var b = {};
		(function() {
			var e = .18,
				t = .08,
				n = .9;
			b.update = function(e) {
				for(var r = 0; r < e.length; r++) {
					var i = e[r],
						s = i.speed * i.speed + i.angularSpeed * i.angularSpeed;
					if(i.force.x > 0 || i.force.y > 0) {
						b.set(i, !1);
						continue
					}
					var o = Math.min(i.motion, s),
						u = Math.max(i.motion, s);
					i.motion = n * o + (1 - n) * u, i.sleepThreshold > 0 && i.motion < t ? (i.sleepCounter += 1, i.sleepCounter >= i.sleepThreshold && b.set(i, !0)) : i.sleepCounter > 0 && (i.sleepCounter -= 1)
				}
			}, b.afterCollisions = function(t) {
				for(var n = 0; n < t.length; n++) {
					var r = t[n];
					if(!r.isActive) continue;
					var i = r.collision,
						s = i.bodyA,
						o = i.bodyB;
					if(s.isSleeping && o.isSleeping || s.isStatic || o.isStatic) continue;
					if(s.isSleeping || o.isSleeping) {
						var u = s.isSleeping && !s.isStatic ? s : o,
							a = u === s ? o : s;
						!u.isStatic && a.motion > e && b.set(u, !1)
					}
				}
			}, b.set = function(e, t) {
				t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0) : (e.isSleeping = !1, e.sleepCounter = 0)
			}
		})();
		var w = {};
		(function() {
			w.rectangle = function(e, n, r, i, s) {
				s = s || {};
				var o = {
					label: "Rectangle Body",
					position: {
						x: e,
						y: n
					},
					vertices: N.fromPath("L 0 0 L " + r + " 0 L " + r + " " + i + " L 0 " + i)
				};
				if(s.chamfer) {
					var u = s.chamfer;
					o.vertices = N.chamfer(o.vertices, u.radius, u.quality, u.qualityMin, u.qualityMax), delete s.chamfer
				}
				return t.create(d.extend({}, o, s))
			}, w.trapezoid = function(e, n, r, i, s, o) {
				o = o || {}, s *= .5;
				var u = (1 - s * 2) * r,
					a = r * s,
					f = a + u,
					l = f + a,
					c = {
						label: "Trapezoid Body",
						position: {
							x: e,
							y: n
						},
						vertices: N.fromPath("L 0 0 L " + a + " " + -i + " L " + f + " " + -i + " L " + l + " 0")
					};
				if(o.chamfer) {
					var h = o.chamfer;
					c.vertices = N.chamfer(c.vertices, h.radius, h.quality, h.qualityMin, h.qualityMax), delete o.chamfer
				}
				return t.create(d.extend({}, c, o))
			}, w.circle = function(e, t, n, r, i) {
				r = r || {}, r.label = "Circle Body", i = i || 25;
				var s = Math.ceil(Math.max(10, Math.min(i, n)));
				return s % 2 === 1 && (s += 1), r.circleRadius = n, w.polygon(e, t, s, n, r)
			}, w.polygon = function(e, n, r, i, s) {
				s = s || {};
				if(r < 3) return w.circle(e, n, i, s);
				var o = 2 * Math.PI / r,
					u = "",
					a = o * .5;
				for(var f = 0; f < r; f += 1) {
					var l = a + f * o,
						c = Math.cos(l) * i,
						h = Math.sin(l) * i;
					u += "L " + c.toFixed(3) + " " + h.toFixed(3) + " "
				}
				var p = {
					label: "Polygon Body",
					position: {
						x: e,
						y: n
					},
					vertices: N.fromPath(u)
				};
				if(s.chamfer) {
					var v = s.chamfer;
					p.vertices = N.chamfer(p.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete s.chamfer
				}
				return t.create(d.extend({}, p, s))
			}
		})();
		var E = {};
		(function() {
			E.stack = function(e, r, i, s, o, u, a) {
				var f = n.create({
						label: "Stack"
					}),
					l = e,
					c = r,
					h, p = 0;
				for(var d = 0; d < s; d++) {
					var v = 0;
					for(var m = 0; m < i; m++) {
						var g = a(l, c, m, d, h, p);
						if(g) {
							var y = g.bounds.max.y - g.bounds.min.y,
								b = g.bounds.max.x - g.bounds.min.x;
							y > v && (v = y), t.translate(g, {
								x: b * .5,
								y: y * .5
							}), l = g.bounds.max.x + o, n.addBody(f, g), h = g, p += 1
						}
					}
					c += v + u, l = e
				}
				return f
			}, E.chain = function(e, t, r, i, s, o) {
				var u = e.bodies;
				for(var a = 1; a < u.length; a++) {
					var f = u[a - 1],
						l = u[a],
						c = f.bounds.max.y - f.bounds.min.y,
						p = f.bounds.max.x - f.bounds.min.x,
						v = l.bounds.max.y - l.bounds.min.y,
						m = l.bounds.max.x - l.bounds.min.x,
						g = {
							bodyA: f,
							pointA: {
								x: p * t,
								y: c * r
							},
							bodyB: l,
							pointB: {
								x: m * i,
								y: v * s
							}
						},
						y = d.extend(g, o);
					n.addConstraint(e, h.create(y))
				}
				return e.label += " Chain", e
			}, E.mesh = function(e, t, r, i, s) {
				var o = e.bodies,
					u, a, f, l, c;
				for(u = 0; u < r; u++) {
					for(a = 0; a < t; a++) a > 0 && (f = o[a - 1 + u * t], l = o[a + u * t], n.addConstraint(e, h.create(d.extend({
						bodyA: f,
						bodyB: l
					}, s))));
					for(a = 0; a < t; a++) u > 0 && (f = o[a + (u - 1) * t], l = o[a + u * t], n.addConstraint(e, h.create(d.extend({
						bodyA: f,
						bodyB: l
					}, s))), i && a > 0 && (c = o[a - 1 + (u - 1) * t], n.addConstraint(e, h.create(d.extend({
						bodyA: c,
						bodyB: l
					}, s)))), i && a < t - 1 && (c = o[a + 1 + (u - 1) * t], n.addConstraint(e, h.create(d.extend({
						bodyA: c,
						bodyB: l
					}, s)))))
				}
				return e.label += " Mesh", e
			}, E.pyramid = function(e, n, r, i, s, o, u) {
				return E.stack(e, n, r, i, s, o, function(n, o, a, f, l, c) {
					var h = Math.min(i, Math.ceil(r / 2)),
						p = l ? l.bounds.max.x - l.bounds.min.x : 0;
					if(f > h) return;
					f = h - f;
					var d = f,
						v = r - 1 - f;
					if(a < d || a > v) return;
					c === 1 && t.translate(l, {
						x: (a + (r % 2 === 1 ? 1 : -1)) * p,
						y: 0
					});
					var m = l ? a * p : 0;
					return u(e + m + a * s, o, a, f, l, c)
				})
			}, E.newtonsCradle = function(e, t, r, i, s) {
				var o = n.create({
					label: "Newtons Cradle"
				});
				for(var u = 0; u < r; u++) {
					var a = 1.9,
						f = w.circle(e + u * i * a, t + s, i, {
							inertia: 99999,
							restitution: 1,
							friction: 0,
							frictionAir: 1e-4,
							slop: .01
						}),
						l = h.create({
							pointA: {
								x: e + u * i * a,
								y: t
							},
							bodyB: f
						});
					n.addBody(o, f), n.addConstraint(o, l)
				}
				return o
			}, E.car = function(e, r, i, s, o) {
				var u = t.nextGroupId(),
					a = -20,
					f = -i * .5 + a,
					l = i * .5 - a,
					c = 0,
					p = n.create({
						label: "Car"
					}),
					d = w.trapezoid(e, r, i, s, .3, {
						groupId: u,
						friction: .01,
						chamfer: {
							radius: 10
						}
					}),
					v = w.circle(e + f, r + c, o, {
						groupId: u,
						restitution: .5,
						friction: .9,
						density: .01
					}),
					m = w.circle(e + l, r + c, o, {
						groupId: u,
						restitution: .5,
						friction: .9,
						density: .01
					}),
					g = h.create({
						bodyA: d,
						pointA: {
							x: f,
							y: c
						},
						bodyB: v,
						stiffness: .5
					}),
					y = h.create({
						bodyA: d,
						pointA: {
							x: l,
							y: c
						},
						bodyB: m,
						stiffness: .5
					});
				return n.addBody(p, d), n.addBody(p, v), n.addBody(p, m), n.addConstraint(p, g), n.addConstraint(p, y), p
			}, E.softBody = function(e, t, n, r, i, s, o, u, a, f) {
				a = d.extend({
					inertia: Infinity
				}, a), f = d.extend({
					stiffness: .4
				}, f);
				var l = E.stack(e, t, n, r, i, s, function(e, t, n, r) {
					return w.circle(e, t, u, a)
				});
				return E.mesh(l, n, r, o, f), l.label = "Soft Body", l
			}
		})();
		var S = {};
		(function() {
			S.fromVertices = function(e) {
				var t = {};
				for(var n = 0; n < e.length; n++) {
					var r = (n + 1) % e.length,
						i = T.normalise({
							x: e[r].y - e[n].y,
							y: e[n].x - e[r].x
						}),
						s = i.y === 0 ? Infinity : i.x / i.y;
					s = s.toFixed(3).toString(), t[s] = i
				}
				return d.values(t)
			}, S.rotate = function(e, t) {
				if(t === 0) return;
				var n = Math.cos(t),
					r = Math.sin(t);
				for(var i = 0; i < e.length; i++) {
					var s = e[i],
						o;
					o = s.x * n - s.y * r, s.y = s.x * r + s.y * n, s.x = o
				}
			}
		})();
		var x = {};
		(function() {
			x.create = function(e) {
				var t = {
					min: {
						x: 0,
						y: 0
					},
					max: {
						x: 0,
						y: 0
					}
				};
				return e && x.update(t, e), t
			}, x.update = function(e, t, n) {
				e.min.x = Number.MAX_VALUE, e.max.x = Number.MIN_VALUE, e.min.y = Number.MAX_VALUE, e.max.y = Number.MIN_VALUE;
				for(var r = 0; r < t.length; r++) {
					var i = t[r];
					i.x > e.max.x && (e.max.x = i.x), i.x < e.min.x && (e.min.x = i.x), i.y > e.max.y && (e.max.y = i.y), i.y < e.min.y && (e.min.y = i.y)
				}
				n && (n.x > 0 ? e.max.x += n.x : e.min.x += n.x, n.y > 0 ? e.max.y += n.y : e.min.y += n.y)
			}, x.contains = function(e, t) {
				return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y
			}, x.overlaps = function(e, t) {
				return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y
			}, x.translate = function(e, t) {
				e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y
			}, x.shift = function(e, t) {
				var n = e.max.x - e.min.x,
					r = e.max.y - e.min.y;
				e.min.x = t.x, e.max.x = t.x + n, e.min.y = t.y, e.max.y = t.y + r
			}
		})();
		var T = {};
		(function() {
			T.magnitude = function(e) {
				return Math.sqrt(e.x * e.x + e.y * e.y)
			}, T.magnitudeSquared = function(e) {
				return e.x * e.x + e.y * e.y
			}, T.rotate = function(e, t) {
				var n = Math.cos(t),
					r = Math.sin(t);
				return {
					x: e.x * n - e.y * r,
					y: e.x * r + e.y * n
				}
			}, T.rotateAbout = function(e, t, n) {
				var r = Math.cos(t),
					i = Math.sin(t);
				return {
					x: n.x + ((e.x - n.x) * r - (e.y - n.y) * i),
					y: n.y + ((e.x - n.x) * i + (e.y - n.y) * r)
				}
			}, T.normalise = function(e) {
				var t = T.magnitude(e);
				return t === 0 ? {
					x: 0,
					y: 0
				} : {
					x: e.x / t,
					y: e.y / t
				}
			}, T.dot = function(e, t) {
				return e.x * t.x + e.y * t.y
			}, T.cross = function(e, t) {
				return e.x * t.y - e.y * t.x
			}, T.add = function(e, t) {
				return {
					x: e.x + t.x,
					y: e.y + t.y
				}
			}, T.sub = function(e, t) {
				return {
					x: e.x - t.x,
					y: e.y - t.y
				}
			}, T.mult = function(e, t) {
				return {
					x: e.x * t,
					y: e.y * t
				}
			}, T.div = function(e, t) {
				return {
					x: e.x / t,
					y: e.y / t
				}
			}, T.perp = function(e, t) {
				return t = t === !0 ? -1 : 1, {
					x: t * -e.y,
					y: t * e.x
				}
			}, T.neg = function(e) {
				return {
					x: -e.x,
					y: -e.y
				}
			}, T.angle = function(e, t) {
				return Math.atan2(t.y - e.y, t.x - e.x)
			}
		})();
		var N = {};
		(function() {
			N.create = function(e, t) {
				for(var n = 0; n < e.length; n++) e[n].index = n, e[n].body = t
			}, N.fromPath = function(e) {
				var t = /L\s*([\-\d\.]*)\s*([\-\d\.]*)/ig,
					n = [];
				return e.replace(t, function(e, t, r) {
					n.push({
						x: parseFloat(t, 10),
						y: parseFloat(r, 10)
					})
				}), n
			}, N.centre = function(e) {
				var t = N.area(e, !0),
					n = {
						x: 0,
						y: 0
					},
					r, i, s;
				for(var o = 0; o < e.length; o++) s = (o + 1) % e.length, r = T.cross(e[o], e[s]), i = T.mult(T.add(e[o], e[s]), r), n = T.add(n, i);
				return T.div(n, 6 * t)
			}, N.area = function(e, t) {
				var n = 0,
					r = e.length - 1;
				for(var i = 0; i < e.length; i++) n += (e[r].x - e[i].x) * (e[r].y + e[i].y), r = i;
				return t ? n / 2 : Math.abs(n) / 2
			}, N.inertia = function(e, t) {
				var n = 0,
					r = 0,
					i = e,
					s, o;
				for(var u = 0; u < i.length; u++) o = (u + 1) % i.length, s = Math.abs(T.cross(i[o], i[u])), n += s * (T.dot(i[o], i[o]) + T.dot(i[o], i[u]) + T.dot(i[u], i[u])), r += s;
				return t / 6 * (n / r)
			}, N.translate = function(e, t, n) {
				var r;
				if(n)
					for(r = 0; r < e.length; r++) e[r].x += t.x * n, e[r].y += t.y * n;
				else
					for(r = 0; r < e.length; r++) e[r].x += t.x, e[r].y += t.y
			}, N.rotate = function(e, t, n) {
				if(t === 0) return;
				var r = Math.cos(t),
					i = Math.sin(t);
				for(var s = 0; s < e.length; s++) {
					var o = e[s],
						u = o.x - n.x,
						a = o.y - n.y;
					o.x = n.x + (u * r - a * i), o.y = n.y + (u * i + a * r)
				}
			}, N.contains = function(e, t) {
				for(var n = 0; n < e.length; n++) {
					var r = e[n],
						i = e[(n + 1) % e.length];
					if((t.x - r.x) * (i.y - r.y) + (t.y - r.y) * (r.x - i.x) > 0) return !1
				}
				return !0
			}, N.scale = function(e, t, n, r) {
				if(t === 1 && n === 1) return e;
				r = r || N.centre(e);
				var i, s;
				for(var o = 0; o < e.length; o++) i = e[o], s = T.sub(i, r), e[o].x = r.x + s.x * t, e[o].y = r.y + s.y * n;
				return e
			}, N.chamfer = function(e, t, n, r, i) {
				t = t || [8], t.length || (t = [t]), n = typeof n != "undefined" ? n : -1, r = r || 2, i = i || 14;
				var s = N.centre(e),
					o = [];
				for(var u = 0; u < e.length; u++) {
					var a = e[u - 1 >= 0 ? u - 1 : e.length - 1],
						f = e[u],
						l = e[(u + 1) % e.length],
						c = t[u < t.length ? u : t.length - 1];
					if(c === 0) {
						o.push(f);
						continue
					}
					var h = T.normalise({
							x: f.y - a.y,
							y: a.x - f.x
						}),
						p = T.normalise({
							x: l.y - f.y,
							y: f.x - l.x
						}),
						v = Math.sqrt(2 * Math.pow(c, 2)),
						m = T.mult(d.clone(h), c),
						g = T.normalise(T.mult(T.add(h, p), .5)),
						y = T.sub(f, T.mult(g, v)),
						b = n;
					n === -1 && (b = Math.pow(c, .32) * 1.75), b = d.clamp(b, r, i), b % 2 === 1 && (b += 1);
					var w = Math.acos(T.dot(h, p)),
						E = w / b;
					for(var S = 0; S < b; S++) o.push(T.add(T.rotate(m, E * S), y))
				}
				return o
			}
		})();
		var C = {};
		(function() {
			C.create = function(t) {
				var n = {
						controller: C,
						element: null,
						canvas: null,
						options: {
							width: 800,
							height: 600,
							background: "#fafafa",
							wireframeBackground: "#222",
							hasBounds: !1,
							enabled: !0,
							wireframes: !0,
							showSleeping: !0,
							showDebug: !1,
							showBroadphase: !1,
							showBounds: !1,
							showVelocity: !1,
							showCollisions: !1,
							showAxes: !1,
							showPositions: !1,
							showAngleIndicator: !1,
							showIds: !1,
							showShadows: !1
						}
					},
					r = d.extend(n, t);
				return r.canvas = r.canvas || e(r.options.width, r.options.height), r.context = r.canvas.getContext("2d"), r.textures = {}, r.bounds = r.bounds || {
					min: {
						x: 0,
						y: 0
					},
					max: {
						x: r.options.width,
						y: r.options.height
					}
				}, C.setBackground(r, r.options.background), d.isElement(r.element) ? r.element.appendChild(r.canvas) : d.log('No "render.element" passed, "render.canvas" was not inserted into document.', "warn"), r
			}, C.clear = function(e) {}, C.setBackground = function(e, t) {
				if(e.currentBackground !== t) {
					var n = t;
					/(jpg|gif|png)$/.test(t) && (n = "url(" + t + ")"), e.canvas.style.background = n, e.canvas.style.backgroundSize = "contain", e.currentBackground = t
				}
			}, C.world = function(e) {
				var t = e.render,
					r = e.world,
					i = t.canvas,
					s = t.context,
					o = t.options,
					u = n.allBodies(r),
					a = n.allConstraints(r),
					f = [],
					l = [],
					c;
				o.wireframes ? C.setBackground(t, o.wireframeBackground) : C.setBackground(t, o.background), s.globalCompositeOperation = "source-in", s.fillStyle = "transparent", s.fillRect(0, 0, i.width, i.height), s.globalCompositeOperation = "source-over";
				var h = t.bounds.max.x - t.bounds.min.x,
					p = t.bounds.max.y - t.bounds.min.y,
					d = h / t.options.width,
					v = p / t.options.height;
				if(o.hasBounds) {
					for(c = 0; c < u.length; c++) {
						var m = u[c];
						x.overlaps(m.bounds, t.bounds) && f.push(m)
					}
					for(c = 0; c < a.length; c++) {
						var g = a[c],
							y = g.bodyA,
							b = g.bodyB,
							w = g.pointA,
							E = g.pointB;
						y && (w = T.add(y.position, g.pointA)), b && (E = T.add(b.position, g.pointB));
						if(!w || !E) continue;
						(x.contains(t.bounds, w) || x.contains(t.bounds, E)) && l.push(g)
					}
					s.scale(1 / d, 1 / v), s.translate(-t.bounds.min.x, -t.bounds.min.y)
				} else l = a, f = u;
				!o.wireframes || e.enableSleeping && o.showSleeping ? C.bodies(e, f, s) : C.bodyWireframes(e, f, s), o.showBounds && C.bodyBounds(e, f, s), (o.showAxes || o.showAngleIndicator) && C.bodyAxes(e, f, s), o.showPositions && C.bodyPositions(e, f, s), o.showVelocity && C.bodyVelocity(e, f, s), o.showIds && C.bodyIds(e, f, s), o.showCollisions && C.collisions(e, e.pairs.list, s), C.constraints(l, s), o.showBroadphase && e.broadphase.current === "grid" && C.grid(e, e.broadphase[e.broadphase.current].instance, s), o.showDebug && C.debug(e, s), o.hasBounds && s.setTransform(1, 0, 0, 1, 0, 0)
			}, C.debug = function(e, t) {
				var r = t,
					i = e.world,
					s = e.render,
					u = s.options,
					a = n.allBodies(i),
					f = "    ";
				if(e.timing.timestamp - (s.debugTimestamp || 0) >= 500) {
					var l = "";
					l += "fps: " + Math.round(e.timing.fps) + f, e.metrics.extended && (l += "delta: " + e.timing.delta.toFixed(3) + f, l += "correction: " + e.timing.correction.toFixed(3) + f, l += "bodies: " + a.length + f, e.broadphase.controller === o && (l += "buckets: " + e.metrics.buckets + f), l += "\n", l += "collisions: " + e.metrics.collisions + f, l += "pairs: " + e.pairs.list.length + f, l += "broad: " + e.metrics.broadEff + f, l += "mid: " + e.metrics.midEff + f, l += "narrow: " + e.metrics.narrowEff + f), s.debugString = l, s.debugTimestamp = e.timing.timestamp
				}
				if(s.debugString) {
					r.font = "12px Arial", u.wireframes ? r.fillStyle = "rgba(255,255,255,0.5)" : r.fillStyle = "rgba(0,0,0,0.5)";
					var c = s.debugString.split("\n");
					for(var h = 0; h < c.length; h++) r.fillText(c[h], 50, 50 + h * 18)
				}
			}, C.constraints = function(e, t) {
				var n = t;
				for(var r = 0; r < e.length; r++) {
					var i = e[r];
					if(!i.render.visible || !i.pointA || !i.pointB) continue;
					var s = i.bodyA,
						o = i.bodyB;
					s ? (n.beginPath(), n.moveTo(s.position.x + i.pointA.x, s.position.y + i.pointA.y)) : (n.beginPath(), n.moveTo(i.pointA.x, i.pointA.y)), o ? n.lineTo(o.position.x + i.pointB.x, o.position.y + i.pointB.y) : n.lineTo(i.pointB.x, i.pointB.y), n.lineWidth = i.render.lineWidth, n.strokeStyle = i.render.strokeStyle, n.stroke()
				}
			}, C.bodyShadows = function(e, t, n) {
				var r = n,
					i = e.render,
					s = i.options;
				for(var o = 0; o < t.length; o++) {
					var u = t[o];
					if(!u.render.visible) continue;
					if(u.circleRadius) r.beginPath(), r.arc(u.position.x, u.position.y, u.circleRadius, 0, 2 * Math.PI), r.closePath();
					else {
						r.beginPath(), r.moveTo(u.vertices[0].x, u.vertices[0].y);
						for(var a = 1; a < u.vertices.length; a++) r.lineTo(u.vertices[a].x, u.vertices[a].y);
						r.closePath()
					}
					var f = u.position.x - i.options.width * .5,
						l = u.position.y - i.options.height * .2,
						c = Math.abs(f) + Math.abs(l);
					r.shadowColor = "rgba(0,0,0,0.15)", r.shadowOffsetX = .05 * f, r.shadowOffsetY = .05 * l, r.shadowBlur = 1 + 12 * Math.min(1, c / 1e3), r.fill(), r.shadowColor = null, r.shadowOffsetX = null, r.shadowOffsetY = null, r.shadowBlur = null
				}
			}, C.bodies = function(e, n, r) {
				var i = r,
					s = e.render,
					o = s.options,
					u;
				for(u = 0; u < n.length; u++) {
					var a = n[u];
					if(!a.render.visible) continue;
					if(a.render.sprite && a.render.sprite.texture && !o.wireframes) {
						var f = a.render.sprite,
							l = t(s, f.texture);
						o.showSleeping && a.isSleeping && (i.globalAlpha = .5), i.translate(a.position.x, a.position.y), i.rotate(a.angle), i.drawImage(l, l.width * -0.5 * f.xScale, l.height * -0.5 * f.yScale, l.width * f.xScale, l.height * f.yScale), i.rotate(-a.angle), i.translate(-a.position.x, -a.position.y), o.showSleeping && a.isSleeping && (i.globalAlpha = 1)
					} else {
						if(a.circleRadius) i.beginPath(), i.arc(a.position.x, a.position.y, a.circleRadius, 0, 2 * Math.PI);
						else {
							i.beginPath(), i.moveTo(a.vertices[0].x, a.vertices[0].y);
							for(var c = 1; c < a.vertices.length; c++) i.lineTo(a.vertices[c].x, a.vertices[c].y);
							i.closePath()
						}
						o.wireframes ? (i.lineWidth = 1, i.strokeStyle = "#bbb", o.showSleeping && a.isSleeping && (i.strokeStyle = "rgba(255,255,255,0.2)"), i.stroke()) : (o.showSleeping && a.isSleeping ? i.fillStyle = d.shadeColor(a.render.fillStyle, 50) : i.fillStyle = a.render.fillStyle, i.lineWidth = a.render.lineWidth, i.strokeStyle = a.render.strokeStyle, i.fill(), i.stroke())
					}
				}
			}, C.bodyWireframes = function(e, t, n) {
				var r = n,
					i, s;
				r.beginPath();
				for(i = 0; i < t.length; i++) {
					var o = t[i];
					if(!o.render.visible) continue;
					r.moveTo(o.vertices[0].x, o.vertices[0].y);
					for(s = 1; s < o.vertices.length; s++) r.lineTo(o.vertices[s].x, o.vertices[s].y);
					r.lineTo(o.vertices[0].x, o.vertices[0].y)
				}
				r.lineWidth = 1, r.strokeStyle = "#bbb", r.stroke()
			}, C.bodyBounds = function(e, t, n) {
				var r = n,
					i = e.render,
					s = i.options;
				r.beginPath();
				for(var o = 0; o < t.length; o++) {
					var u = t[o];
					u.render.visible && r.rect(u.bounds.min.x, u.bounds.min.y, u.bounds.max.x - u.bounds.min.x, u.bounds.max.y - u.bounds.min.y)
				}
				s.wireframes ? r.strokeStyle = "rgba(255,255,255,0.08)" : r.strokeStyle = "rgba(0,0,0,0.1)", r.lineWidth = 1, r.stroke()
			}, C.bodyAxes = function(e, t, n) {
				var r = n,
					i = e.render,
					s = i.options,
					o, u;
				r.beginPath();
				for(o = 0; o < t.length; o++) {
					var a = t[o];
					if(!a.render.visible) continue;
					if(s.showAxes)
						for(u = 0; u < a.axes.length; u++) {
							var f = a.axes[u];
							r.moveTo(a.position.x, a.position.y), r.lineTo(a.position.x + f.x * 20, a.position.y + f.y * 20)
						} else r.moveTo(a.position.x, a.position.y), r.lineTo((a.vertices[0].x + a.vertices[a.vertices.length - 1].x) / 2, (a.vertices[0].y + a.vertices[a.vertices.length - 1].y) / 2)
				}
				s.wireframes ? r.strokeStyle = "indianred" : r.strokeStyle = "rgba(0,0,0,0.3)", r.lineWidth = 1, r.stroke()
			}, C.bodyPositions = function(e, t, n) {
				var r = n,
					i = e.render,
					s = i.options,
					o, u;
				r.beginPath();
				for(u = 0; u < t.length; u++) o = t[u], o.render.visible && (r.arc(o.position.x, o.position.y, 3, 0, 2 * Math.PI, !1), r.closePath());
				s.wireframes ? r.fillStyle = "indianred" : r.fillStyle = "rgba(0,0,0,0.5)", r.fill(), r.beginPath();
				for(u = 0; u < t.length; u++) o = t[u], o.render.visible && (r.arc(o.positionPrev.x, o.positionPrev.y, 2, 0, 2 * Math.PI, !1), r.closePath());
				r.fillStyle = "rgba(255,165,0,0.8)", r.fill()
			}, C.bodyVelocity = function(e, t, n) {
				var r = n,
					i = e.render,
					s = i.options;
				r.beginPath();
				for(var o = 0; o < t.length; o++) {
					var u = t[o];
					if(!u.render.visible) continue;
					r.moveTo(u.position.x, u.position.y), r.lineTo(u.position.x + (u.position.x - u.positionPrev.x) * 2, u.position.y + (u.position.y - u.positionPrev.y) * 2)
				}
				r.lineWidth = 3, r.strokeStyle = "cornflowerblue", r.stroke()
			}, C.bodyIds = function(e, t, n) {
				var r = n;
				for(var i = 0; i < t.length; i++) {
					var s = t[i];
					if(!s.render.visible) continue;
					r.font = "12px Arial", r.fillStyle = "rgba(255,255,255,0.5)", r.fillText(s.id, s.position.x + 10, s.position.y - 10)
				}
			}, C.collisions = function(e, t, n) {
				var r = n,
					i = e.render.options,
					s, o, u, a;
				r.beginPath();
				for(u = 0; u < t.length; u++) {
					s = t[u], o = s.collision;
					for(a = 0; a < s.activeContacts.length; a++) {
						var f = s.activeContacts[a],
							l = f.vertex;
						r.rect(l.x - 1.5, l.y - 1.5, 3.5, 3.5)
					}
				}
				i.wireframes ? r.fillStyle = "rgba(255,255,255,0.7)" : r.fillStyle = "orange", r.fill(), r.beginPath();
				for(u = 0; u < t.length; u++) {
					s = t[u], o = s.collision;
					if(s.activeContacts.length > 0) {
						var c = s.activeContacts[0].vertex.x,
							h = s.activeContacts[0].vertex.y;
						s.activeContacts.length === 2 && (c = (s.activeContacts[0].vertex.x + s.activeContacts[1].vertex.x) / 2, h = (s.activeContacts[0].vertex.y + s.activeContacts[1].vertex.y) / 2), r.moveTo(c - o.normal.x * 8, h - o.normal.y * 8), r.lineTo(c, h)
					}
				}
				i.wireframes ? r.strokeStyle = "rgba(255,165,0,0.7)" : r.strokeStyle = "orange", r.lineWidth = 1, r.stroke()
			}, C.grid = function(e, t, n) {
				var r = n,
					i = e.render.options;
				i.wireframes ? r.strokeStyle = "rgba(255,180,0,0.1)" : r.strokeStyle = "rgba(255,180,0,0.5)", r.beginPath();
				var s = d.keys(t.buckets);
				for(var o = 0; o < s.length; o++) {
					var u = s[o];
					if(t.buckets[u].length < 2) continue;
					var a = u.split(",");
					r.rect(.5 + parseInt(a[0], 10) * t.bucketWidth, .5 + parseInt(a[1], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight)
				}
				r.lineWidth = 1, r.stroke()
			}, C.inspector = function(e, t) {
				var n = e.engine,
					r = n.input.mouse,
					i = e.selected,
					s = t,
					o = n.render,
					u = o.options,
					a;
				if(u.hasBounds) {
					var f = o.bounds.max.x - o.bounds.min.x,
						l = o.bounds.max.y - o.bounds.min.y,
						c = f / o.options.width,
						h = l / o.options.height;
					t.scale(1 / c, 1 / h), t.translate(-o.bounds.min.x, -o.bounds.min.y)
				}
				for(var p = 0; p < i.length; p++) {
					var d = i[p].data;
					t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.9)", t.setLineDash([1, 2]);
					switch(d.type) {
						case "body":
							a = d.bounds, t.beginPath(), t.rect(Math.floor(a.min.x - 3), Math.floor(a.min.y - 3), Math.floor(a.max.x - a.min.x + 6), Math.floor(a.max.y - a.min.y + 6)), t.closePath(), t.stroke();
							break;
						case "constraint":
							var v = d.pointA;
							d.bodyA && (v = d.pointB), t.beginPath(), t.arc(v.x, v.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke()
					}
					t.setLineDash([0]), t.translate(-0.5, -0.5)
				}
				e.selectStart !== null && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.6)", t.fillStyle = "rgba(255,165,0,0.1)", a = e.selectBounds, t.beginPath(), t.rect(Math.floor(a.min.x), Math.floor(a.min.y), Math.floor(a.max.x - a.min.x), Math.floor(a.max.y - a.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-0.5, -0.5)), u.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0)
			};
			var e = function(e, t) {
					var n = document.createElement("canvas");
					return n.width = e, n.height = t, n
				},
				t = function(e, t) {
					var n = e.textures[t];
					return n ? n : (n = e.textures[t] = new Image, n.src = t, n)
				}
		})();
		var k = {};
		(function() {
			k.create = function(e) {
				var t = {
						controller: k,
						element: null,
						canvas: null,
						options: {
							width: 800,
							height: 600,
							background: "#fafafa",
							wireframeBackground: "#222",
							enabled: !0,
							wireframes: !0,
							showSleeping: !0,
							showDebug: !1,
							showBroadphase: !1,
							showBounds: !1,
							showVelocity: !1,
							showCollisions: !1,
							showAxes: !1,
							showPositions: !1,
							showAngleIndicator: !1,
							showIds: !1,
							showShadows: !1
						}
					},
					n = d.extend(t, e);
				return n.context = new PIXI.WebGLRenderer(800, 600, n.canvas, !1, !0), n.canvas = n.context.view, n.stage = new PIXI.Stage, n.textures = {}, n.sprites = {}, n.primitives = {}, n.spriteBatch = new PIXI.SpriteBatch, n.stage.addChild(n.spriteBatch), d.isElement(n.element) ? n.element.appendChild(n.canvas) : d.log('No "render.element" passed, "render.canvas" was not inserted into document.', "warn"), n.canvas.oncontextmenu = function() {
					return !1
				}, n.canvas.onselectstart = function() {
					return !1
				}, n
			}, k.clear = function(e) {
				var t = e.stage,
					n = e.spriteBatch;
				while(t.children[0]) t.removeChild(t.children[0]);
				while(n.children[0]) n.removeChild(n.children[0]);
				var r = e.sprites["bg-0"];
				e.textures = {}, e.sprites = {}, e.primitives = {}, e.sprites["bg-0"] = r, r && n.addChildAt(r, 0), e.stage.addChild(e.spriteBatch), e.currentBackground = null
			}, k.setBackground = function(e, t) {
				if(e.currentBackground !== t) {
					var n = t.indexOf && t.indexOf("#") !== -1,
						i = e.sprites["bg-0"];
					if(n) {
						var s = d.colorToNumber(t);
						e.stage.setBackgroundColor(s), i && e.spriteBatch.removeChild(i)
					} else if(!i) {
						var o = r(e, t);
						i = e.sprites["bg-0"] = new PIXI.Sprite(o), i.position.x = 0, i.position.y = 0, e.spriteBatch.addChildAt(i, 0)
					}
					e.currentBackground = t
				}
			}, k.world = function(e) {
				var t = e.render,
					r = e.world,
					i = t.context,
					s = t.stage,
					o = t.options,
					u = n.allBodies(r),
					a = n.allConstraints(r),
					f;
				o.wireframes ? k.setBackground(t, o.wireframeBackground) : k.setBackground(t, o.background);
				for(f = 0; f < u.length; f++) k.body(e, u[f]);
				for(f = 0; f < a.length; f++) k.constraint(e, a[f]);
				i.render(s)
			}, k.constraint = function(e, t) {
				var n = e.render,
					r = t.bodyA,
					i = t.bodyB,
					s = t.pointA,
					o = t.pointB,
					u = n.stage,
					a = t.render,
					f = "c-" + t.id,
					l = n.primitives[f];
				l || (l = n.primitives[f] = new PIXI.Graphics);
				if(!a.visible || !t.pointA || !t.pointB) {
					l.clear();
					return
				}
				u.children.indexOf(l) === -1 && u.addChild(l), l.clear(), l.beginFill(0, 0), l.lineStyle(a.lineWidth, d.colorToNumber(a.strokeStyle), 1), r ? l.moveTo(r.position.x + s.x, r.position.y + s.y) : l.moveTo(s.x, s.y), i ? l.lineTo(i.position.x + o.x, i.position.y + o.y) : l.lineTo(o.x, o.y), l.endFill()
			}, k.body = function(n, r) {
				var i = n.render,
					s = r.render;
				if(!s.visible) return;
				if(s.sprite && s.sprite.texture) {
					var o = "b-" + r.id,
						u = i.sprites[o],
						a = i.spriteBatch;
					u || (u = i.sprites[o] = e(i, r)), a.children.indexOf(u) === -1 && a.addChild(u), u.position.x = r.position.x, u.position.y = r.position.y, u.rotation = r.angle
				} else {
					var f = "b-" + r.id,
						l = i.primitives[f],
						c = i.stage;
					l || (l = i.primitives[f] = t(i, r), l.initialAngle = r.angle), c.children.indexOf(l) === -1 && c.addChild(l), l.position.x = r.position.x, l.position.y = r.position.y, l.rotation = r.angle - l.initialAngle
				}
			};
			var e = function(e, t) {
					var n = t.render,
						i = n.sprite.texture,
						s = r(e, i),
						o = new PIXI.Sprite(s);
					return o.anchor.x = .5, o.anchor.y = .5, o
				},
				t = function(e, t) {
					var n = t.render,
						r = e.options,
						i = new PIXI.Graphics;
					i.clear(), r.wireframes ? (i.beginFill(0, 0), i.lineStyle(1, d.colorToNumber("#bbb"), 1)) : (i.beginFill(d.colorToNumber(n.fillStyle), 1), i.lineStyle(t.render.lineWidth, d.colorToNumber(n.strokeStyle), 1)), i.moveTo(t.vertices[0].x - t.position.x, t.vertices[0].y - t.position.y);
					for(var s = 1; s < t.vertices.length; s++) i.lineTo(t.vertices[s].x - t.position.x, t.vertices[s].y - t.position.y);
					i.lineTo(t.vertices[0].x - t.position.x, t.vertices[0].y - t.position.y), i.endFill();
					if(r.showAngleIndicator || r.showAxes) i.beginFill(0, 0), r.wireframes ? i.lineStyle(1, d.colorToNumber("#CD5C5C"), 1) : i.lineStyle(1, d.colorToNumber(t.render.strokeStyle)), i.moveTo(0, 0), i.lineTo((t.vertices[0].x + t.vertices[t.vertices.length - 1].x) / 2 - t.position.x, (t.vertices[0].y + t.vertices[t.vertices.length - 1].y) / 2 - t.position.y), i.endFill();
					return i
				},
				r = function(e, t) {
					var n = e.textures[t];
					return n || (n = e.textures[t] = PIXI.Texture.fromImage(t)), n
				}
		})(), r.add = n.add, r.remove = n.remove, r.addComposite = n.addComposite, r.addBody = n.addBody, r.addConstraint = n.addConstraint, r.clear = n.clear, e.Body = t, e.Composite = n, e.World = r, e.Contact = i, e.Detector = s, e.Grid = o, e.Pairs = a, e.Pair = u, e.Resolver = l, e.SAT = c, e.Constraint = h, e.MouseConstraint = p, e.Common = d, e.Engine = v, e.Metrics = g, e.Mouse = y, e.Sleeping = b, e.Bodies = w, e.Composites = E, e.Axes = S, e.Bounds = x, e.Vector = T, e.Vertices = N, e.Render = C, e.RenderPixi = k, e.Events = m, e.Query = f, typeof exports != "undefined" && (typeof module != "undefined" && module.exports && (exports = module.exports = e), exports.Matter = e), typeof define == "function" && define.amd && define("Matter", [], function() {
			return e
		}), typeof window == "object" && typeof window.document == "object" && (window.Matter = e)
	}(), define("matter", function() {});
var dat = dat || {};
dat.gui = dat.gui || {}, dat.utils = dat.utils || {}, dat.controllers = dat.controllers || {}, dat.dom = dat.dom || {}, dat.color = dat.color || {}, dat.utils.css = function() {
	return {
		load: function(e, t) {
			t = t || document;
			var n = t.createElement("link");
			n.type = "text/css", n.rel = "stylesheet", n.href = e, t.getElementsByTagName("head")[0].appendChild(n)
		},
		inject: function(e, t) {
			t = t || document;
			var n = document.createElement("style");
			n.type = "text/css", n.innerHTML = e, t.getElementsByTagName("head")[0].appendChild(n)
		}
	}
}(), dat.utils.common = function() {
	var e = Array.prototype.forEach,
		t = Array.prototype.slice;
	return {
		BREAK: {},
		extend: function(e) {
			return this.each(t.call(arguments, 1), function(t) {
				for(var n in t) this.isUndefined(t[n]) || (e[n] = t[n])
			}, this), e
		},
		defaults: function(e) {
			return this.each(t.call(arguments, 1), function(t) {
				for(var n in t) this.isUndefined(e[n]) && (e[n] = t[n])
			}, this), e
		},
		compose: function() {
			var e = t.call(arguments);
			return function() {
				for(var n = t.call(arguments), r = e.length - 1; 0 <= r; r--) n = [e[r].apply(this, n)];
				return n[0]
			}
		},
		each: function(t, n, r) {
			if(e && t.forEach === e) t.forEach(n, r);
			else if(t.length === t.length + 0)
				for(var i = 0, s = t.length; i < s && !(i in t && n.call(r, t[i], i) === this.BREAK); i++);
			else
				for(i in t)
					if(n.call(r, t[i], i) === this.BREAK) break
		},
		defer: function(e) {
			setTimeout(e, 0)
		},
		toArray: function(e) {
			return e.toArray ? e.toArray() : t.call(e)
		},
		isUndefined: function(e) {
			return void 0 === e
		},
		isNull: function(e) {
			return null === e
		},
		isNaN: function(e) {
			return e !== e
		},
		isArray: Array.isArray || function(e) {
			return e.constructor === Array
		},
		isObject: function(e) {
			return e === Object(e)
		},
		isNumber: function(e) {
			return e === e + 0
		},
		isString: function(e) {
			return e === e + ""
		},
		isBoolean: function(e) {
			return !1 === e || !0 === e
		},
		isFunction: function(e) {
			return "[object Function]" === Object.prototype.toString.call(e)
		}
	}
}(), dat.controllers.Controller = function(e) {
	var t = function(e, t) {
		this.initialValue = e[t], this.domElement = document.createElement("div"), this.object = e, this.property = t, this.__onFinishChange = this.__onChange = void 0
	};
	return e.extend(t.prototype, {
		onChange: function(e) {
			return this.__onChange = e, this
		},
		onFinishChange: function(e) {
			return this.__onFinishChange = e, this
		},
		setValue: function(e) {
			return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this
		},
		getValue: function() {
			return this.object[this.property]
		},
		updateDisplay: function() {
			return this
		},
		isModified: function() {
			return this.initialValue !== this.getValue()
		}
	}), t
}(dat.utils.common), dat.dom.dom = function(e) {
	function t(t) {
		return "0" === t || e.isUndefined(t) ? 0 : (t = t.match(r), e.isNull(t) ? 0 : parseFloat(t[1]))
	}
	var n = {};
	e.each({
		HTMLEvents: ["change"],
		MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
		KeyboardEvents: ["keydown"]
	}, function(t, r) {
		e.each(t, function(e) {
			n[e] = r
		})
	});
	var r = /(\d+(\.\d+)?)px/,
		i = {
			makeSelectable: function(e, t) {
				void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function() {
					return !1
				} : function() {}, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off")
			},
			makeFullscreen: function(t, n, r) {
				e.isUndefined(n) && (n = !0), e.isUndefined(r) && (r = !0), t.style.position = "absolute", n && (t.style.left = 0, t.style.right = 0), r && (t.style.top = 0, t.style.bottom = 0)
			},
			fakeEvent: function(t, r, i, s) {
				i = i || {};
				var o = n[r];
				if(!o) throw Error("Event type " + r + " not supported.");
				var u = document.createEvent(o);
				switch(o) {
					case "MouseEvents":
						u.initMouseEvent(r, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, i.x || i.clientX || 0, i.y || i.clientY || 0, !1, !1, !1, !1, 0, null);
						break;
					case "KeyboardEvents":
						o = u.initKeyboardEvent || u.initKeyEvent, e.defaults(i, {
							cancelable: !0,
							ctrlKey: !1,
							altKey: !1,
							shiftKey: !1,
							metaKey: !1,
							keyCode: void 0,
							charCode: void 0
						}), o(r, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
						break;
					default:
						u.initEvent(r, i.bubbles || !1, i.cancelable || !0)
				}
				e.defaults(u, s), t.dispatchEvent(u)
			},
			bind: function(e, t, n, r) {
				return e.addEventListener ? e.addEventListener(t, n, r || !1) : e.attachEvent && e.attachEvent("on" + t, n), i
			},
			unbind: function(e, t, n, r) {
				return e.removeEventListener ? e.removeEventListener(t, n, r || !1) : e.detachEvent && e.detachEvent("on" + t, n), i
			},
			addClass: function(e, t) {
				if(void 0 === e.className) e.className = t;
				else if(e.className !== t) {
					var n = e.className.split(/ +/); - 1 == n.indexOf(t) && (n.push(t), e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
				}
				return i
			},
			removeClass: function(e, t) {
				if(t) {
					if(void 0 !== e.className)
						if(e.className === t) e.removeAttribute("class");
						else {
							var n = e.className.split(/ +/),
								r = n.indexOf(t); - 1 != r && (n.splice(r, 1), e.className = n.join(" "))
						}
				} else e.className = void 0;
				return i
			},
			hasClass: function(e, t) {
				return RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
			},
			getWidth: function(e) {
				return e = getComputedStyle(e), t(e["border-left-width"]) + t(e["border-right-width"]) + t(e["padding-left"]) + t(e["padding-right"]) + t(e.width)
			},
			getHeight: function(e) {
				return e = getComputedStyle(e), t(e["border-top-width"]) + t(e["border-bottom-width"]) + t(e["padding-top"]) + t(e["padding-bottom"]) + t(e.height)
			},
			getOffset: function(e) {
				var t = {
					left: 0,
					top: 0
				};
				if(e.offsetParent)
					do t.left += e.offsetLeft, t.top += e.offsetTop; while (e = e.offsetParent);
				return t
			},
			isActive: function(e) {
				return e === document.activeElement && (e.type || e.href)
			}
		};
	return i
}(dat.utils.common), dat.controllers.OptionController = function(e, t, n) {
	var r = function(e, i, s) {
		r.superclass.call(this, e, i);
		var o = this;
		this.__select = document.createElement("select");
		if(n.isArray(s)) {
			var u = {};
			n.each(s, function(e) {
				u[e] = e
			}), s = u
		}
		n.each(s, function(e, t) {
			var n = document.createElement("option");
			n.innerHTML = t, n.setAttribute("value", e), o.__select.appendChild(n)
		}), this.updateDisplay(), t.bind(this.__select, "change", function() {
			o.setValue(this.options[this.selectedIndex].value)
		}), this.domElement.appendChild(this.__select)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {
		setValue: function(e) {
			return e = r.superclass.prototype.setValue.call(this, e), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), e
		},
		updateDisplay: function() {
			return this.__select.value = this.getValue(), r.superclass.prototype.updateDisplay.call(this)
		}
	}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.NumberController = function(e, t) {
	var n = function(e, r, i) {
		n.superclass.call(this, e, r), i = i || {}, this.__min = i.min, this.__max = i.max, this.__step = i.step, t.isUndefined(this.__step) ? this.__impliedStep = 0 == this.initialValue ? 1 : Math.pow(10, Math.floor(Math.log(this.initialValue) / Math.LN10)) / 10 : this.__impliedStep = this.__step, e = this.__impliedStep, e = e.toString(), e = -1 < e.indexOf(".") ? e.length - e.indexOf(".") - 1 : 0, this.__precision = e
	};
	return n.superclass = e, t.extend(n.prototype, e.prototype, {
		setValue: function(e) {
			return void 0 !== this.__min && e < this.__min ? e = this.__min : void 0 !== this.__max && e > this.__max && (e = this.__max), void 0 !== this.__step && 0 != e % this.__step && (e = Math.round(e / this.__step) * this.__step), n.superclass.prototype.setValue.call(this, e)
		},
		min: function(e) {
			return this.__min = e, this
		},
		max: function(e) {
			return this.__max = e, this
		},
		step: function(e) {
			return this.__step = e, this
		}
	}), n
}(dat.controllers.Controller, dat.utils.common), dat.controllers.NumberControllerBox = function(e, t, n) {
	var r = function(e, i, s) {
		function o() {
			var e = parseFloat(l.__input.value);
			n.isNaN(e) || l.setValue(e)
		}

		function u(e) {
			var t = c - e.clientY;
			l.setValue(l.getValue() + t * l.__impliedStep), c = e.clientY
		}

		function f() {
			t.unbind(window, "mousemove", u), t.unbind(window, "mouseup", f)
		}
		this.__truncationSuspended = !1, r.superclass.call(this, e, i, s);
		var l = this,
			c;
		this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), t.bind(this.__input, "change", o), t.bind(this.__input, "blur", function() {
			o(), l.__onFinishChange && l.__onFinishChange.call(l, l.getValue())
		}), t.bind(this.__input, "mousedown", function(e) {
			t.bind(window, "mousemove", u), t.bind(window, "mouseup", f), c = e.clientY
		}), t.bind(this.__input, "keydown", function(e) {
			13 === e.keyCode && (l.__truncationSuspended = !0, this.blur(), l.__truncationSuspended = !1)
		}), this.updateDisplay(), this.domElement.appendChild(this.__input)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {
		updateDisplay: function() {
			var e = this.__input,
				t;
			if(this.__truncationSuspended) t = this.getValue();
			else {
				t = this.getValue();
				var n = Math.pow(10, this.__precision);
				t = Math.round(t * n) / n
			}
			return e.value = t, r.superclass.prototype.updateDisplay.call(this)
		}
	}), r
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.common), dat.controllers.NumberControllerSlider = function(e, t, n, r, i) {
	function s(e, t, n, r, i) {
		return r + (e - t) / (n - t) * (i - r)
	}
	var o = function(e, n, r, i, u) {
		function f(e) {
			e.preventDefault();
			var n = t.getOffset(h.__background),
				r = t.getWidth(h.__background);
			return h.setValue(s(e.clientX, n.left, n.left + r, h.__min, h.__max)), !1
		}

		function l() {
			t.unbind(window, "mousemove", f), t.unbind(window, "mouseup", l), h.__onFinishChange && h.__onFinishChange.call(h, h.getValue())
		}
		o.superclass.call(this, e, n, {
			min: r,
			max: i,
			step: u
		});
		var h = this;
		this.__background = document.createElement("div"), this.__foreground = document.createElement("div"), t.bind(this.__background, "mousedown", function(e) {
			t.bind(window, "mousemove", f), t.bind(window, "mouseup", l), f(e)
		}), t.addClass(this.__background, "slider"), t.addClass(this.__foreground, "slider-fg"), this.updateDisplay(), this.__background.appendChild(this.__foreground), this.domElement.appendChild(this.__background)
	};
	return o.superclass = e, o.useDefaultStyles = function() {
		n.inject(i)
	}, r.extend(o.prototype, e.prototype, {
		updateDisplay: function() {
			var e = (this.getValue() - this.__min) / (this.__max - this.__min);
			return this.__foreground.style.width = 100 * e + "%", o.superclass.prototype.updateDisplay.call(this)
		}
	}), o
}(dat.controllers.NumberController, dat.dom.dom, dat.utils.css, dat.utils.common, "/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}"), dat.controllers.FunctionController = function(e, t, n) {
	var r = function(e, n, i) {
		r.superclass.call(this, e, n);
		var s = this;
		this.__button = document.createElement("div"), this.__button.innerHTML = void 0 === i ? "Fire" : i, t.bind(this.__button, "click", function(e) {
			return e.preventDefault(), s.fire(), !1
		}), t.addClass(this.__button, "button"), this.domElement.appendChild(this.__button)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {
		fire: function() {
			this.__onChange && this.__onChange.call(this), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.getValue().call(this.object)
		}
	}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.BooleanController = function(e, t, n) {
	var r = function(e, n) {
		r.superclass.call(this, e, n);
		var i = this;
		this.__prev = this.getValue(), this.__checkbox = document.createElement("input"), this.__checkbox.setAttribute("type", "checkbox"), t.bind(this.__checkbox, "change", function() {
			i.setValue(!i.__prev)
		}, !1), this.domElement.appendChild(this.__checkbox), this.updateDisplay()
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {
		setValue: function(e) {
			return e = r.superclass.prototype.setValue.call(this, e), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), e
		},
		updateDisplay: function() {
			return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0) : this.__checkbox.checked = !1, r.superclass.prototype.updateDisplay.call(this)
		}
	}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.color.toString = function(e) {
	return function(t) {
		if(1 == t.a || e.isUndefined(t.a)) {
			for(t = t.hex.toString(16); 6 > t.length;) t = "0" + t;
			return "#" + t
		}
		return "rgba(" + Math.round(t.r) + "," + Math.round(t.g) + "," + Math.round(t.b) + "," + t.a + ")"
	}
}(dat.utils.common), dat.color.interpret = function(e, t) {
	var n, r, i = [{
		litmus: t.isString,
		conversions: {
			THREE_CHAR_HEX: {
				read: function(e) {
					return e = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i), null === e ? !1 : {
						space: "HEX",
						hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString())
					}
				},
				write: e
			},
			SIX_CHAR_HEX: {
				read: function(e) {
					return e = e.match(/^#([A-F0-9]{6})$/i), null === e ? !1 : {
						space: "HEX",
						hex: parseInt("0x" + e[1].toString())
					}
				},
				write: e
			},
			CSS_RGB: {
				read: function(e) {
					return e = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/), null === e ? !1 : {
						space: "RGB",
						r: parseFloat(e[1]),
						g: parseFloat(e[2]),
						b: parseFloat(e[3])
					}
				},
				write: e
			},
			CSS_RGBA: {
				read: function(e) {
					return e = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/), null === e ? !1 : {
						space: "RGB",
						r: parseFloat(e[1]),
						g: parseFloat(e[2]),
						b: parseFloat(e[3]),
						a: parseFloat(e[4])
					}
				},
				write: e
			}
		}
	}, {
		litmus: t.isNumber,
		conversions: {
			HEX: {
				read: function(e) {
					return {
						space: "HEX",
						hex: e,
						conversionName: "HEX"
					}
				},
				write: function(e) {
					return e.hex
				}
			}
		}
	}, {
		litmus: t.isArray,
		conversions: {
			RGB_ARRAY: {
				read: function(e) {
					return 3 != e.length ? !1 : {
						space: "RGB",
						r: e[0],
						g: e[1],
						b: e[2]
					}
				},
				write: function(e) {
					return [e.r, e.g, e.b]
				}
			},
			RGBA_ARRAY: {
				read: function(e) {
					return 4 != e.length ? !1 : {
						space: "RGB",
						r: e[0],
						g: e[1],
						b: e[2],
						a: e[3]
					}
				},
				write: function(e) {
					return [e.r, e.g, e.b, e.a]
				}
			}
		}
	}, {
		litmus: t.isObject,
		conversions: {
			RGBA_OBJ: {
				read: function(e) {
					return t.isNumber(e.r) && t.isNumber(e.g) && t.isNumber(e.b) && t.isNumber(e.a) ? {
						space: "RGB",
						r: e.r,
						g: e.g,
						b: e.b,
						a: e.a
					} : !1
				},
				write: function(e) {
					return {
						r: e.r,
						g: e.g,
						b: e.b,
						a: e.a
					}
				}
			},
			RGB_OBJ: {
				read: function(e) {
					return t.isNumber(e.r) && t.isNumber(e.g) && t.isNumber(e.b) ? {
						space: "RGB",
						r: e.r,
						g: e.g,
						b: e.b
					} : !1
				},
				write: function(e) {
					return {
						r: e.r,
						g: e.g,
						b: e.b
					}
				}
			},
			HSVA_OBJ: {
				read: function(e) {
					return t.isNumber(e.h) && t.isNumber(e.s) && t.isNumber(e.v) && t.isNumber(e.a) ? {
						space: "HSV",
						h: e.h,
						s: e.s,
						v: e.v,
						a: e.a
					} : !1
				},
				write: function(e) {
					return {
						h: e.h,
						s: e.s,
						v: e.v,
						a: e.a
					}
				}
			},
			HSV_OBJ: {
				read: function(e) {
					return t.isNumber(e.h) && t.isNumber(e.s) && t.isNumber(e.v) ? {
						space: "HSV",
						h: e.h,
						s: e.s,
						v: e.v
					} : !1
				},
				write: function(e) {
					return {
						h: e.h,
						s: e.s,
						v: e.v
					}
				}
			}
		}
	}];
	return function() {
		r = !1;
		var e = 1 < arguments.length ? t.toArray(arguments) : arguments[0];
		return t.each(i, function(i) {
			if(i.litmus(e)) return t.each(i.conversions, function(i, s) {
				n = i.read(e);
				if(!1 === r && !1 !== n) return r = n, n.conversionName = s, n.conversion = i, t.BREAK
			}), t.BREAK
		}), r
	}
}(dat.color.toString, dat.utils.common), dat.GUI = dat.gui.GUI = function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d) {
	function v(e, t, n, s) {
		if(void 0 === t[n]) throw Error("Object " + t + ' has no property "' + n + '"');
		s.color ? t = new l(t, n) : (t = [t, n].concat(s.factoryArgs), t = r.apply(e, t)), s.before instanceof i && (s.before = s.before.__li), y(e, t), p.addClass(t.domElement, "c"), n = document.createElement("span"), p.addClass(n, "property-name"), n.innerHTML = t.property;
		var o = document.createElement("div");
		return o.appendChild(n), o.appendChild(t.domElement), s = m(e, o, s.before), p.addClass(s, P.CLASS_CONTROLLER_ROW), p.addClass(s, typeof t.getValue()), g(e, s, t), e.__controllers.push(t), t
	}

	function m(e, t, n) {
		var r = document.createElement("li");
		return t && r.appendChild(t), n ? e.__ul.insertBefore(r, params.before) : e.__ul.appendChild(r), e.onResize(), r
	}

	function g(e, t, n) {
		n.__li = t, n.__gui = e, d.extend(n, {
			options: function(t) {
				if(1 < arguments.length) return n.remove(), v(e, n.object, n.property, {
					before: n.__li.nextElementSibling,
					factoryArgs: [d.toArray(arguments)]
				});
				if(d.isArray(t) || d.isObject(t)) return n.remove(), v(e, n.object, n.property, {
					before: n.__li.nextElementSibling,
					factoryArgs: [t]
				})
			},
			name: function(e) {
				return n.__li.firstElementChild.firstElementChild.innerHTML = e, n
			},
			listen: function() {
				return n.__gui.listen(n), n
			},
			remove: function() {
				return n.__gui.remove(n), n
			}
		});
		if(n instanceof a) {
			var r = new u(n.object, n.property, {
				min: n.__min,
				max: n.__max,
				step: n.__step
			});
			d.each(["updateDisplay", "onChange", "onFinishChange"], function(e) {
				var t = n[e],
					i = r[e];
				n[e] = r[e] = function() {
					var e = Array.prototype.slice.call(arguments);
					return t.apply(n, e), i.apply(r, e)
				}
			}), p.addClass(t, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
		} else if(n instanceof u) {
			var i = function(t) {
				return d.isNumber(n.__min) && d.isNumber(n.__max) ? (n.remove(), v(e, n.object, n.property, {
					before: n.__li.nextElementSibling,
					factoryArgs: [n.__min, n.__max, n.__step]
				})) : t
			};
			n.min = d.compose(i, n.min), n.max = d.compose(i, n.max)
		} else n instanceof s ? (p.bind(t, "click", function() {
			p.fakeEvent(n.__checkbox, "click")
		}), p.bind(n.__checkbox, "click", function(e) {
			e.stopPropagation()
		})) : n instanceof o ? (p.bind(t, "click", function() {
			p.fakeEvent(n.__button, "click")
		}), p.bind(t, "mouseover", function() {
			p.addClass(n.__button, "hover")
		}), p.bind(t, "mouseout", function() {
			p.removeClass(n.__button, "hover")
		})) : n instanceof l && (p.addClass(t, "color"), n.updateDisplay = d.compose(function(e) {
			return t.style.borderLeftColor = n.__color.toString(), e
		}, n.updateDisplay), n.updateDisplay());
		n.setValue = d.compose(function(t) {
			return e.getRoot().__preset_select && n.isModified() && T(e.getRoot(), !0), t
		}, n.setValue)
	}

	function y(e, t) {
		var n = e.getRoot(),
			r = n.__rememberedObjects.indexOf(t.object);
		if(-1 != r) {
			var i = n.__rememberedObjectIndecesToControllers[r];
			void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[r] = i), i[t.property] = t;
			if(n.load && n.load.remembered) {
				n = n.load.remembered;
				if(n[e.preset]) n = n[e.preset];
				else {
					if(!n[C]) return;
					n = n[C]
				}
				n[r] && void 0 !== n[r][t.property] && (r = n[r][t.property], t.initialValue = r, t.setValue(r))
			}
		}
	}

	function b(e) {
		var t = e.__save_row = document.createElement("li");
		p.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), p.addClass(t, "save-row");
		var n = document.createElement("span");
		n.innerHTML = "&nbsp;", p.addClass(n, "button gears");
		var r = document.createElement("span");
		r.innerHTML = "Save", p.addClass(r, "button"), p.addClass(r, "save");
		var i = document.createElement("span");
		i.innerHTML = "New", p.addClass(i, "button"), p.addClass(i, "save-as");
		var s = document.createElement("span");
		s.innerHTML = "Revert", p.addClass(s, "button"), p.addClass(s, "revert");
		var o = e.__preset_select = document.createElement("select");
		e.load && e.load.remembered ? d.each(e.load.remembered, function(t, n) {
			x(e, n, n == e.preset)
		}) : x(e, C, !1), p.bind(o, "change", function() {
			for(var t = 0; t < e.__preset_select.length; t++) e.__preset_select[t].innerHTML = e.__preset_select[t].value;
			e.preset = this.value
		}), t.appendChild(o), t.appendChild(n), t.appendChild(r), t.appendChild(i), t.appendChild(s);
		if(k) {
			var t = document.getElementById("dg-save-locally"),
				u = document.getElementById("dg-local-explain");
			t.style.display = "block", t = document.getElementById("dg-local-storage"), "true" === localStorage.getItem(document.location.href + ".isLocal") && t.setAttribute("checked", "checked");
			var a = function() {
				u.style.display = e.useLocalStorage ? "block" : "none"
			};
			a(), p.bind(t, "change", function() {
				e.useLocalStorage = !e.useLocalStorage, a()
			})
		}
		var f = document.getElementById("dg-new-constructor");
		p.bind(f, "keydown", function(e) {
			!e.metaKey || 67 !== e.which && 67 != e.keyCode || A.hide()
		}), p.bind(n, "click", function() {
			f.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), A.show(), f.focus(), f.select()
		}), p.bind(r, "click", function() {
			e.save()
		}), p.bind(i, "click", function() {
			var t = prompt("Enter a new preset name.");
			t && e.saveAs(t)
		}), p.bind(s, "click", function() {
			e.revert()
		})
	}

	function w(e) {
		function t(t) {
			return t.preventDefault(), i = t.clientX, p.addClass(e.__closeButton, P.CLASS_DRAG), p.bind(window, "mousemove", n), p.bind(window, "mouseup", r), !1
		}

		function n(t) {
			return t.preventDefault(), e.width += i - t.clientX, e.onResize(), i = t.clientX, !1
		}

		function r() {
			p.removeClass(e.__closeButton, P.CLASS_DRAG), p.unbind(window, "mousemove", n), p.unbind(window, "mouseup", r)
		}
		e.__resize_handle = document.createElement("div"), d.extend(e.__resize_handle.style, {
			width: "6px",
			marginLeft: "-3px",
			height: "200px",
			cursor: "ew-resize",
			position: "absolute"
		});
		var i;
		p.bind(e.__resize_handle, "mousedown", t), p.bind(e.__closeButton, "mousedown", t), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild)
	}

	function E(e, t) {
		e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px")
	}

	function S(e, t) {
		var n = {};
		return d.each(e.__rememberedObjects, function(r, i) {
			var s = {};
			d.each(e.__rememberedObjectIndecesToControllers[i], function(e, n) {
				s[n] = t ? e.initialValue : e.getValue()
			}), n[i] = s
		}), n
	}

	function x(e, t, n) {
		var r = document.createElement("option");
		r.innerHTML = t, r.value = t, e.__preset_select.appendChild(r), n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1)
	}

	function T(e, t) {
		var n = e.__preset_select[e.__preset_select.selectedIndex];
		n.innerHTML = t ? n.value + "*" : n.value
	}

	function N(e) {
		0 != e.length && c(function() {
			N(e)
		}), d.each(e, function(e) {
			e.updateDisplay()
		})
	}
	e.inject(n);
	var C = "Default",
		k;
	try {
		k = "localStorage" in window && null !== window.localStorage
	} catch(L) {
		k = !1
	}
	var A, O = !0,
		M, _ = !1,
		D = [],
		P = function(e) {
			function t() {
				localStorage.setItem(document.location.href + ".gui", JSON.stringify(r.getSaveObject()))
			}

			function n() {
				var e = r.getRoot();
				e.width += 1, d.defer(function() {
					e.width -= 1
				})
			}
			var r = this;
			this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), p.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], e = e || {}, e = d.defaults(e, {
				autoPlace: !0,
				width: P.DEFAULT_WIDTH
			}), e = d.defaults(e, {
				resizable: e.autoPlace,
				hideable: e.autoPlace
			}), d.isUndefined(e.load) ? e.load = {
				preset: C
			} : e.preset && (e.load.preset = e.preset), d.isUndefined(e.parent) && e.hideable && D.push(this), e.resizable = d.isUndefined(e.parent) && e.resizable, e.autoPlace && d.isUndefined(e.scrollable) && (e.scrollable = !0);
			var i = k && "true" === localStorage.getItem(document.location.href + ".isLocal");
			Object.defineProperties(this, {
				parent: {
					get: function() {
						return e.parent
					}
				},
				scrollable: {
					get: function() {
						return e.scrollable
					}
				},
				autoPlace: {
					get: function() {
						return e.autoPlace
					}
				},
				preset: {
					get: function() {
						return r.parent ? r.getRoot().preset : e.load.preset
					},
					set: function(t) {
						r.parent ? r.getRoot().preset = t : e.load.preset = t;
						for(t = 0; t < this.__preset_select.length; t++) this.__preset_select[t].value == this.preset && (this.__preset_select.selectedIndex = t);
						r.revert()
					}
				},
				width: {
					get: function() {
						return e.width
					},
					set: function(t) {
						e.width = t, E(r, t)
					}
				},
				name: {
					get: function() {
						return e.name
					},
					set: function(t) {
						e.name = t, o && (o.innerHTML = e.name)
					}
				},
				closed: {
					get: function() {
						return e.closed
					},
					set: function(t) {
						e.closed = t, e.closed ? p.addClass(r.__ul, P.CLASS_CLOSED) : p.removeClass(r.__ul, P.CLASS_CLOSED), this.onResize(), r.__closeButton && (r.__closeButton.innerHTML = t ? P.TEXT_OPEN : P.TEXT_CLOSED)
					}
				},
				load: {
					get: function() {
						return e.load
					}
				},
				useLocalStorage: {
					get: function() {
						return i
					},
					set: function(e) {
						k && ((i = e) ? p.bind(window, "unload", t) : p.unbind(window, "unload", t), localStorage.setItem(document.location.href + ".isLocal", e))
					}
				}
			});
			if(d.isUndefined(e.parent)) {
				e.closed = !1, p.addClass(this.domElement, P.CLASS_MAIN), p.makeSelectable(this.domElement, !1);
				if(k && i) {
					r.useLocalStorage = !0;
					var s = localStorage.getItem(document.location.href + ".gui");
					s && (e.load = JSON.parse(s))
				}
				this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = P.TEXT_CLOSED, p.addClass(this.__closeButton, P.CLASS_CLOSE_BUTTON), this.domElement.appendChild(this.__closeButton), p.bind(this.__closeButton, "click", function() {
					r.closed = !r.closed
				})
			} else {
				void 0 === e.closed && (e.closed = !0);
				var o = document.createTextNode(e.name);
				p.addClass(o, "controller-name"), s = m(r, o), p.addClass(this.__ul, P.CLASS_CLOSED), p.addClass(s, "title"), p.bind(s, "click", function(e) {
					return e.preventDefault(), r.closed = !r.closed, !1
				}), e.closed || (this.closed = !1)
			}
			e.autoPlace && (d.isUndefined(e.parent) && (O && (M = document.createElement("div"), p.addClass(M, "dg"), p.addClass(M, P.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(M), O = !1), M.appendChild(this.domElement), p.addClass(this.domElement, P.CLASS_AUTO_PLACE)), this.parent || E(r, e.width)), p.bind(window, "resize", function() {
				r.onResize()
			}), p.bind(this.__ul, "webkitTransitionEnd", function() {
				r.onResize()
			}), p.bind(this.__ul, "transitionend", function() {
				r.onResize()
			}), p.bind(this.__ul, "oTransitionEnd", function() {
				r.onResize()
			}), this.onResize(), e.resizable && w(this), r.getRoot(), e.parent || n()
		};
	return P.toggleHide = function() {
		_ = !_, d.each(D, function(e) {
			e.domElement.style.zIndex = _ ? -999 : 999, e.domElement.style.opacity = _ ? 0 : 1
		})
	}, P.CLASS_AUTO_PLACE = "a", P.CLASS_AUTO_PLACE_CONTAINER = "ac", P.CLASS_MAIN = "main", P.CLASS_CONTROLLER_ROW = "cr", P.CLASS_TOO_TALL = "taller-than-window", P.CLASS_CLOSED = "closed", P.CLASS_CLOSE_BUTTON = "close-button", P.CLASS_DRAG = "drag", P.DEFAULT_WIDTH = 245, P.TEXT_CLOSED = "Close Controls", P.TEXT_OPEN = "Open Controls", p.bind(window, "keydown", function(e) {
		"text" === document.activeElement.type || 72 !== e.which && 72 != e.keyCode || P.toggleHide()
	}, !1), d.extend(P.prototype, {
		add: function(e, t) {
			return v(this, e, t, {
				factoryArgs: Array.prototype.slice.call(arguments, 2)
			})
		},
		addColor: function(e, t) {
			return v(this, e, t, {
				color: !0
			})
		},
		remove: function(e) {
			this.__ul.removeChild(e.__li), this.__controllers.slice(this.__controllers.indexOf(e), 1);
			var t = this;
			d.defer(function() {
				t.onResize()
			})
		},
		destroy: function() {
			this.autoPlace && M.removeChild(this.domElement)
		},
		addFolder: function(e) {
			if(void 0 !== this.__folders[e]) throw Error('You already have a folder in this GUI by the name "' + e + '"');
			var t = {
				name: e,
				parent: this
			};
			return t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]), t = new P(t), this.__folders[e] = t, e = m(this, t.domElement), p.addClass(e, "folder"), t
		},
		open: function() {
			this.closed = !1
		},
		close: function() {
			this.closed = !0
		},
		onResize: function() {
			var e = this.getRoot();
			if(e.scrollable) {
				var t = p.getOffset(e.__ul).top,
					n = 0;
				d.each(e.__ul.childNodes, function(t) {
					e.autoPlace && t === e.__save_row || (n += p.getHeight(t))
				}), window.innerHeight - t - 20 < n ? (p.addClass(e.domElement, P.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - 20 + "px") : (p.removeClass(e.domElement, P.CLASS_TOO_TALL), e.__ul.style.height = "auto")
			}
			e.__resize_handle && d.defer(function() {
				e.__resize_handle.style.height = e.__ul.offsetHeight + "px"
			}), e.__closeButton && (e.__closeButton.style.width = e.width + "px")
		},
		remember: function() {
			d.isUndefined(A) && (A = new h, A.domElement.innerHTML = t);
			if(this.parent) throw Error("You can only call remember on a top level GUI.");
			var e = this;
			d.each(Array.prototype.slice.call(arguments), function(t) {
				0 == e.__rememberedObjects.length && b(e), -1 == e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t)
			}), this.autoPlace && E(this, this.width)
		},
		getRoot: function() {
			for(var e = this; e.parent;) e = e.parent;
			return e
		},
		getSaveObject: function() {
			var e = this.load;
			return e.closed = this.closed, 0 < this.__rememberedObjects.length && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = S(this)), e.folders = {}, d.each(this.__folders, function(t, n) {
				e.folders[n] = t.getSaveObject()
			}), e
		},
		save: function() {
			this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = S(this), T(this, !1)
		},
		saveAs: function(e) {
			this.load.remembered || (this.load.remembered = {}, this.load.remembered[C] = S(this, !0)), this.load.remembered[e] = S(this), this.preset = e, x(this, e, !0)
		},
		revert: function(e) {
			d.each(this.__controllers, function(t) {
				this.getRoot().load.remembered ? y(e || this.getRoot(), t) : t.setValue(t.initialValue)
			}, this), d.each(this.__folders, function(e) {
				e.revert(e)
			}), e || T(this.getRoot(), !1)
		},
		listen: function(e) {
			var t = 0 == this.__listening.length;
			this.__listening.push(e), t && N(this.__listening)
		}
	}), P
}(dat.utils.css, '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>', ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid rgba(0, 0, 0, 0); }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name,\n  .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2fa1d6; }\n    .dg .cr.number input[type=text] {\n      color: #2fa1d6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover, .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2fa1d6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n", dat.controllers.factory = function(e, t, n, r, i, s, o) {
	return function(u, l, h, v) {
		var m = u[l];
		if(o.isArray(h) || o.isObject(h)) return new e(u, l, h);
		if(o.isNumber(m)) return o.isNumber(h) && o.isNumber(v) ? new n(u, l, h, v) : new t(u, l, {
			min: h,
			max: v
		});
		if(o.isString(m)) return new r(u, l);
		if(o.isFunction(m)) return new i(u, l, "");
		if(o.isBoolean(m)) return new s(u, l)
	}
}(dat.controllers.OptionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.StringController = function(e, t, n) {
	var r = function(e, n) {
		function i() {
			s.setValue(s.__input.value)
		}
		r.superclass.call(this, e, n);
		var s = this;
		this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), t.bind(this.__input, "keyup", i), t.bind(this.__input, "change", i), t.bind(this.__input, "blur", function() {
			s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
		}), t.bind(this.__input, "keydown", function(e) {
			13 === e.keyCode && this.blur()
		}), this.updateDisplay(), this.domElement.appendChild(this.__input)
	};
	return r.superclass = e, n.extend(r.prototype, e.prototype, {
		updateDisplay: function() {
			return t.isActive(this.__input) || (this.__input.value = this.getValue()), r.superclass.prototype.updateDisplay.call(this)
		}
	}), r
}(dat.controllers.Controller, dat.dom.dom, dat.utils.common), dat.controllers.FunctionController, dat.controllers.BooleanController, dat.utils.common), dat.controllers.Controller, dat.controllers.BooleanController, dat.controllers.FunctionController, dat.controllers.NumberControllerBox, dat.controllers.NumberControllerSlider, dat.controllers.OptionController, dat.controllers.ColorController = function(e, t, n, r, i) {
	function s(e, t, n, r) {
		e.style.background = "", i.each(a, function(i) {
			e.style.cssText += "background: " + i + "linear-gradient(" + t + ", " + n + " 0%, " + r + " 100%); "
		})
	}

	function o(e) {
		e.style.background = "", e.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", e.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
	}
	var u = function(e, a) {
		function l(e) {
			g(e), t.bind(window, "mousemove", g), t.bind(window, "mouseup", h)
		}

		function h() {
			t.unbind(window, "mousemove", g), t.unbind(window, "mouseup", h)
		}

		function v() {
			var e = r(this.value);
			!1 !== e ? (w.__color.__state = e, w.setValue(w.__color.toOriginal())) : this.value = w.__color.toString()
		}

		function m() {
			t.unbind(window, "mousemove", y), t.unbind(window, "mouseup", m)
		}

		function g(e) {
			e.preventDefault();
			var n = t.getWidth(w.__saturation_field),
				r = t.getOffset(w.__saturation_field),
				i = (e.clientX - r.left + document.body.scrollLeft) / n;
			return e = 1 - (e.clientY - r.top + document.body.scrollTop) / n, 1 < e ? e = 1 : 0 > e && (e = 0), 1 < i ? i = 1 : 0 > i && (i = 0), w.__color.v = e, w.__color.s = i, w.setValue(w.__color.toOriginal()), !1
		}

		function y(e) {
			e.preventDefault();
			var n = t.getHeight(w.__hue_field),
				r = t.getOffset(w.__hue_field);
			return e = 1 - (e.clientY - r.top + document.body.scrollTop) / n, 1 < e ? e = 1 : 0 > e && (e = 0), w.__color.h = 360 * e, w.setValue(w.__color.toOriginal()), !1
		}
		u.superclass.call(this, e, a), this.__color = new n(this.getValue()), this.__temp = new n(0);
		var w = this;
		this.domElement = document.createElement("div"), t.makeSelectable(this.domElement, !1), this.__selector = document.createElement("div"), this.__selector.className = "selector", this.__saturation_field = document.createElement("div"), this.__saturation_field.className = "saturation-field", this.__field_knob = document.createElement("div"), this.__field_knob.className = "field-knob", this.__field_knob_border = "2px solid ", this.__hue_knob = document.createElement("div"), this.__hue_knob.className = "hue-knob", this.__hue_field = document.createElement("div"), this.__hue_field.className = "hue-field", this.__input = document.createElement("input"), this.__input.type = "text", this.__input_textShadow = "0 1px 1px ", t.bind(this.__input, "keydown", function(e) {
			13 === e.keyCode && v.call(this)
		}), t.bind(this.__input, "blur", v), t.bind(this.__selector, "mousedown", function(e) {
			t.addClass(this, "drag").bind(window, "mouseup", function(e) {
				t.removeClass(w.__selector, "drag")
			})
		});
		var E = document.createElement("div");
		i.extend(this.__selector.style, {
			width: "122px",
			height: "102px",
			padding: "3px",
			backgroundColor: "#222",
			boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
		}), i.extend(this.__field_knob.style, {
			position: "absolute",
			width: "12px",
			height: "12px",
			border: this.__field_knob_border + (.5 > this.__color.v ? "#fff" : "#000"),
			boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
			borderRadius: "12px",
			zIndex: 1
		}), i.extend(this.__hue_knob.style, {
			position: "absolute",
			width: "15px",
			height: "2px",
			borderRight: "4px solid #fff",
			zIndex: 1
		}), i.extend(this.__saturation_field.style, {
			width: "100px",
			height: "100px",
			border: "1px solid #555",
			marginRight: "3px",
			display: "inline-block",
			cursor: "pointer"
		}), i.extend(E.style, {
			width: "100%",
			height: "100%",
			background: "none"
		}), s(E, "top", "rgba(0,0,0,0)", "#000"), i.extend(this.__hue_field.style, {
			width: "15px",
			height: "100px",
			display: "inline-block",
			border: "1px solid #555",
			cursor: "ns-resize"
		}), o(this.__hue_field), i.extend(this.__input.style, {
			outline: "none",
			textAlign: "center",
			color: "#fff",
			border: 0,
			fontWeight: "bold",
			textShadow: this.__input_textShadow + "rgba(0,0,0,0.7)"
		}), t.bind(this.__saturation_field, "mousedown", l), t.bind(this.__field_knob, "mousedown", l), t.bind(this.__hue_field, "mousedown", function(e) {
			y(e), t.bind(window, "mousemove", y), t.bind(window, "mouseup", m)
		}), this.__saturation_field.appendChild(E), this.__selector.appendChild(this.__field_knob), this.__selector.appendChild(this.__saturation_field), this.__selector.appendChild(this.__hue_field), this.__hue_field.appendChild(this.__hue_knob), this.domElement.appendChild(this.__input), this.domElement.appendChild(this.__selector), this.updateDisplay()
	};
	u.superclass = e, i.extend(u.prototype, e.prototype, {
		updateDisplay: function() {
			var e = r(this.getValue());
			if(!1 !== e) {
				var t = !1;
				i.each(n.COMPONENTS, function(n) {
					if(!i.isUndefined(e[n]) && !i.isUndefined(this.__color.__state[n]) && e[n] !== this.__color.__state[n]) return t = !0, {}
				}, this), t && i.extend(this.__color.__state, e)
			}
			i.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
			var o = .5 > this.__color.v || .5 < this.__color.s ? 255 : 0,
				u = 255 - o;
			i.extend(this.__field_knob.style, {
				marginLeft: 100 * this.__color.s - 7 + "px",
				marginTop: 100 * (1 - this.__color.v) - 7 + "px",
				backgroundColor: this.__temp.toString(),
				border: this.__field_knob_border + "rgb(" + o + "," + o + "," + o + ")"
			}), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, s(this.__saturation_field, "left", "#fff", this.__temp.toString()), i.extend(this.__input.style, {
				backgroundColor: this.__input.value = this.__color.toString(),
				color: "rgb(" + o + "," + o + "," + o + ")",
				textShadow: this.__input_textShadow + "rgba(" + u + "," + u + "," + u + ",.7)"
			})
		}
	});
	var a = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
	return u
}(dat.controllers.Controller, dat.dom.dom, dat.color.Color = function(e, t, n, r) {
	function i(e, t, n) {
		Object.defineProperty(e, t, {
			get: function() {
				return "RGB" === this.__state.space ? this.__state[t] : (o(this, t, n), this.__state[t])
			},
			set: function(e) {
				"RGB" !== this.__state.space && (o(this, t, n), this.__state.space = "RGB"), this.__state[t] = e
			}
		})
	}

	function s(e, t) {
		Object.defineProperty(e, t, {
			get: function() {
				return "HSV" === this.__state.space ? this.__state[t] : (u(this), this.__state[t])
			},
			set: function(e) {
				"HSV" !== this.__state.space && (u(this), this.__state.space = "HSV"), this.__state[t] = e
			}
		})
	}

	function o(e, n, i) {
		if("HEX" === e.__state.space) e.__state[n] = t.component_from_hex(e.__state.hex, i);
		else {
			if("HSV" !== e.__state.space) throw "Corrupted color state";
			r.extend(e.__state, t.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v))
		}
	}

	function u(e) {
		var n = t.rgb_to_hsv(e.r, e.g, e.b);
		r.extend(e.__state, {
			s: n.s,
			v: n.v
		}), r.isNaN(n.h) ? r.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = n.h
	}
	var a = function() {
		this.__state = e.apply(this, arguments);
		if(!1 === this.__state) throw "Failed to interpret color arguments";
		this.__state.a = this.__state.a || 1
	};
	return a.COMPONENTS = "r g b h s v hex a".split(" "), r.extend(a.prototype, {
		toString: function() {
			return n(this)
		},
		toOriginal: function() {
			return this.__state.conversion.write(this)
		}
	}), i(a.prototype, "r", 2), i(a.prototype, "g", 1), i(a.prototype, "b", 0), s(a.prototype, "h"), s(a.prototype, "s"), s(a.prototype, "v"), Object.defineProperty(a.prototype, "a", {
		get: function() {
			return this.__state.a
		},
		set: function(e) {
			this.__state.a = e
		}
	}), Object.defineProperty(a.prototype, "hex", {
		get: function() {
			return "HEX" !== !this.__state.space && (this.__state.hex = t.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
		},
		set: function(e) {
			this.__state.space = "HEX", this.__state.hex = e
		}
	}), a
}(dat.color.interpret, dat.color.math = function() {
	var e;
	return {
		hsv_to_rgb: function(e, t, n) {
			var r = e / 60 - Math.floor(e / 60),
				i = n * (1 - t),
				s = n * (1 - r * t);
			return t = n * (1 - (1 - r) * t), e = [
				[n, t, i],
				[s, n, i],
				[i, n, t],
				[i, s, n],
				[t, i, n],
				[n, i, s]
			][Math.floor(e / 60) % 6], {
				r: 255 * e[0],
				g: 255 * e[1],
				b: 255 * e[2]
			}
		},
		rgb_to_hsv: function(e, t, n) {
			var r = Math.min(e, t, n),
				i = Math.max(e, t, n),
				r = i - r;
			return 0 == i ? {
				h: NaN,
				s: 0,
				v: 0
			} : (e = (e == i ? (t - n) / r : t == i ? 2 + (n - e) / r : 4 + (e - t) / r) / 6, 0 > e && (e += 1), {
				h: 360 * e,
				s: r / i,
				v: i / 255
			})
		},
		rgb_to_hex: function(e, t, n) {
			return e = this.hex_with_component(0, 2, e), e = this.hex_with_component(e, 1, t), e = this.hex_with_component(e, 0, n)
		},
		component_from_hex: function(e, t) {
			return e >> 8 * t & 255
		},
		hex_with_component: function(t, n, r) {
			return r << (e = 8 * n) | t & ~(255 << e)
		}
	}
}(), dat.color.toString, dat.utils.common), dat.color.interpret, dat.utils.common), dat.utils.requestAnimationFrame = function() {
	return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e, t) {
		window.setTimeout(e, 1e3 / 60)
	}
}(), dat.dom.CenteredDiv = function(e, t) {
	var n = function() {
		this.backgroundElement = document.createElement("div"), t.extend(this.backgroundElement.style, {
			backgroundColor: "rgba(0,0,0,0.8)",
			top: 0,
			left: 0,
			display: "none",
			zIndex: "1000",
			opacity: 0,
			WebkitTransition: "opacity 0.2s linear"
		}), e.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), t.extend(this.domElement.style, {
			position: "fixed",
			display: "none",
			zIndex: "1001",
			opacity: 0,
			WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear"
		}), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
		var n = this;
		e.bind(this.backgroundElement, "click", function() {
			n.hide()
		})
	};
	return n.prototype.show = function() {
		var e = this;
		this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), t.defer(function() {
			e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)"
		})
	}, n.prototype.hide = function() {
		var t = this,
			n = function() {
				t.domElement.style.display = "none", t.backgroundElement.style.display = "none", e.unbind(t.domElement, "webkitTransitionEnd", n), e.unbind(t.domElement, "transitionend", n), e.unbind(t.domElement, "oTransitionEnd", n)
			};
		e.bind(this.domElement, "webkitTransitionEnd", n), e.bind(this.domElement, "transitionend", n), e.bind(this.domElement, "oTransitionEnd", n), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
	}, n.prototype.layout = function() {
		this.domElement.style.left = window.innerWidth / 2 - e.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - e.getHeight(this.domElement) / 2 + "px"
	}, n
}(dat.dom.dom, dat.utils.common), dat.dom.dom, dat.utils.common), define("datgui", function() {});
var THREE = {
	REVISION: "68"
};
"object" == typeof module && (module.exports = THREE), THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = function() {}, THREE.CubeReflectionMapping = function() {}, THREE.CubeRefractionMapping = function() {}, THREE.SphericalReflectionMapping = function() {}, THREE.SphericalRefractionMapping = function() {}, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.Color = function(e) {
		return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(e)
	}, THREE.Color.prototype = {
		constructor: THREE.Color,
		r: 1,
		g: 1,
		b: 1,
		set: function(e) {
			return e instanceof THREE.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
		},
		setHex: function(e) {
			return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this
		},
		setRGB: function(e, t, n) {
			return this.r = e, this.g = t, this.b = n, this
		},
		setHSL: function(e, t, n) {
			if(0 === t) this.r = this.g = this.b = n;
			else {
				var r = function(e, t, n) {
					return 0 > n && (n += 1), 1 < n && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : .5 > n ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
				};
				t = .5 >= n ? n * (1 + t) : n + t - n * t, n = 2 * n - t, this.r = r(n, t, e + 1 / 3), this.g = r(n, t, e), this.b = r(n, t, e - 1 / 3)
			}
			return this
		},
		setStyle: function(e) {
			if(/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e)) return e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e), this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this;
			if(/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e)) return e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e), this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this;
			if(/^\#([0-9a-f]{6})$/i.test(e)) return e = /^\#([0-9a-f]{6})$/i.exec(e), this.setHex(parseInt(e[1], 16)), this;
			if(/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) return e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e), this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this;
			if(/^(\w+)$/i.test(e)) return this.setHex(THREE.ColorKeywords[e]), this
		},
		copy: function(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this
		},
		copyGammaToLinear: function(e) {
			return this.r = e.r * e.r, this.g = e.g * e.g, this.b = e.b * e.b, this
		},
		copyLinearToGamma: function(e) {
			return this.r = Math.sqrt(e.r), this.g = Math.sqrt(e.g), this.b = Math.sqrt(e.b), this
		},
		convertGammaToLinear: function() {
			var e = this.r,
				t = this.g,
				n = this.b;
			return this.r = e * e, this.g = t * t, this.b = n * n, this
		},
		convertLinearToGamma: function() {
			return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
		},
		getHex: function() {
			return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
		},
		getHexString: function() {
			return("000000" + this.getHex().toString(16)).slice(-6)
		},
		getHSL: function(e) {
			e = e || {
				h: 0,
				s: 0,
				l: 0
			};
			var t = this.r,
				n = this.g,
				r = this.b,
				i = Math.max(t, n, r),
				s = Math.min(t, n, r),
				o, u = (s + i) / 2;
			if(s === i) s = o = 0;
			else {
				var a = i - s,
					s = .5 >= u ? a / (i + s) : a / (2 - i - s);
				switch(i) {
					case t:
						o = (n - r) / a + (n < r ? 6 : 0);
						break;
					case n:
						o = (r - t) / a + 2;
						break;
					case r:
						o = (t - n) / a + 4
				}
				o /= 6
			}
			return e.h = o, e.s = s, e.l = u, e
		},
		getStyle: function() {
			return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
		},
		offsetHSL: function(e, t, n) {
			var r = this.getHSL();
			return r.h += e, r.s += t, r.l += n, this.setHSL(r.h, r.s, r.l), this
		},
		add: function(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this
		},
		addColors: function(e, t) {
			return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
		},
		addScalar: function(e) {
			return this.r += e, this.g += e, this.b += e, this
		},
		multiply: function(e) {
			return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
		},
		multiplyScalar: function(e) {
			return this.r *= e, this.g *= e, this.b *= e, this
		},
		lerp: function(e, t) {
			return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
		},
		equals: function(e) {
			return e.r === this.r && e.g === this.g && e.b === this.b
		},
		fromArray: function(e) {
			return this.r = e[0], this.g = e[1], this.b = e[2], this
		},
		toArray: function() {
			return [this.r, this.g, this.b]
		},
		clone: function() {
			return(new THREE.Color).setRGB(this.r, this.g, this.b)
		}
	}, THREE.ColorKeywords = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	}, THREE.Quaternion = function(e, t, n, r) {
		this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
	}, THREE.Quaternion.prototype = {
		constructor: THREE.Quaternion,
		_x: 0,
		_y: 0,
		_z: 0,
		_w: 0,
		get x() {
			return this._x
		},
		set x(e) {
			this._x = e, this.onChangeCallback()
		},
		get y() {
			return this._y
		},
		set y(e) {
			this._y = e, this.onChangeCallback()
		},
		get z() {
			return this._z
		},
		set z(e) {
			this._z = e, this.onChangeCallback()
		},
		get w() {
			return this._w
		},
		set w(e) {
			this._w = e, this.onChangeCallback()
		},
		set: function(e, t, n, r) {
			return this._x = e, this._y = t, this._z = n, this._w = r, this.onChangeCallback(), this
		},
		copy: function(e) {
			return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
		},
		setFromEuler: function(e, t) {
			if(0 == e instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
			var n = Math.cos(e._x / 2),
				r = Math.cos(e._y / 2),
				i = Math.cos(e._z / 2),
				s = Math.sin(e._x / 2),
				o = Math.sin(e._y / 2),
				u = Math.sin(e._z / 2);
			return "XYZ" === e.order ? (this._x = s * r * i + n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i - s * o * u) : "YXZ" === e.order ? (this._x = s * r * i + n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i + s * o * u) : "ZXY" === e.order ? (this._x = s * r * i - n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i - s * o * u) : "ZYX" === e.order ? (this._x = s * r * i - n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i + s * o * u) : "YZX" === e.order ? (this._x = s * r * i + n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i - s * o * u) : "XZY" === e.order && (this._x = s * r * i - n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i + s * o * u), !1 !== t && this.onChangeCallback(), this
		},
		setFromAxisAngle: function(e, t) {
			var n = t / 2,
				r = Math.sin(n);
			return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
		},
		setFromRotationMatrix: function(e) {
			var t = e.elements,
				n = t[0];
			e = t[4];
			var r = t[8],
				i = t[1],
				s = t[5],
				o = t[9],
				u = t[2],
				a = t[6],
				t = t[10],
				f = n + s + t;
			return 0 < f ? (n = .5 / Math.sqrt(f + 1), this._w = .25 / n, this._x = (a - o) * n, this._y = (r - u) * n, this._z = (i - e) * n) : n > s && n > t ? (n = 2 * Math.sqrt(1 + n - s - t), this._w = (a - o) / n, this._x = .25 * n, this._y = (e + i) / n, this._z = (r + u) / n) : s > t ? (n = 2 * Math.sqrt(1 + s - n - t), this._w = (r - u) / n, this._x = (e + i) / n, this._y = .25 * n, this._z = (o + a) / n) : (n = 2 * Math.sqrt(1 + t - n - s), this._w = (i - e) / n, this._x = (r + u) / n, this._y = (o + a) / n, this._z = .25 * n), this.onChangeCallback(), this
		},
		setFromUnitVectors: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector3), t = n.dot(r) + 1, 1e-6 > t ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, r), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize(), this
			}
		}(),
		inverse: function() {
			return this.conjugate().normalize(), this
		},
		conjugate: function() {
			return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
		},
		dot: function(e) {
			return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
		},
		lengthSq: function() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
		},
		length: function() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
		},
		normalize: function() {
			var e = this.length();
			return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
		},
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
		},
		multiplyQuaternions: function(e, t) {
			var n = e._x,
				r = e._y,
				i = e._z,
				s = e._w,
				o = t._x,
				u = t._y,
				a = t._z,
				f = t._w;
			return this._x = n * f + s * o + r * a - i * u, this._y = r * f + s * u + i * o - n * a, this._z = i * f + s * a + n * u - r * o, this._w = s * f - n * o - r * u - i * a, this.onChangeCallback(), this
		},
		multiplyVector3: function(e) {
			return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
		},
		slerp: function(e, t) {
			var n = this._x,
				r = this._y,
				i = this._z,
				s = this._w,
				o = s * e._w + n * e._x + r * e._y + i * e._z;
			0 > o ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e);
			if(1 <= o) return this._w = s, this._x = n, this._y = r, this._z = i, this;
			var u = Math.acos(o),
				a = Math.sqrt(1 - o * o);
			return .001 > Math.abs(a) ? (this._w = .5 * (s + this._w), this._x = .5 * (n + this._x), this._y = .5 * (r + this._y), this._z = .5 * (i + this._z), this) : (o = Math.sin((1 - t) * u) / a, u = Math.sin(t * u) / a, this._w = s * o + this._w * u, this._x = n * o + this._x * u, this._y = r * o + this._y * u, this._z = i * o + this._z * u, this.onChangeCallback(), this)
		},
		equals: function(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
		},
		fromArray: function(e) {
			return this._x = e[0], this._y = e[1], this._z = e[2], this._w = e[3], this.onChangeCallback(), this
		},
		toArray: function() {
			return [this._x, this._y, this._z, this._w]
		},
		onChange: function(e) {
			return this.onChangeCallback = e, this
		},
		onChangeCallback: function() {},
		clone: function() {
			return new THREE.Quaternion(this._x, this._y, this._z, this._w)
		}
	}, THREE.Quaternion.slerp = function(e, t, n, r) {
		return n.copy(e).slerp(t, r)
	}, THREE.Vector2 = function(e, t) {
		this.x = e || 0, this.y = t || 0
	}, THREE.Vector2.prototype = {
		constructor: THREE.Vector2,
		set: function(e, t) {
			return this.x = e, this.y = t, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setComponent: function(e, t) {
			switch(e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		getComponent: function(e) {
			switch(e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this
		},
		multiply: function(e) {
			return this.x *= e.x, this.y *= e.y, this
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this
		},
		divide: function(e) {
			return this.x /= e.x, this.y /= e.y, this
		},
		divideScalar: function(e) {
			return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e) : this.y = this.x = 0, this
		},
		min: function(e) {
			return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this
		},
		max: function(e) {
			return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this
		},
		clamp: function(e, t) {
			return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this
		},
		clampScalar: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector2, t = new THREE.Vector2), e.set(n, n), t.set(r, r), this.clamp(e, t)
			}
		}(),
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
		},
		negate: function() {
			return this.x = -this.x, this.y = -this.y, this
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		distanceTo: function(e) {
			return Math.sqrt(this.distanceToSquared(e))
		},
		distanceToSquared: function(e) {
			var t = this.x - e.x;
			return e = this.y - e.y, t * t + e * e
		},
		setLength: function(e) {
			var t = this.length();
			return 0 !== t && e !== t && this.multiplyScalar(e / t), this
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y
		},
		fromArray: function(e) {
			return this.x = e[0], this.y = e[1], this
		},
		toArray: function() {
			return [this.x, this.y]
		},
		clone: function() {
			return new THREE.Vector2(this.x, this.y)
		}
	}, THREE.Vector3 = function(e, t, n) {
		this.x = e || 0, this.y = t || 0, this.z = n || 0
	}, THREE.Vector3.prototype = {
		constructor: THREE.Vector3,
		set: function(e, t, n) {
			return this.x = e, this.y = t, this.z = n, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setZ: function(e) {
			return this.z = e, this
		},
		setComponent: function(e, t) {
			switch(e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		getComponent: function(e) {
			switch(e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this.z += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
		},
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		},
		multiplyVectors: function(e, t) {
			return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
		},
		applyEuler: function() {
			var e;
			return function(t) {
				return 0 == t instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromEuler(t)), this
			}
		}(),
		applyAxisAngle: function() {
			var e;
			return function(t, n) {
				return void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromAxisAngle(t, n)), this
			}
		}(),
		applyMatrix3: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			return e = e.elements, this.x = e[0] * t + e[3] * n + e[6] * r, this.y = e[1] * t + e[4] * n + e[7] * r, this.z = e[2] * t + e[5] * n + e[8] * r, this
		},
		applyMatrix4: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12], this.y = e[1] * t + e[5] * n + e[9] * r + e[13], this.z = e[2] * t + e[6] * n + e[10] * r + e[14], this
		},
		applyProjection: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			e = e.elements;
			var i = 1 / (e[3] * t + e[7] * n + e[11] * r + e[15]);
			return this.x = (e[0] * t + e[4] * n + e[8] * r + e[12]) * i, this.y = (e[1] * t + e[5] * n + e[9] * r + e[13]) * i, this.z = (e[2] * t + e[6] * n + e[10] * r + e[14]) * i, this
		},
		applyQuaternion: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z,
				i = e.x,
				s = e.y,
				o = e.z;
			e = e.w;
			var u = e * t + s * r - o * n,
				a = e * n + o * t - i * r,
				f = e * r + i * n - s * t,
				t = -i * t - s * n - o * r;
			return this.x = u * e + t * -i + a * -o - f * -s, this.y = a * e + t * -s + f * -i - u * -o, this.z = f * e + t * -o + u * -s - a * -i, this
		},
		transformDirection: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r, this.y = e[1] * t + e[5] * n + e[9] * r, this.z = e[2] * t + e[6] * n + e[10] * r, this.normalize(), this
		},
		divide: function(e) {
			return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
		},
		divideScalar: function(e) {
			return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0, this
		},
		min: function(e) {
			return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this
		},
		max: function(e) {
			return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this
		},
		clamp: function(e, t) {
			return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this
		},
		clampScalar: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector3, t = new THREE.Vector3), e.set(n, n, n), t.set(r, r, r), this.clamp(e, t)
			}
		}(),
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
		},
		negate: function() {
			return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		},
		lengthManhattan: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		setLength: function(e) {
			var t = this.length();
			return 0 !== t && e !== t && this.multiplyScalar(e / t), this
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
		},
		cross: function(e, t) {
			if(void 0 !== t) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
			var n = this.x,
				r = this.y,
				i = this.z;
			return this.x = r * e.z - i * e.y, this.y = i * e.x - n * e.z, this.z = n * e.y - r * e.x, this
		},
		crossVectors: function(e, t) {
			var n = e.x,
				r = e.y,
				i = e.z,
				s = t.x,
				o = t.y,
				u = t.z;
			return this.x = r * u - i * o, this.y = i * s - n * u, this.z = n * o - r * s, this
		},
		projectOnVector: function() {
			var e, t;
			return function(n) {
				return void 0 === e && (e = new THREE.Vector3), e.copy(n).normalize(), t = this.dot(e), this.copy(e).multiplyScalar(t)
			}
		}(),
		projectOnPlane: function() {
			var e;
			return function(t) {
				return void 0 === e && (e = new THREE.Vector3), e.copy(this).projectOnVector(t), this.sub(e)
			}
		}(),
		reflect: function() {
			var e;
			return function(t) {
				return void 0 === e && (e = new THREE.Vector3), this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
			}
		}(),
		angleTo: function(e) {
			return e = this.dot(e) / (this.length() * e.length()), Math.acos(THREE.Math.clamp(e, -1, 1))
		},
		distanceTo: function(e) {
			return Math.sqrt(this.distanceToSquared(e))
		},
		distanceToSquared: function(e) {
			var t = this.x - e.x,
				n = this.y - e.y;
			return e = this.z - e.z, t * t + n * n + e * e
		},
		setEulerFromRotationMatrix: function(e, t) {
			console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
		},
		setEulerFromQuaternion: function(e, t) {
			console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
		},
		getPositionFromMatrix: function(e) {
			return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
		},
		getScaleFromMatrix: function(e) {
			return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
		},
		getColumnFromMatrix: function(e, t) {
			return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
		},
		setFromMatrixPosition: function(e) {
			return this.x = e.elements[12], this.y = e.elements[13], this.z = e.elements[14], this
		},
		setFromMatrixScale: function(e) {
			var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
				n = this.set(e.elements[4], e.elements[5], e.elements[6]).length();
			return e = this.set(e.elements[8], e.elements[9], e.elements[10]).length(), this.x = t, this.y = n, this.z = e, this
		},
		setFromMatrixColumn: function(e, t) {
			var n = 4 * e,
				r = t.elements;
			return this.x = r[n], this.y = r[n + 1], this.z = r[n + 2], this
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z
		},
		fromArray: function(e) {
			return this.x = e[0], this.y = e[1], this.z = e[2], this
		},
		toArray: function() {
			return [this.x, this.y, this.z]
		},
		clone: function() {
			return new THREE.Vector3(this.x, this.y, this.z)
		}
	}, THREE.Vector4 = function(e, t, n, r) {
		this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
	}, THREE.Vector4.prototype = {
		constructor: THREE.Vector4,
		set: function(e, t, n, r) {
			return this.x = e, this.y = t, this.z = n, this.w = r, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setZ: function(e) {
			return this.z = e, this
		},
		setW: function(e) {
			return this.w = e, this
		},
		setComponent: function(e, t) {
			switch(e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				case 3:
					this.w = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		getComponent: function(e) {
			switch(e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this.z += e, this.w += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
		},
		applyMatrix4: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z,
				i = this.w;
			return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i, this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i, this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i, this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i, this
		},
		divideScalar: function(e) {
			return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e) : (this.z = this.y = this.x = 0, this.w = 1), this
		},
		setAxisAngleFromQuaternion: function(e) {
			this.w = 2 * Math.acos(e.w);
			var t = Math.sqrt(1 - e.w * e.w);
			return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
		},
		setAxisAngleFromRotationMatrix: function(e) {
			var t, n, r;
			e = e.elements;
			var i = e[0];
			r = e[4];
			var s = e[8],
				o = e[1],
				u = e[5],
				a = e[9];
			n = e[2], t = e[6];
			var f = e[10];
			return .01 > Math.abs(r - o) && .01 > Math.abs(s - n) && .01 > Math.abs(a - t) ? .1 > Math.abs(r + o) && .1 > Math.abs(s + n) && .1 > Math.abs(a + t) && .1 > Math.abs(i + u + f - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, i = (i + 1) / 2, u = (u + 1) / 2, f = (f + 1) / 2, r = (r + o) / 4, s = (s + n) / 4, a = (a + t) / 4, i > u && i > f ? .01 > i ? (t = 0, r = n = .707106781) : (t = Math.sqrt(i), n = r / t, r = s / t) : u > f ? .01 > u ? (t = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(u), t = r / n, r = a / n) : .01 > f ? (n = t = .707106781, r = 0) : (r = Math.sqrt(f), t = s / r, n = a / r), this.set(t, n, r, e), this) : (e = Math.sqrt((t - a) * (t - a) + (s - n) * (s - n) + (o - r) * (o - r)), .001 > Math.abs(e) && (e = 1), this.x = (t - a) / e, this.y = (s - n) / e, this.z = (o - r) / e, this.w = Math.acos((i + u + f - 1) / 2), this)
		},
		min: function(e) {
			return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this
		},
		max: function(e) {
			return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this
		},
		clamp: function(e, t) {
			return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this.w < e.w ? this.w = e.w : this.w > t.w && (this.w = t.w), this
		},
		clampScalar: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector4, t = new THREE.Vector4), e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t)
			}
		}(),
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
		},
		negate: function() {
			return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		},
		lengthManhattan: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		setLength: function(e) {
			var t = this.length();
			return 0 !== t && e !== t && this.multiplyScalar(e / t), this
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
		},
		fromArray: function(e) {
			return this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3], this
		},
		toArray: function() {
			return [this.x, this.y, this.z, this.w]
		},
		clone: function() {
			return new THREE.Vector4(this.x, this.y, this.z, this.w)
		}
	}, THREE.Euler = function(e, t, n, r) {
		this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || THREE.Euler.DefaultOrder
	}, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
		constructor: THREE.Euler,
		_x: 0,
		_y: 0,
		_z: 0,
		_order: THREE.Euler.DefaultOrder,
		get x() {
			return this._x
		},
		set x(e) {
			this._x = e, this.onChangeCallback()
		},
		get y() {
			return this._y
		},
		set y(e) {
			this._y = e, this.onChangeCallback()
		},
		get z() {
			return this._z
		},
		set z(e) {
			this._z = e, this.onChangeCallback()
		},
		get order() {
			return this._order
		},
		set order(e) {
			this._order = e, this.onChangeCallback()
		},
		set: function(e, t, n, r) {
			return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this.onChangeCallback(), this
		},
		copy: function(e) {
			return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
		},
		setFromRotationMatrix: function(e, t) {
			var n = THREE.Math.clamp,
				r = e.elements,
				i = r[0],
				s = r[4],
				o = r[8],
				u = r[1],
				a = r[5],
				f = r[9],
				l = r[2],
				c = r[6],
				r = r[10];
			return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(-f, r), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(c, a), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(f, -1, 1)), .99999 > Math.abs(f) ? (this._y = Math.atan2(o, r), this._z = Math.atan2(u, a)) : (this._y = Math.atan2(-l, i), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(-l, r), this._z = Math.atan2(-s, a)) : (this._y = 0, this._z = Math.atan2(u, i))) : "ZYX" === t ? (this._y = Math.asin(-n(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(c, r), this._z = Math.atan2(u, i)) : (this._x = 0, this._z = Math.atan2(-s, a))) : "YZX" === t ? (this._z = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._x = Math.atan2(-f, a), this._y = Math.atan2(-l, i)) : (this._x = 0, this._y = Math.atan2(o, r))) : "XZY" === t ? (this._z = Math.asin(-n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(c, a), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-f, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, this.onChangeCallback(), this
		},
		setFromQuaternion: function(e, t, n) {
			var r = THREE.Math.clamp,
				i = e.x * e.x,
				s = e.y * e.y,
				o = e.z * e.z,
				u = e.w * e.w;
			return t = t || this._order, "XYZ" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), u - i - s + o), this._y = Math.asin(r(2 * (e.x * e.z + e.y * e.w), -1, 1)), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u + i - s - o)) : "YXZ" === t ? (this._x = Math.asin(r(2 * (e.x * e.w - e.y * e.z), -1, 1)), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u - i - s + o), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u - i + s - o)) : "ZXY" === t ? (this._x = Math.asin(r(2 * (e.x * e.w + e.y * e.z), -1, 1)), this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), u - i - s + o), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u - i + s - o)) : "ZYX" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), u - i - s + o), this._y = Math.asin(r(2 * (e.y * e.w - e.x * e.z), -1, 1)), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u + i - s - o)) : "YZX" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), u - i + s - o), this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), u + i - s - o), this._z = Math.asin(r(2 * (e.x * e.y + e.z * e.w), -1, 1))) : "XZY" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), u - i + s - o), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u + i - s - o), this._z = Math.asin(r(2 * (e.z * e.w - e.x * e.y), -1, 1))) : console.warn("THREE.Euler: .setFromQuaternion() given unsupported order: " + t), this._order = t, !1 !== n && this.onChangeCallback(), this
		},
		reorder: function() {
			var e = new THREE.Quaternion;
			return function(t) {
				e.setFromEuler(this), this.setFromQuaternion(e, t)
			}
		}(),
		equals: function(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
		},
		fromArray: function(e) {
			return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
		},
		toArray: function() {
			return [this._x, this._y, this._z, this._order]
		},
		onChange: function(e) {
			return this.onChangeCallback = e, this
		},
		onChangeCallback: function() {},
		clone: function() {
			return new THREE.Euler(this._x, this._y, this._z, this._order)
		}
	}, THREE.Line3 = function(e, t) {
		this.start = void 0 !== e ? e : new THREE.Vector3, this.end = void 0 !== t ? t : new THREE.Vector3
	}, THREE.Line3.prototype = {
		constructor: THREE.Line3,
		set: function(e, t) {
			return this.start.copy(e), this.end.copy(t), this
		},
		copy: function(e) {
			return this.start.copy(e.start), this.end.copy(e.end), this
		},
		center: function(e) {
			return(e || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
		},
		delta: function(e) {
			return(e || new THREE.Vector3).subVectors(this.end, this.start)
		},
		distanceSq: function() {
			return this.start.distanceToSquared(this.end)
		},
		distance: function() {
			return this.start.distanceTo(this.end)
		},
		at: function(e, t) {
			var n = t || new THREE.Vector3;
			return this.delta(n).multiplyScalar(e).add(this.start)
		},
		closestPointToPointParameter: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n, r) {
				e.subVectors(n, this.start), t.subVectors(this.end, this.start);
				var i = t.dot(t),
					i = t.dot(e) / i;
				return r && (i = THREE.Math.clamp(i, 0, 1)), i
			}
		}(),
		closestPointToPoint: function(e, t, n) {
			return e = this.closestPointToPointParameter(e, t), n = n || new THREE.Vector3, this.delta(n).multiplyScalar(e).add(this.start)
		},
		applyMatrix4: function(e) {
			return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
		},
		equals: function(e) {
			return e.start.equals(this.start) && e.end.equals(this.end)
		},
		clone: function() {
			return(new THREE.Line3).copy(this)
		}
	}, THREE.Box2 = function(e, t) {
		this.min = void 0 !== e ? e : new THREE.Vector2(Infinity, Infinity), this.max = void 0 !== t ? t : new THREE.Vector2(-Infinity, -Infinity)
	}, THREE.Box2.prototype = {
		constructor: THREE.Box2,
		set: function(e, t) {
			return this.min.copy(e), this.max.copy(t), this
		},
		setFromPoints: function(e) {
			this.makeEmpty();
			for(var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
			return this
		},
		setFromCenterAndSize: function() {
			var e = new THREE.Vector2;
			return function(t, n) {
				var r = e.copy(n).multiplyScalar(.5);
				return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
			}
		}(),
		copy: function(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this
		},
		makeEmpty: function() {
			return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -Infinity, this
		},
		empty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y
		},
		center: function(e) {
			return(e || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
		},
		size: function(e) {
			return(e || new THREE.Vector2).subVectors(this.max, this.min)
		},
		expandByPoint: function(e) {
			return this.min.min(e), this.max.max(e), this
		},
		expandByVector: function(e) {
			return this.min.sub(e), this.max.add(e), this
		},
		expandByScalar: function(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this
		},
		containsPoint: function(e) {
			return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0
		},
		containsBox: function(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1
		},
		getParameter: function(e, t) {
			return(t || new THREE.Vector2).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
		},
		isIntersectionBox: function(e) {
			return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0
		},
		clampPoint: function(e, t) {
			return(t || new THREE.Vector2).copy(e).clamp(this.min, this.max)
		},
		distanceToPoint: function() {
			var e = new THREE.Vector2;
			return function(t) {
				return e.copy(t).clamp(this.min, this.max).sub(t).length()
			}
		}(),
		intersect: function(e) {
			return this.min.max(e.min), this.max.min(e.max), this
		},
		union: function(e) {
			return this.min.min(e.min), this.max.max(e.max), this
		},
		translate: function(e) {
			return this.min.add(e), this.max.add(e), this
		},
		equals: function(e) {
			return e.min.equals(this.min) && e.max.equals(this.max)
		},
		clone: function() {
			return(new THREE.Box2).copy(this)
		}
	}, THREE.Box3 = function(e, t) {
		this.min = void 0 !== e ? e : new THREE.Vector3(Infinity, Infinity, Infinity), this.max = void 0 !== t ? t : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
	}, THREE.Box3.prototype = {
		constructor: THREE.Box3,
		set: function(e, t) {
			return this.min.copy(e), this.max.copy(t), this
		},
		setFromPoints: function(e) {
			this.makeEmpty();
			for(var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
			return this
		},
		setFromCenterAndSize: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				var r = e.copy(n).multiplyScalar(.5);
				return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
			}
		}(),
		setFromObject: function() {
			var e = new THREE.Vector3;
			return function(t) {
				var n = this;
				return t.updateMatrixWorld(!0), this.makeEmpty(), t.traverse(function(t) {
					if(void 0 !== t.geometry && void 0 !== t.geometry.vertices)
						for(var r = t.geometry.vertices, i = 0, s = r.length; i < s; i++) e.copy(r[i]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e)
				}), this
			}
		}(),
		copy: function(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this
		},
		makeEmpty: function() {
			return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -Infinity, this
		},
		empty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
		},
		center: function(e) {
			return(e || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
		},
		size: function(e) {
			return(e || new THREE.Vector3).subVectors(this.max, this.min)
		},
		expandByPoint: function(e) {
			return this.min.min(e), this.max.max(e), this
		},
		expandByVector: function(e) {
			return this.min.sub(e), this.max.add(e), this
		},
		expandByScalar: function(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this
		},
		containsPoint: function(e) {
			return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0
		},
		containsBox: function(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1
		},
		getParameter: function(e, t) {
			return(t || new THREE.Vector3).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
		},
		isIntersectionBox: function(e) {
			return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0
		},
		clampPoint: function(e, t) {
			return(t || new THREE.Vector3).copy(e).clamp(this.min, this.max)
		},
		distanceToPoint: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return e.copy(t).clamp(this.min, this.max).sub(t).length()
			}
		}(),
		getBoundingSphere: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return t = t || new THREE.Sphere, t.center = this.center(), t.radius = .5 * this.size(e).length(), t
			}
		}(),
		intersect: function(e) {
			return this.min.max(e.min), this.max.min(e.max), this
		},
		union: function(e) {
			return this.min.min(e.min), this.max.max(e.max), this
		},
		applyMatrix4: function() {
			var e = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
			return function(t) {
				return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.makeEmpty(), this.setFromPoints(e), this
			}
		}(),
		translate: function(e) {
			return this.min.add(e), this.max.add(e), this
		},
		equals: function(e) {
			return e.min.equals(this.min) && e.max.equals(this.max)
		},
		clone: function() {
			return(new THREE.Box3).copy(this)
		}
	}, THREE.Matrix3 = function(e, t, n, r, i, s, o, u, a) {
		var f = this.elements = new Float32Array(9);
		f[0] = void 0 !== e ? e : 1, f[3] = t || 0, f[6] = n || 0, f[1] = r || 0, f[4] = void 0 !== i ? i : 1, f[7] = s || 0, f[2] = o || 0, f[5] = u || 0, f[8] = void 0 !== a ? a : 1
	}, THREE.Matrix3.prototype = {
		constructor: THREE.Matrix3,
		set: function(e, t, n, r, i, s, o, u, a) {
			var f = this.elements;
			return f[0] = e, f[3] = t, f[6] = n, f[1] = r, f[4] = i, f[7] = s, f[2] = o, f[5] = u, f[8] = a, this
		},
		identity: function() {
			return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
		},
		copy: function(e) {
			return e = e.elements, this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
		},
		multiplyVector3: function(e) {
			return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
		},
		multiplyVector3Array: function(e) {
			return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
		},
		applyToVector3Array: function() {
			var e = new THREE.Vector3;
			return function(t, n, r) {
				void 0 === n && (n = 0), void 0 === r && (r = t.length);
				for(var i = 0; i < r; i += 3, n += 3) e.x = t[n], e.y = t[n + 1], e.z = t[n + 2], e.applyMatrix3(this), t[n] = e.x, t[n + 1] = e.y, t[n + 2] = e.z;
				return t
			}
		}(),
		multiplyScalar: function(e) {
			var t = this.elements;
			return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
		},
		determinant: function() {
			var e = this.elements,
				t = e[0],
				n = e[1],
				r = e[2],
				i = e[3],
				s = e[4],
				o = e[5],
				u = e[6],
				a = e[7],
				e = e[8];
			return t * s * e - t * o * a - n * i * e + n * o * u + r * i * a - r * s * u
		},
		getInverse: function(e, t) {
			var n = e.elements,
				r = this.elements;
			r[0] = n[10] * n[5] - n[6] * n[9], r[1] = -n[10] * n[1] + n[2] * n[9], r[2] = n[6] * n[1] - n[2] * n[5], r[3] = -n[10] * n[4] + n[6] * n[8], r[4] = n[10] * n[0] - n[2] * n[8], r[5] = -n[6] * n[0] + n[2] * n[4], r[6] = n[9] * n[4] - n[5] * n[8], r[7] = -n[9] * n[0] + n[1] * n[8], r[8] = n[5] * n[0] - n[1] * n[4], n = n[0] * r[0] + n[1] * r[3] + n[2] * r[6];
			if(0 === n) {
				if(t) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
				return console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
			}
			return this.multiplyScalar(1 / n), this
		},
		transpose: function() {
			var e, t = this.elements;
			return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
		},
		flattenToArrayOffset: function(e, t) {
			var n = this.elements;
			return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
		},
		getNormalMatrix: function(e) {
			return this.getInverse(e).transpose(), this
		},
		transposeIntoArray: function(e) {
			var t = this.elements;
			return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
		},
		fromArray: function(e) {
			return this.elements.set(e), this
		},
		toArray: function() {
			var e = this.elements;
			return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
		},
		clone: function() {
			var e = this.elements;
			return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8])
		}
	}, THREE.Matrix4 = function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
		var m = this.elements = new Float32Array(16);
		m[0] = void 0 !== e ? e : 1, m[4] = t || 0, m[8] = n || 0, m[12] = r || 0, m[1] = i || 0, m[5] = void 0 !== s ? s : 1, m[9] = o || 0, m[13] = u || 0, m[2] = a || 0, m[6] = f || 0, m[10] = void 0 !== l ? l : 1, m[14] = c || 0, m[3] = h || 0, m[7] = p || 0, m[11] = d || 0, m[15] = void 0 !== v ? v : 1
	}, THREE.Matrix4.prototype = {
		constructor: THREE.Matrix4,
		set: function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
			var m = this.elements;
			return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = i, m[5] = s, m[9] = o, m[13] = u, m[2] = a, m[6] = f, m[10] = l, m[14] = c, m[3] = h, m[7] = p, m[11] = d, m[15] = v, this
		},
		identity: function() {
			return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
		},
		copy: function(e) {
			return this.elements.set(e.elements), this
		},
		extractPosition: function(e) {
			return console.warn("THREEMatrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
		},
		copyPosition: function(e) {
			var t = this.elements;
			return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
		},
		extractRotation: function() {
			var e = new THREE.Vector3;
			return function(t) {
				var n = this.elements;
				t = t.elements;
				var r = 1 / e.set(t[0], t[1], t[2]).length(),
					i = 1 / e.set(t[4], t[5], t[6]).length(),
					s = 1 / e.set(t[8], t[9], t[10]).length();
				return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[4] = t[4] * i, n[5] = t[5] * i, n[6] = t[6] * i, n[8] = t[8] * s, n[9] = t[9] * s, n[10] = t[10] * s, this
			}
		}(),
		makeRotationFromEuler: function(e) {
			0 == e instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
			var t = this.elements,
				n = e.x,
				r = e.y,
				i = e.z,
				s = Math.cos(n),
				n = Math.sin(n),
				o = Math.cos(r),
				r = Math.sin(r),
				u = Math.cos(i),
				i = Math.sin(i);
			if("XYZ" === e.order) {
				e = s * u;
				var a = s * i,
					f = n * u,
					l = n * i;
				t[0] = o * u, t[4] = -o * i, t[8] = r, t[1] = a + f * r, t[5] = e - l * r, t[9] = -n * o, t[2] = l - e * r, t[6] = f + a * r, t[10] = s * o
			} else "YXZ" === e.order ? (e = o * u, a = o * i, f = r * u, l = r * i, t[0] = e + l * n, t[4] = f * n - a, t[8] = s * r, t[1] = s * i, t[5] = s * u, t[9] = -n, t[2] = a * n - f, t[6] = l + e * n, t[10] = s * o) : "ZXY" === e.order ? (e = o * u, a = o * i, f = r * u, l = r * i, t[0] = e - l * n, t[4] = -s * i, t[8] = f + a * n, t[1] = a + f * n, t[5] = s * u, t[9] = l - e * n, t[2] = -s * r, t[6] = n, t[10] = s * o) : "ZYX" === e.order ? (e = s * u, a = s * i, f = n * u, l = n * i, t[0] = o * u, t[4] = f * r - a, t[8] = e * r + l, t[1] = o * i, t[5] = l * r + e, t[9] = a * r - f, t[2] = -r, t[6] = n * o, t[10] = s * o) : "YZX" === e.order ? (e = s * o, a = s * r, f = n * o, l = n * r, t[0] = o * u, t[4] = l - e * i, t[8] = f * i + a, t[1] = i, t[5] = s * u, t[9] = -n * u, t[2] = -r * u, t[6] = a * i + f, t[10] = e - l * i) : "XZY" === e.order && (e = s * o, a = s * r, f = n * o, l = n * r, t[0] = o * u, t[4] = -i, t[8] = r * u, t[1] = e * i + l, t[5] = s * u, t[9] = a * i - f, t[2] = f * i - a, t[6] = n * u, t[10] = l * i + e);
			return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
		},
		setRotationFromQuaternion: function(e) {
			return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
		},
		makeRotationFromQuaternion: function(e) {
			var t = this.elements,
				n = e.x,
				r = e.y,
				i = e.z,
				s = e.w,
				o = n + n,
				u = r + r,
				a = i + i;
			e = n * o;
			var f = n * u,
				n = n * a,
				l = r * u,
				r = r * a,
				i = i * a,
				o = s * o,
				u = s * u,
				s = s * a;
			return t[0] = 1 - (l + i), t[4] = f - s, t[8] = n + u, t[1] = f + s, t[5] = 1 - (e + i), t[9] = r - o, t[2] = n - u, t[6] = r + o, t[10] = 1 - (e + l), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
		},
		lookAt: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3,
				n = new THREE.Vector3;
			return function(r, i, s) {
				var o = this.elements;
				return n.subVectors(r, i).normalize(), 0 === n.length() && (n.z = 1), e.crossVectors(s, n).normalize(), 0 === e.length() && (n.x += 1e-4, e.crossVectors(s, n).normalize()), t.crossVectors(n, e), o[0] = e.x, o[4] = t.x, o[8] = n.x, o[1] = e.y, o[5] = t.y, o[9] = n.y, o[2] = e.z, o[6] = t.z, o[10] = n.z, this
			}
		}(),
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
		},
		multiplyMatrices: function(e, t) {
			var n = e.elements,
				r = t.elements,
				i = this.elements,
				s = n[0],
				o = n[4],
				u = n[8],
				a = n[12],
				f = n[1],
				l = n[5],
				c = n[9],
				h = n[13],
				p = n[2],
				d = n[6],
				v = n[10],
				m = n[14],
				g = n[3],
				y = n[7],
				b = n[11],
				n = n[15],
				w = r[0],
				E = r[4],
				S = r[8],
				x = r[12],
				T = r[1],
				N = r[5],
				C = r[9],
				k = r[13],
				L = r[2],
				A = r[6],
				O = r[10],
				M = r[14],
				_ = r[3],
				D = r[7],
				P = r[11],
				r = r[15];
			return i[0] = s * w + o * T + u * L + a * _, i[4] = s * E + o * N + u * A + a * D, i[8] = s * S + o * C + u * O + a * P, i[12] = s * x + o * k + u * M + a * r, i[1] = f * w + l * T + c * L + h * _, i[5] = f * E + l * N + c * A + h * D, i[9] = f * S + l * C + c * O + h * P, i[13] = f * x + l * k + c * M + h * r, i[2] = p * w + d * T + v * L + m * _, i[6] = p * E + d * N + v * A + m * D, i[10] = p * S + d * C + v * O + m * P, i[14] = p * x + d * k + v * M + m * r, i[3] = g * w + y * T + b * L + n * _, i[7] = g * E + y * N + b * A + n * D, i[11] = g * S + y * C + b * O + n * P, i[15] = g * x + y * k + b * M + n * r, this
		},
		multiplyToArray: function(e, t, n) {
			var r = this.elements;
			return this.multiplyMatrices(e, t), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
		},
		multiplyScalar: function(e) {
			var t = this.elements;
			return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
		},
		multiplyVector3: function(e) {
			return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
		},
		multiplyVector4: function(e) {
			return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		multiplyVector3Array: function(e) {
			return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
		},
		applyToVector3Array: function() {
			var e = new THREE.Vector3;
			return function(t, n, r) {
				void 0 === n && (n = 0), void 0 === r && (r = t.length);
				for(var i = 0; i < r; i += 3, n += 3) e.x = t[n], e.y = t[n + 1], e.z = t[n + 2], e.applyMatrix4(this), t[n] = e.x, t[n + 1] = e.y, t[n + 2] = e.z;
				return t
			}
		}(),
		rotateAxis: function(e) {
			console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
		},
		crossVector: function(e) {
			return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		determinant: function() {
			var e = this.elements,
				t = e[0],
				n = e[4],
				r = e[8],
				i = e[12],
				s = e[1],
				o = e[5],
				u = e[9],
				a = e[13],
				f = e[2],
				l = e[6],
				c = e[10],
				h = e[14];
			return e[3] * (+i * u * l - r * a * l - i * o * c + n * a * c + r * o * h - n * u * h) + e[7] * (+t * u * h - t * a * c + i * s * c - r * s * h + r * a * f - i * u * f) + e[11] * (+t * a * l - t * o * h - i * s * l + n * s * h + i * o * f - n * a * f) + e[15] * (-r * o * f - t * u * l + t * o * c + r * s * l - n * s * c + n * u * f)
		},
		transpose: function() {
			var e = this.elements,
				t;
			return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
		},
		flattenToArrayOffset: function(e, t) {
			var n = this.elements;
			return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
		},
		getPosition: function() {
			var e = new THREE.Vector3;
			return function() {
				console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
				var t = this.elements;
				return e.set(t[12], t[13], t[14])
			}
		}(),
		setPosition: function(e) {
			var t = this.elements;
			return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
		},
		getInverse: function(e, t) {
			var n = this.elements,
				r = e.elements,
				i = r[0],
				s = r[4],
				o = r[8],
				u = r[12],
				a = r[1],
				f = r[5],
				l = r[9],
				c = r[13],
				h = r[2],
				p = r[6],
				d = r[10],
				v = r[14],
				m = r[3],
				g = r[7],
				y = r[11],
				r = r[15];
			n[0] = l * v * g - c * d * g + c * p * y - f * v * y - l * p * r + f * d * r, n[4] = u * d * g - o * v * g - u * p * y + s * v * y + o * p * r - s * d * r, n[8] = o * c * g - u * l * g + u * f * y - s * c * y - o * f * r + s * l * r, n[12] = u * l * p - o * c * p - u * f * d + s * c * d + o * f * v - s * l * v, n[1] = c * d * m - l * v * m - c * h * y + a * v * y + l * h * r - a * d * r, n[5] = o * v * m - u * d * m + u * h * y - i * v * y - o * h * r + i * d * r, n[9] = u * l * m - o * c * m - u * a * y + i * c * y + o * a * r - i * l * r, n[13] = o * c * h - u * l * h + u * a * d - i * c * d - o * a * v + i * l * v, n[2] = f * v * m - c * p * m + c * h * g - a * v * g - f * h * r + a * p * r, n[6] = u * p * m - s * v * m - u * h * g + i * v * g + s * h * r - i * p * r, n[10] = s * c * m - u * f * m + u * a * g - i * c * g - s * a * r + i * f * r, n[14] = u * f * h - s * c * h - u * a * p + i * c * p + s * a * v - i * f * v, n[3] = l * p * m - f * d * m - l * h * g + a * d * g + f * h * y - a * p * y, n[7] = s * d * m - o * p * m + o * h * g - i * d * g - s * h * y + i * p * y, n[11] = o * f * m - s * l * m - o * a * g + i * l * g + s * a * y - i * f * y, n[15] = s * l * h - o * f * h + o * a * p - i * l * p - s * a * d + i * f * d, n = i * n[0] + a * n[4] + h * n[8] + m * n[12];
			if(0 == n) {
				if(t) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
				return console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
			}
			return this.multiplyScalar(1 / n), this
		},
		translate: function(e) {
			console.warn("THREE.Matrix4: .translate() has been removed.")
		},
		rotateX: function(e) {
			console.warn("THREE.Matrix4: .rotateX() has been removed.")
		},
		rotateY: function(e) {
			console.warn("THREE.Matrix4: .rotateY() has been removed.")
		},
		rotateZ: function(e) {
			console.warn("THREE.Matrix4: .rotateZ() has been removed.")
		},
		rotateByAxis: function(e, t) {
			console.warn("THREE.Matrix4: .rotateByAxis() has been removed.")
		},
		scale: function(e) {
			var t = this.elements,
				n = e.x,
				r = e.y;
			return e = e.z, t[0] *= n, t[4] *= r, t[8] *= e, t[1] *= n, t[5] *= r, t[9] *= e, t[2] *= n, t[6] *= r, t[10] *= e, t[3] *= n, t[7] *= r, t[11] *= e, this
		},
		getMaxScaleOnAxis: function() {
			var e = this.elements;
			return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], Math.max(e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])))
		},
		makeTranslation: function(e, t, n) {
			return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
		},
		makeRotationX: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
		},
		makeRotationY: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
		},
		makeRotationZ: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
		},
		makeRotationAxis: function(e, t) {
			var n = Math.cos(t),
				r = Math.sin(t),
				i = 1 - n,
				s = e.x,
				o = e.y,
				u = e.z,
				a = i * s,
				f = i * o;
			return this.set(a * s + n, a * o - r * u, a * u + r * o, 0, a * o + r * u, f * o + n, f * u - r * s, 0, a * u - r * o, f * u + r * s, i * u * u + n, 0, 0, 0, 0, 1), this
		},
		makeScale: function(e, t, n) {
			return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
		},
		compose: function(e, t, n) {
			return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
		},
		decompose: function() {
			var e = new THREE.Vector3,
				t = new THREE.Matrix4;
			return function(n, r, i) {
				var s = this.elements,
					o = e.set(s[0], s[1], s[2]).length(),
					u = e.set(s[4], s[5], s[6]).length(),
					f = e.set(s[8], s[9], s[10]).length();
				0 > this.determinant() && (o = -o), n.x = s[12], n.y = s[13], n.z = s[14], t.elements.set(this.elements), n = 1 / o;
				var s = 1 / u,
					l = 1 / f;
				return t.elements[0] *= n, t.elements[1] *= n, t.elements[2] *= n, t.elements[4] *= s, t.elements[5] *= s, t.elements[6] *= s, t.elements[8] *= l, t.elements[9] *= l, t.elements[10] *= l, r.setFromRotationMatrix(t), i.x = o, i.y = u, i.z = f, this
			}
		}(),
		makeFrustum: function(e, t, n, r, i, s) {
			var o = this.elements;
			return o[0] = 2 * i / (t - e), o[4] = 0, o[8] = (t + e) / (t - e), o[12] = 0, o[1] = 0, o[5] = 2 * i / (r - n), o[9] = (r + n) / (r - n), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(s + i) / (s - i), o[14] = -2 * s * i / (s - i), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
		},
		makePerspective: function(e, t, n, r) {
			e = n * Math.tan(THREE.Math.degToRad(.5 * e));
			var i = -e;
			return this.makeFrustum(i * t, e * t, i, e, n, r)
		},
		makeOrthographic: function(e, t, n, r, i, s) {
			var o = this.elements,
				u = t - e,
				a = n - r,
				f = s - i;
			return o[0] = 2 / u, o[4] = 0, o[8] = 0, o[12] = -((t + e) / u), o[1] = 0, o[5] = 2 / a, o[9] = 0, o[13] = -((n + r) / a), o[2] = 0, o[6] = 0, o[10] = -2 / f, o[14] = -((s + i) / f), o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
		},
		fromArray: function(e) {
			return this.elements.set(e), this
		},
		toArray: function() {
			var e = this.elements;
			return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
		},
		clone: function() {
			var e = this.elements;
			return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15])
		}
	}, THREE.Ray = function(e, t) {
		this.origin = void 0 !== e ? e : new THREE.Vector3, this.direction = void 0 !== t ? t : new THREE.Vector3
	}, THREE.Ray.prototype = {
		constructor: THREE.Ray,
		set: function(e, t) {
			return this.origin.copy(e), this.direction.copy(t), this
		},
		copy: function(e) {
			return this.origin.copy(e.origin), this.direction.copy(e.direction), this
		},
		at: function(e, t) {
			return(t || new THREE.Vector3).copy(this.direction).multiplyScalar(e).add(this.origin)
		},
		recast: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return this.origin.copy(this.at(t, e)), this
			}
		}(),
		closestPointToPoint: function(e, t) {
			var n = t || new THREE.Vector3;
			n.subVectors(e, this.origin);
			var r = n.dot(this.direction);
			return 0 > r ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
		},
		distanceToPoint: function() {
			var e = new THREE.Vector3;
			return function(t) {
				var n = e.subVectors(t, this.origin).dot(this.direction);
				return 0 > n ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceTo(t))
			}
		}(),
		distanceSqToSegment: function(e, t, n, r) {
			var i = e.clone().add(t).multiplyScalar(.5),
				s = t.clone().sub(e).normalize(),
				o = .5 * e.distanceTo(t),
				u = this.origin.clone().sub(i);
			e = -this.direction.dot(s), t = u.dot(this.direction);
			var a = -u.dot(s),
				f = u.lengthSq(),
				l = Math.abs(1 - e * e),
				c, h;
			return 0 <= l ? (u = e * a - t, c = e * t - a, h = o * l, 0 <= u ? c >= -h ? c <= h ? (o = 1 / l, u *= o, c *= o, e = u * (u + e * c + 2 * t) + c * (e * u + c + 2 * a) + f) : (c = o, u = Math.max(0, -(e * c + t)), e = -u * u + c * (c + 2 * a) + f) : (c = -o, u = Math.max(0, -(e * c + t)), e = -u * u + c * (c + 2 * a) + f) : c <= -h ? (u = Math.max(0, -(-e * o + t)), c = 0 < u ? -o : Math.min(Math.max(-o, -a), o), e = -u * u + c * (c + 2 * a) + f) : c <= h ? (u = 0, c = Math.min(Math.max(-o, -a), o), e = c * (c + 2 * a) + f) : (u = Math.max(0, -(e * o + t)), c = 0 < u ? o : Math.min(Math.max(-o, -a), o), e = -u * u + c * (c + 2 * a) + f)) : (c = 0 < e ? -o : o, u = Math.max(0, -(e * c + t)), e = -u * u + c * (c + 2 * a) + f), n && n.copy(this.direction.clone().multiplyScalar(u).add(this.origin)), r && r.copy(s.clone().multiplyScalar(c).add(i)), e
		},
		isIntersectionSphere: function(e) {
			return this.distanceToPoint(e.center) <= e.radius
		},
		intersectSphere: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				e.subVectors(t.center, this.origin);
				var r = e.dot(this.direction),
					i = e.dot(e) - r * r,
					s = t.radius * t.radius;
				return i > s ? null : (s = Math.sqrt(s - i), i = r - s, r += s, 0 > i && 0 > r ? null : 0 > i ? this.at(r, n) : this.at(i, n))
			}
		}(),
		isIntersectionPlane: function(e) {
			var t = e.distanceToPoint(this.origin);
			return 0 === t || 0 > e.normal.dot(this.direction) * t ? !0 : !1
		},
		distanceToPlane: function(e) {
			var t = e.normal.dot(this.direction);
			return 0 == t ? 0 == e.distanceToPoint(this.origin) ? 0 : null : (e = -(this.origin.dot(e.normal) + e.constant) / t, 0 <= e ? e : null)
		},
		intersectPlane: function(e, t) {
			var n = this.distanceToPlane(e);
			return null === n ? null : this.at(n, t)
		},
		isIntersectionBox: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return null !== this.intersectBox(t, e)
			}
		}(),
		intersectBox: function(e, t) {
			var n, r, i, s, o;
			r = 1 / this.direction.x, s = 1 / this.direction.y, o = 1 / this.direction.z;
			var u = this.origin;
			0 <= r ? (n = (e.min.x - u.x) * r, r *= e.max.x - u.x) : (n = (e.max.x - u.x) * r, r *= e.min.x - u.x), 0 <= s ? (i = (e.min.y - u.y) * s, s *= e.max.y - u.y) : (i = (e.max.y - u.y) * s, s *= e.min.y - u.y);
			if(n > s || i > r) return null;
			if(i > n || n !== n) n = i;
			if(s < r || r !== r) r = s;
			0 <= o ? (i = (e.min.z - u.z) * o, o *= e.max.z - u.z) : (i = (e.max.z - u.z) * o, o *= e.min.z - u.z);
			if(n > o || i > r) return null;
			if(i > n || n !== n) n = i;
			if(o < r || r !== r) r = o;
			return 0 > r ? null : this.at(0 <= n ? n : r, t)
		},
		intersectTriangle: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3,
				n = new THREE.Vector3,
				r = new THREE.Vector3;
			return function(i, s, o, u, f) {
				t.subVectors(s, i), n.subVectors(o, i), r.crossVectors(t, n), s = this.direction.dot(r);
				if(0 < s) {
					if(u) return null;
					u = 1
				} else {
					if(!(0 > s)) return null;
					u = -1, s = -s
				}
				return e.subVectors(this.origin, i), i = u * this.direction.dot(n.crossVectors(e, n)), 0 > i ? null : (o = u * this.direction.dot(t.cross(e)), 0 > o || i + o > s ? null : (i = -u * e.dot(r), 0 > i ? null : this.at(i / s, f)))
			}
		}(),
		applyMatrix4: function(e) {
			return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
		},
		equals: function(e) {
			return e.origin.equals(this.origin) && e.direction.equals(this.direction)
		},
		clone: function() {
			return(new THREE.Ray).copy(this)
		}
	}, THREE.Sphere = function(e, t) {
		this.center = void 0 !== e ? e : new THREE.Vector3, this.radius = void 0 !== t ? t : 0
	}, THREE.Sphere.prototype = {
		constructor: THREE.Sphere,
		set: function(e, t) {
			return this.center.copy(e), this.radius = t, this
		},
		setFromPoints: function() {
			var e = new THREE.Box3;
			return function(t, n) {
				var r = this.center;
				void 0 !== n ? r.copy(n) : e.setFromPoints(t).center(r);
				for(var i = 0, s = 0, o = t.length; s < o; s++) i = Math.max(i, r.distanceToSquared(t[s]));
				return this.radius = Math.sqrt(i), this
			}
		}(),
		copy: function(e) {
			return this.center.copy(e.center), this.radius = e.radius, this
		},
		empty: function() {
			return 0 >= this.radius
		},
		containsPoint: function(e) {
			return e.distanceToSquared(this.center) <= this.radius * this.radius
		},
		distanceToPoint: function(e) {
			return e.distanceTo(this.center) - this.radius
		},
		intersectsSphere: function(e) {
			var t = this.radius + e.radius;
			return e.center.distanceToSquared(this.center) <= t * t
		},
		clampPoint: function(e, t) {
			var n = this.center.distanceToSquared(e),
				r = t || new THREE.Vector3;
			return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
		},
		getBoundingBox: function(e) {
			return e = e || new THREE.Box3, e.set(this.center, this.center), e.expandByScalar(this.radius), e
		},
		applyMatrix4: function(e) {
			return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
		},
		translate: function(e) {
			return this.center.add(e), this
		},
		equals: function(e) {
			return e.center.equals(this.center) && e.radius === this.radius
		},
		clone: function() {
			return(new THREE.Sphere).copy(this)
		}
	}, THREE.Frustum = function(e, t, n, r, i, s) {
		this.planes = [void 0 !== e ? e : new THREE.Plane, void 0 !== t ? t : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== s ? s : new THREE.Plane]
	}, THREE.Frustum.prototype = {
		constructor: THREE.Frustum,
		set: function(e, t, n, r, i, s) {
			var o = this.planes;
			return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this
		},
		copy: function(e) {
			for(var t = this.planes, n = 0; 6 > n; n++) t[n].copy(e.planes[n]);
			return this
		},
		setFromMatrix: function(e) {
			var t = this.planes,
				n = e.elements;
			e = n[0];
			var r = n[1],
				i = n[2],
				s = n[3],
				o = n[4],
				u = n[5],
				a = n[6],
				f = n[7],
				l = n[8],
				c = n[9],
				h = n[10],
				p = n[11],
				d = n[12],
				v = n[13],
				m = n[14],
				n = n[15];
			return t[0].setComponents(s - e, f - o, p - l, n - d).normalize(), t[1].setComponents(s + e, f + o, p + l, n + d).normalize(), t[2].setComponents(s + r, f + u, p + c, n + v).normalize(), t[3].setComponents(s - r, f - u, p - c, n - v).normalize(), t[4].setComponents(s - i, f - a, p - h, n - m).normalize(), t[5].setComponents(s + i, f + a, p + h, n + m).normalize(), this
		},
		intersectsObject: function() {
			var e = new THREE.Sphere;
			return function(t) {
				var n = t.geometry;
				return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
			}
		}(),
		intersectsSphere: function(e) {
			var t = this.planes,
				n = e.center;
			e = -e.radius;
			for(var r = 0; 6 > r; r++)
				if(t[r].distanceToPoint(n) < e) return !1;
			return !0
		},
		intersectsBox: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n) {
				for(var r = this.planes, i = 0; 6 > i; i++) {
					var s = r[i];
					e.x = 0 < s.normal.x ? n.min.x : n.max.x, t.x = 0 < s.normal.x ? n.max.x : n.min.x, e.y = 0 < s.normal.y ? n.min.y : n.max.y, t.y = 0 < s.normal.y ? n.max.y : n.min.y, e.z = 0 < s.normal.z ? n.min.z : n.max.z, t.z = 0 < s.normal.z ? n.max.z : n.min.z;
					var o = s.distanceToPoint(e),
						s = s.distanceToPoint(t);
					if(0 > o && 0 > s) return !1
				}
				return !0
			}
		}(),
		containsPoint: function(e) {
			for(var t = this.planes, n = 0; 6 > n; n++)
				if(0 > t[n].distanceToPoint(e)) return !1;
			return !0
		},
		clone: function() {
			return(new THREE.Frustum).copy(this)
		}
	}, THREE.Plane = function(e, t) {
		this.normal = void 0 !== e ? e : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
	}, THREE.Plane.prototype = {
		constructor: THREE.Plane,
		set: function(e, t) {
			return this.normal.copy(e), this.constant = t, this
		},
		setComponents: function(e, t, n, r) {
			return this.normal.set(e, t, n), this.constant = r, this
		},
		setFromNormalAndCoplanarPoint: function(e, t) {
			return this.normal.copy(e), this.constant = -t.dot(this.normal), this
		},
		setFromCoplanarPoints: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n, r, i) {
				return r = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize(), this.setFromNormalAndCoplanarPoint(r, n), this
			}
		}(),
		copy: function(e) {
			return this.normal.copy(e.normal), this.constant = e.constant, this
		},
		normalize: function() {
			var e = 1 / this.normal.length();
			return this.normal.multiplyScalar(e), this.constant *= e, this
		},
		negate: function() {
			return this.constant *= -1, this.normal.negate(), this
		},
		distanceToPoint: function(e) {
			return this.normal.dot(e) + this.constant
		},
		distanceToSphere: function(e) {
			return this.distanceToPoint(e.center) - e.radius
		},
		projectPoint: function(e, t) {
			return this.orthoPoint(e, t).sub(e).negate()
		},
		orthoPoint: function(e, t) {
			var n = this.distanceToPoint(e);
			return(t || new THREE.Vector3).copy(this.normal).multiplyScalar(n)
		},
		isIntersectionLine: function(e) {
			var t = this.distanceToPoint(e.start);
			return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t
		},
		intersectLine: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				var r = n || new THREE.Vector3,
					i = t.delta(e),
					s = this.normal.dot(i);
				if(0 != s) return s = -(t.start.dot(this.normal) + this.constant) / s, 0 > s || 1 < s ? void 0 : r.copy(i).multiplyScalar(s).add(t.start);
				if(0 == this.distanceToPoint(t.start)) return r.copy(t.start)
			}
		}(),
		coplanarPoint: function(e) {
			return(e || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
		},
		applyMatrix4: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3,
				n = new THREE.Matrix3;
			return function(r, i) {
				var s = i || n.getNormalMatrix(r),
					s = e.copy(this.normal).applyMatrix3(s),
					o = this.coplanarPoint(t);
				return o.applyMatrix4(r), this.setFromNormalAndCoplanarPoint(s, o), this
			}
		}(),
		translate: function(e) {
			return this.constant -= e.dot(this.normal), this
		},
		equals: function(e) {
			return e.normal.equals(this.normal) && e.constant == this.constant
		},
		clone: function() {
			return(new THREE.Plane).copy(this)
		}
	}, THREE.Math = {
		generateUUID: function() {
			var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
				t = Array(36),
				n = 0,
				r;
			return function() {
				for(var i = 0; 36 > i; i++) 8 == i || 13 == i || 18 == i || 23 == i ? t[i] = "-" : 14 == i ? t[i] = "4" : (2 >= n && (n = 33554432 + 16777216 * Math.random() | 0), r = n & 15, n >>= 4, t[i] = e[19 == i ? r & 3 | 8 : r]);
				return t.join("")
			}
		}(),
		clamp: function(e, t, n) {
			return e < t ? t : e > n ? n : e
		},
		clampBottom: function(e, t) {
			return e < t ? t : e
		},
		mapLinear: function(e, t, n, r, i) {
			return r + (e - t) * (i - r) / (n - t)
		},
		smoothstep: function(e, t, n) {
			return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
		},
		smootherstep: function(e, t, n) {
			return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
		},
		random16: function() {
			return(65280 * Math.random() + 255 * Math.random()) / 65535
		},
		randInt: function(e, t) {
			return e + Math.floor(Math.random() * (t - e + 1))
		},
		randFloat: function(e, t) {
			return e + Math.random() * (t - e)
		},
		randFloatSpread: function(e) {
			return e * (.5 - Math.random())
		},
		sign: function(e) {
			return 0 > e ? -1 : 0 < e ? 1 : 0
		},
		degToRad: function() {
			var e = Math.PI / 180;
			return function(t) {
				return t * e
			}
		}(),
		radToDeg: function() {
			var e = 180 / Math.PI;
			return function(t) {
				return t * e
			}
		}(),
		isPowerOfTwo: function(e) {
			return 0 === (e & e - 1) && 0 !== e
		}
	}, THREE.Spline = function(e) {
		function t(e, t, n, r, i, s, o) {
			return e = .5 * (n - e), r = .5 * (r - t), (2 * (t - n) + e + r) * o + (-3 * (t - n) - 2 * e - r) * s + e * i + t
		}
		this.points = e;
		var n = [],
			r = {
				x: 0,
				y: 0,
				z: 0
			},
			i, s, o, u, a, f, l, c, h;
		this.initFromArray = function(e) {
			this.points = [];
			for(var t = 0; t < e.length; t++) this.points[t] = {
				x: e[t][0],
				y: e[t][1],
				z: e[t][2]
			}
		}, this.getPoint = function(e) {
			return i = (this.points.length - 1) * e, s = Math.floor(i), o = i - s, n[0] = 0 === s ? s : s - 1, n[1] = s, n[2] = s > this.points.length - 2 ? this.points.length - 1 : s + 1, n[3] = s > this.points.length - 3 ? this.points.length - 1 : s + 2, f = this.points[n[0]], l = this.points[n[1]], c = this.points[n[2]], h = this.points[n[3]], u = o * o, a = o * u, r.x = t(f.x, l.x, c.x, h.x, o, u, a), r.y = t(f.y, l.y, c.y, h.y, o, u, a), r.z = t(f.z, l.z, c.z, h.z, o, u, a), r
		}, this.getControlPointsArray = function() {
			var e, t, n = this.points.length,
				r = [];
			for(e = 0; e < n; e++) t = this.points[e], r[e] = [t.x, t.y, t.z];
			return r
		}, this.getLength = function(e) {
			var t, n, r, i = t = t = 0,
				s = new THREE.Vector3,
				o = new THREE.Vector3,
				u = [],
				a = 0;
			u[0] = 0, e || (e = 100), n = this.points.length * e, s.copy(this.points[0]);
			for(e = 1; e < n; e++) t = e / n, r = this.getPoint(t), o.copy(r), a += o.distanceTo(s), s.copy(r), t *= this.points.length - 1, t = Math.floor(t), t != i && (u[t] = a, i = t);
			return u[u.length] = a, {
				chunks: u,
				total: a
			}
		}, this.reparametrizeByArcLength = function(e) {
			var t, n, r, i, s, o, u = [],
				a = new THREE.Vector3,
				f = this.getLength();
			u.push(a.copy(this.points[0]).clone());
			for(t = 1; t < this.points.length; t++) {
				n = f.chunks[t] - f.chunks[t - 1], o = Math.ceil(e * n / f.total), i = (t - 1) / (this.points.length - 1), s = t / (this.points.length - 1);
				for(n = 1; n < o - 1; n++) r = i + 1 / o * n * (s - i), r = this.getPoint(r), u.push(a.copy(r).clone());
				u.push(a.copy(this.points[t]).clone())
			}
			this.points = u
		}
	}, THREE.Triangle = function(e, t, n) {
		this.a = void 0 !== e ? e : new THREE.Vector3, this.b = void 0 !== t ? t : new THREE.Vector3, this.c = void 0 !== n ? n : new THREE.Vector3
	}, THREE.Triangle.normal = function() {
		var e = new THREE.Vector3;
		return function(t, n, r, i) {
			return i = i || new THREE.Vector3, i.subVectors(r, n), e.subVectors(t, n), i.cross(e), t = i.lengthSq(), 0 < t ? i.multiplyScalar(1 / Math.sqrt(t)) : i.set(0, 0, 0)
		}
	}(), THREE.Triangle.barycoordFromPoint = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3,
			n = new THREE.Vector3;
		return function(r, i, s, o, u) {
			e.subVectors(o, i), t.subVectors(s, i), n.subVectors(r, i), r = e.dot(e), i = e.dot(t), s = e.dot(n);
			var f = t.dot(t);
			o = t.dot(n);
			var l = r * f - i * i;
			return u = u || new THREE.Vector3, 0 == l ? u.set(-2, -1, -1) : (l = 1 / l, f = (f * s - i * o) * l, r = (r * o - i * s) * l, u.set(1 - f - r, r, f))
		}
	}(), THREE.Triangle.containsPoint = function() {
		var e = new THREE.Vector3;
		return function(t, n, r, i) {
			return t = THREE.Triangle.barycoordFromPoint(t, n, r, i, e), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
		}
	}(), THREE.Triangle.prototype = {
		constructor: THREE.Triangle,
		set: function(e, t, n) {
			return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
		},
		setFromPointsAndIndices: function(e, t, n, r) {
			return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
		},
		copy: function(e) {
			return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
		},
		area: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function() {
				return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
			}
		}(),
		midpoint: function(e) {
			return(e || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
		},
		normal: function(e) {
			return THREE.Triangle.normal(this.a, this.b, this.c, e)
		},
		plane: function(e) {
			return(e || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
		},
		barycoordFromPoint: function(e, t) {
			return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
		},
		containsPoint: function(e) {
			return THREE.Triangle.containsPoint(e, this.a, this.b, this.c)
		},
		equals: function(e) {
			return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
		},
		clone: function() {
			return(new THREE.Triangle).copy(this)
		}
	}, THREE.Clock = function(e) {
		this.autoStart = void 0 !== e ? e : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
	}, THREE.Clock.prototype = {
		constructor: THREE.Clock,
		start: function() {
			this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.running = !0
		},
		stop: function() {
			this.getElapsedTime(), this.running = !1
		},
		getElapsedTime: function() {
			return this.getDelta(), this.elapsedTime
		},
		getDelta: function() {
			var e = 0;
			this.autoStart && !this.running && this.start();
			if(this.running) {
				var t = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
					e = .001 * (t - this.oldTime);
				this.oldTime = t, this.elapsedTime += e
			}
			return e
		}
	}, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
		constructor: THREE.EventDispatcher,
		apply: function(e) {
			e.addEventListener = THREE.EventDispatcher.prototype.addEventListener, e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
		},
		addEventListener: function(e, t) {
			void 0 === this._listeners && (this._listeners = {});
			var n = this._listeners;
			void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
		},
		hasEventListener: function(e, t) {
			if(void 0 === this._listeners) return !1;
			var n = this._listeners;
			return void 0 !== n[e] && -1 !== n[e].indexOf(t) ? !0 : !1
		},
		removeEventListener: function(e, t) {
			if(void 0 !== this._listeners) {
				var n = this._listeners[e];
				if(void 0 !== n) {
					var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
				}
			}
		},
		dispatchEvent: function(e) {
			if(void 0 !== this._listeners) {
				var t = this._listeners[e.type];
				if(void 0 !== t) {
					e.target = this;
					for(var n = [], r = t.length, i = 0; i < r; i++) n[i] = t[i];
					for(i = 0; i < r; i++) n[i].call(this, e)
				}
			}
		}
	},
	function(e) {
		e.Raycaster = function(t, n, r, i) {
			this.ray = new e.Ray(t, n), this.near = r || 0, this.far = i || Infinity, this.params = {
				Sprite: {},
				Mesh: {},
				PointCloud: {
					threshold: 1
				},
				LOD: {},
				Line: {}
			}
		};
		var t = function(e, t) {
				return e.distance - t.distance
			},
			n = function(e, t, r, i) {
				e.raycast(t, r);
				if(!0 === i) {
					e = e.children, i = 0;
					for(var s = e.length; i < s; i++) n(e[i], t, r, !0)
				}
			};
		e.Raycaster.prototype = {
			constructor: e.Raycaster,
			precision: 1e-4,
			linePrecision: 1,
			set: function(e, t) {
				this.ray.set(e, t)
			},
			intersectObject: function(e, r) {
				var i = [];
				return n(e, this, i, r), i.sort(t), i
			},
			intersectObjects: function(e, r) {
				for(var i = [], s = 0, o = e.length; s < o; s++) n(e[s], this, i, r);
				return i.sort(t), i
			}
		}
	}(THREE), THREE.Object3D = function() {
		this.id = THREE.Object3DIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
		var e = new THREE.Vector3,
			t = new THREE.Euler,
			n = new THREE.Quaternion,
			r = new THREE.Vector3(1, 1, 1);
		t.onChange(function() {
			n.setFromEuler(t, !1)
		}), n.onChange(function() {
			t.setFromQuaternion(n, void 0, !1)
		}), Object.defineProperties(this, {
			position: {
				enumerable: !0,
				value: e
			},
			rotation: {
				enumerable: !0,
				value: t
			},
			quaternion: {
				enumerable: !0,
				value: n
			},
			scale: {
				enumerable: !0,
				value: r
			}
		}), this.renderDepth = null, this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.userData = {}
	}, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = {
		constructor: THREE.Object3D,
		get eulerOrder() {
			return console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order
		},
		set eulerOrder(e) {
			console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = e
		},
		get useQuaternion() {
			console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
		},
		set useQuaternion(e) {
			console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
		},
		applyMatrix: function(e) {
			this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
		},
		setRotationFromAxisAngle: function(e, t) {
			this.quaternion.setFromAxisAngle(e, t)
		},
		setRotationFromEuler: function(e) {
			this.quaternion.setFromEuler(e, !0)
		},
		setRotationFromMatrix: function(e) {
			this.quaternion.setFromRotationMatrix(e)
		},
		setRotationFromQuaternion: function(e) {
			this.quaternion.copy(e)
		},
		rotateOnAxis: function() {
			var e = new THREE.Quaternion;
			return function(t, n) {
				return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
			}
		}(),
		rotateX: function() {
			var e = new THREE.Vector3(1, 0, 0);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		rotateY: function() {
			var e = new THREE.Vector3(0, 1, 0);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		rotateZ: function() {
			var e = new THREE.Vector3(0, 0, 1);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		translateOnAxis: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
			}
		}(),
		translate: function(e, t) {
			return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
		},
		translateX: function() {
			var e = new THREE.Vector3(1, 0, 0);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		translateY: function() {
			var e = new THREE.Vector3(0, 1, 0);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		translateZ: function() {
			var e = new THREE.Vector3(0, 0, 1);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		localToWorld: function(e) {
			return e.applyMatrix4(this.matrixWorld)
		},
		worldToLocal: function() {
			var e = new THREE.Matrix4;
			return function(t) {
				return t.applyMatrix4(e.getInverse(this.matrixWorld))
			}
		}(),
		lookAt: function() {
			var e = new THREE.Matrix4;
			return function(t) {
				e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
			}
		}(),
		add: function(e) {
			if(1 < arguments.length) {
				for(var t = 0; t < arguments.length; t++) this.add(arguments[t]);
				return this
			}
			if(e === this) return console.error("THREE.Object3D.add:", e, "can't be added as a child of itself."), this;
			if(e instanceof THREE.Object3D) {
				void 0 !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
					type: "added"
				}), this.children.push(e);
				for(t = this; void 0 !== t.parent;) t = t.parent;
				void 0 !== t && t instanceof THREE.Scene && t.__addObject(e)
			} else console.error("THREE.Object3D.add:", e, "is not an instance of THREE.Object3D.");
			return this
		},
		remove: function(e) {
			if(1 < arguments.length)
				for(var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
			t = this.children.indexOf(e);
			if(-1 !== t) {
				e.parent = void 0, e.dispatchEvent({
					type: "removed"
				}), this.children.splice(t, 1);
				for(t = this; void 0 !== t.parent;) t = t.parent;
				void 0 !== t && t instanceof THREE.Scene && t.__removeObject(e)
			}
		},
		raycast: function() {},
		traverse: function(e) {
			e(this);
			for(var t = 0, n = this.children.length; t < n; t++) this.children[t].traverse(e)
		},
		traverseVisible: function(e) {
			if(!1 !== this.visible) {
				e(this);
				for(var t = 0, n = this.children.length; t < n; t++) this.children[t].traverseVisible(e)
			}
		},
		getObjectById: function(e, t) {
			for(var n = 0, r = this.children.length; n < r; n++) {
				var i = this.children[n];
				if(i.id === e || !0 === t && (i = i.getObjectById(e, t), void 0 !== i)) return i
			}
		},
		getObjectByName: function(e, t) {
			for(var n = 0, r = this.children.length; n < r; n++) {
				var i = this.children[n];
				if(i.name === e || !0 === t && (i = i.getObjectByName(e, t), void 0 !== i)) return i
			}
		},
		getChildByName: function(e, t) {
			return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e, t)
		},
		updateMatrix: function() {
			this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
		},
		updateMatrixWorld: function(e) {
			!0 === this.matrixAutoUpdate && this.updateMatrix();
			if(!0 === this.matrixWorldNeedsUpdate || !0 === e) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0;
			for(var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e)
		},
		clone: function(e, t) {
			void 0 === e && (e = new THREE.Object3D), void 0 === t && (t = !0), e.name = this.name, e.up.copy(this.up), e.position.copy(this.position), e.quaternion.copy(this.quaternion), e.scale.copy(this.scale), e.renderDepth = this.renderDepth, e.rotationAutoUpdate = this.rotationAutoUpdate, e.matrix.copy(this.matrix), e.matrixWorld.copy(this.matrixWorld), e.matrixAutoUpdate = this.matrixAutoUpdate, e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, e.visible = this.visible, e.castShadow = this.castShadow, e.receiveShadow = this.receiveShadow, e.frustumCulled = this.frustumCulled, e.userData = JSON.parse(JSON.stringify(this.userData));
			if(!0 === t)
				for(var n = 0; n < this.children.length; n++) e.add(this.children[n].clone());
			return e
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Projector = function() {
		function e() {
			if(c === p) {
				var e = new THREE.RenderableVertex;
				return h.push(e), p++, c++, e
			}
			return h[c++]
		}

		function t() {
			if(v === g) {
				var e = new THREE.RenderableFace;
				return m.push(e), g++, v++, e
			}
			return m[v++]
		}

		function n() {
			if(b === E) {
				var e = new THREE.RenderableLine;
				return w.push(e), E++, b++, e
			}
			return w[b++]
		}

		function r() {
			if(x === N) {
				var e = new THREE.RenderableSprite;
				return T.push(e), N++, x++, e
			}
			return T[x++]
		}

		function i(e, t) {
			return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0
		}

		function s(e, t) {
			var n = 0,
				r = 1,
				i = e.z + e.w,
				s = t.z + t.w,
				o = -e.z + e.w,
				u = -t.z + t.w;
			return 0 <= i && 0 <= s && 0 <= o && 0 <= u ? !0 : 0 > i && 0 > s || 0 > o && 0 > u ? !1 : (0 > i ? n = Math.max(n, i / (i - s)) : 0 > s && (r = Math.min(r, i / (i - s))), 0 > o ? n = Math.max(n, o / (o - u)) : 0 > u && (r = Math.min(r, o / (o - u))), r < n ? !1 : (e.lerp(t, n), t.lerp(e, 1 - r), !0))
		}
		var o, u, a = [],
			f = 0,
			l, c, h = [],
			p = 0,
			d, v, m = [],
			g = 0,
			y, b, w = [],
			E = 0,
			S, x, T = [],
			N = 0,
			C = {
				objects: [],
				lights: [],
				elements: []
			},
			k = new THREE.Vector3,
			L = new THREE.Vector3,
			A = new THREE.Vector3,
			O = new THREE.Vector3,
			M = new THREE.Vector4,
			_ = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
			D = new THREE.Box3,
			P = Array(3),
			H = new THREE.Matrix4,
			B = new THREE.Matrix4,
			j, F = new THREE.Matrix4,
			I = new THREE.Matrix3,
			q = new THREE.Frustum,
			R = new THREE.Vector4,
			U = new THREE.Vector4;
		this.projectVector = function(e, t) {
			return t.matrixWorldInverse.getInverse(t.matrixWorld), B.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), e.applyProjection(B)
		}, this.unprojectVector = function() {
			var e = new THREE.Matrix4;
			return function(t, n) {
				return e.getInverse(n.projectionMatrix), B.multiplyMatrices(n.matrixWorld, e), t.applyProjection(B)
			}
		}(), this.pickingRay = function(e, t) {
			e.z = -1;
			var n = new THREE.Vector3(e.x, e.y, 1);
			return this.unprojectVector(e, t), this.unprojectVector(n, t), n.sub(e).normalize(), new THREE.Raycaster(e, n)
		};
		var z = new function() {
			var r = [],
				i = [],
				s = null,
				o = null,
				u = new THREE.Matrix3,
				a = function(e) {
					var t = e.positionWorld,
						n = e.positionScreen;
					t.copy(e.position).applyMatrix4(j), n.copy(t).applyMatrix4(B), t = 1 / n.w, n.x *= t, n.y *= t, n.z *= t, e.visible = -1 <= n.x && 1 >= n.x && -1 <= n.y && 1 >= n.y && -1 <= n.z && 1 >= n.z
				},
				f = function(e, t, n) {
					return !0 === e.visible || !0 === t.visible || !0 === n.visible ? !0 : (P[0] = e.positionScreen, P[1] = t.positionScreen, P[2] = n.positionScreen, _.isIntersectionBox(D.setFromPoints(P)))
				},
				c = function(e, t, n) {
					return 0 > (n.positionScreen.x - e.positionScreen.x) * (t.positionScreen.y - e.positionScreen.y) - (n.positionScreen.y - e.positionScreen.y) * (t.positionScreen.x - e.positionScreen.x)
				};
			return {
				setObject: function(e) {
					s = e, o = s.material, u.getNormalMatrix(s.matrixWorld), r.length = 0, i.length = 0
				},
				projectVertex: a,
				checkTriangleVisibility: f,
				checkBackfaceCulling: c,
				pushVertex: function(t, n, r) {
					l = e(), l.position.set(t, n, r), a(l)
				},
				pushNormal: function(e, t, n) {
					r.push(e, t, n)
				},
				pushUv: function(e, t) {
					i.push(e, t)
				},
				pushLine: function(e, t) {
					var r = h[e],
						i = h[t];
					y = n(), y.id = s.id, y.v1.copy(r), y.v2.copy(i), y.z = (r.positionScreen.z + i.positionScreen.z) / 2, y.material = s.material, C.elements.push(y)
				},
				pushTriangle: function(e, n, a) {
					var l = h[e],
						p = h[n],
						v = h[a];
					if(!1 !== f(l, p, v) && (o.side === THREE.DoubleSide || !0 === c(l, p, v))) {
						d = t(), d.id = s.id, d.v1.copy(l), d.v2.copy(p), d.v3.copy(v), d.z = (l.positionScreen.z + p.positionScreen.z + v.positionScreen.z) / 3;
						for(l = 0; 3 > l; l++) p = 3 * arguments[l], v = d.vertexNormalsModel[l], v.set(r[p], r[p + 1], r[p + 2]), v.applyMatrix3(u).normalize(), p = 2 * arguments[l], d.uvs[l].set(i[p], i[p + 1]);
						d.vertexNormalsLength = 3, d.material = s.material, C.elements.push(d)
					}
				}
			}
		};
		this.projectScene = function(l, p, m, g) {
			x = b = v = 0, C.elements.length = 0, !0 === l.autoUpdate && l.updateMatrixWorld(), void 0 === p.parent && p.updateMatrixWorld(), H.copy(p.matrixWorldInverse.getInverse(p.matrixWorld)), B.multiplyMatrices(p.projectionMatrix, H), q.setFromMatrix(B), u = 0, C.objects.length = 0, C.lights.length = 0, l.traverseVisible(function(e) {
				if(e instanceof THREE.Light) C.lights.push(e);
				else if(e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Sprite)
					if(!1 === e.frustumCulled || !0 === q.intersectsObject(e)) {
						if(u === f) {
							var t = new THREE.RenderableObject;
							a.push(t), f++, u++, o = t
						} else o = a[u++];
						o.id = e.id, o.object = e, null !== e.renderDepth ? o.z = e.renderDepth : (O.setFromMatrixPosition(e.matrixWorld), O.applyProjection(B), o.z = O.z), C.objects.push(o)
					}
			}), !0 === m && C.objects.sort(i), l = 0;
			for(m = C.objects.length; l < m; l++) {
				var w = C.objects[l].object,
					E = w.geometry;
				z.setObject(w), j = w.matrixWorld, c = 0;
				if(w instanceof THREE.Mesh) {
					if(E instanceof THREE.BufferGeometry) {
						var T = E.attributes,
							w = E.offsets;
						if(void 0 !== T.position) {
							for(var N = T.position.array, E = 0, _ = N.length; E < _; E += 3) z.pushVertex(N[E], N[E + 1], N[E + 2]);
							if(void 0 !== T.normal)
								for(var D = T.normal.array, E = 0, _ = D.length; E < _; E += 3) z.pushNormal(D[E], D[E + 1], D[E + 2]);
							if(void 0 !== T.uv)
								for(D = T.uv.array, E = 0, _ = D.length; E < _; E += 2) z.pushUv(D[E], D[E + 1]);
							if(void 0 !== T.index)
								if(T = T.index.array, 0 < w.length)
									for(l = 0; l < w.length; l++)
										for(_ = w[l], N = _.index, E = _.start, _ = _.start + _.count; E < _; E += 3) z.pushTriangle(T[E] + N, T[E + 1] + N, T[E + 2] + N);
								else
									for(E = 0, _ = T.length; E < _; E += 3) z.pushTriangle(T[E], T[E + 1], T[E + 2]);
							else
								for(E = 0, _ = N.length / 3; E < _; E += 3) z.pushTriangle(E, E + 1, E + 2)
						}
					} else if(E instanceof THREE.Geometry) {
						var P = E.vertices,
							_ = E.faces,
							T = E.faceVertexUvs[0];
						I.getNormalMatrix(j);
						for(var N = w.material instanceof THREE.MeshFaceMaterial, D = !0 === N ? w.material : null, Q = 0, G = P.length; Q < G; Q++) {
							var Y = P[Q];
							z.pushVertex(Y.x, Y.y, Y.z)
						}
						P = 0;
						for(Q = _.length; P < Q; P++) {
							var G = _[P],
								Z = !0 === N ? D.materials[G.materialIndex] : w.material;
							if(void 0 !== Z) {
								var et = Z.side,
									Y = h[G.a],
									tt = h[G.b],
									nt = h[G.c];
								if(!0 === Z.morphTargets) {
									var rt = E.morphTargets,
										it = w.morphTargetInfluences,
										st = Y.position,
										ot = tt.position,
										ut = nt.position;
									k.set(0, 0, 0), L.set(0, 0, 0), A.set(0, 0, 0);
									for(var at = 0, ft = rt.length; at < ft; at++) {
										var lt = it[at];
										if(0 !== lt) {
											var ct = rt[at].vertices;
											k.x += (ct[G.a].x - st.x) * lt, k.y += (ct[G.a].y - st.y) * lt, k.z += (ct[G.a].z - st.z) * lt, L.x += (ct[G.b].x - ot.x) * lt, L.y += (ct[G.b].y - ot.y) * lt, L.z += (ct[G.b].z - ot.z) * lt, A.x += (ct[G.c].x - ut.x) * lt, A.y += (ct[G.c].y - ut.y) * lt, A.z += (ct[G.c].z - ut.z) * lt
										}
									}
									Y.position.add(k), tt.position.add(L), nt.position.add(A), z.projectVertex(Y), z.projectVertex(tt), z.projectVertex(nt)
								}
								if(!1 !== z.checkTriangleVisibility(Y, tt, nt)) {
									rt = z.checkBackfaceCulling(Y, tt, nt);
									if(et !== THREE.DoubleSide) {
										if(et === THREE.FrontSide && !1 === rt) continue;
										if(et === THREE.BackSide && !0 === rt) continue
									}
									d = t(), d.id = w.id, d.v1.copy(Y), d.v2.copy(tt), d.v3.copy(nt), d.normalModel.copy(G.normal), !1 !== rt || et !== THREE.BackSide && et !== THREE.DoubleSide || d.normalModel.negate(), d.normalModel.applyMatrix3(I).normalize(), it = G.vertexNormals, st = 0;
									for(ot = Math.min(it.length, 3); st < ot; st++) ut = d.vertexNormalsModel[st], ut.copy(it[st]), !1 !== rt || et !== THREE.BackSide && et !== THREE.DoubleSide || ut.negate(), ut.applyMatrix3(I).normalize();
									d.vertexNormalsLength = it.length, et = T[P];
									if(void 0 !== et)
										for(rt = 0; 3 > rt; rt++) d.uvs[rt].copy(et[rt]);
									d.color = G.color, d.material = Z, d.z = (Y.positionScreen.z + tt.positionScreen.z + nt.positionScreen.z) / 3, C.elements.push(d)
								}
							}
						}
					}
				} else if(w instanceof THREE.Line) {
					if(E instanceof THREE.BufferGeometry) {
						if(T = E.attributes, void 0 !== T.position) {
							N = T.position.array, E = 0;
							for(_ = N.length; E < _; E += 3) z.pushVertex(N[E], N[E + 1], N[E + 2]);
							if(void 0 !== T.index)
								for(T = T.index.array, E = 0, _ = T.length; E < _; E += 2) z.pushLine(T[E], T[E + 1]);
							else
								for(T = w.type === THREE.LinePieces ? 2 : 1, E = 0, _ = N.length / 3 - 1; E < _; E += T) z.pushLine(E, E + 1)
						}
					} else if(E instanceof THREE.Geometry && (F.multiplyMatrices(B, j), P = w.geometry.vertices, 0 !== P.length))
						for(Y = e(), Y.positionScreen.copy(P[0]).applyMatrix4(F), T = w.type === THREE.LinePieces ? 2 : 1, Q = 1, G = P.length; Q < G; Q++) Y = e(), Y.positionScreen.copy(P[Q]).applyMatrix4(F), 0 < (Q + 1) % T || (tt = h[c - 2], R.copy(Y.positionScreen), U.copy(tt.positionScreen), !0 === s(R, U) && (R.multiplyScalar(1 / R.w), U.multiplyScalar(1 / U.w), y = n(), y.id = w.id, y.v1.positionScreen.copy(R), y.v2.positionScreen.copy(U), y.z = Math.max(R.z, U.z), y.material = w.material, w.material.vertexColors === THREE.VertexColors && (y.vertexColors[0].copy(w.geometry.colors[Q]), y.vertexColors[1].copy(w.geometry.colors[Q - 1])), C.elements.push(y)))
				} else w instanceof THREE.Sprite && (M.set(j.elements[12], j.elements[13], j.elements[14], 1), M.applyMatrix4(B), E = 1 / M.w, M.z *= E, -1 <= M.z && 1 >= M.z && (S = r(), S.id = w.id, S.x = M.x * E, S.y = M.y * E, S.z = M.z, S.object = w, S.rotation = w.rotation, S.scale.x = w.scale.x * Math.abs(S.x - (M.x + p.projectionMatrix.elements[0]) / (M.w + p.projectionMatrix.elements[12])), S.scale.y = w.scale.y * Math.abs(S.y - (M.y + p.projectionMatrix.elements[5]) / (M.w + p.projectionMatrix.elements[13])), S.material = w.material, C.elements.push(S)))
			}
			return !0 === g && C.elements.sort(i), C
		}
	}, THREE.Face3 = function(e, t, n, r, i, s) {
		this.a = e, this.b = t, this.c = n, this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3, this.vertexNormals = r instanceof Array ? r : [], this.color = i instanceof THREE.Color ? i : new THREE.Color, this.vertexColors = i instanceof Array ? i : [], this.vertexTangents = [], this.materialIndex = void 0 !== s ? s : 0
	}, THREE.Face3.prototype = {
		constructor: THREE.Face3,
		clone: function() {
			var e = new THREE.Face3(this.a, this.b, this.c);
			e.normal.copy(this.normal), e.color.copy(this.color), e.materialIndex = this.materialIndex;
			for(var t = 0, n = this.vertexNormals.length; t < n; t++) e.vertexNormals[t] = this.vertexNormals[t].clone();
			t = 0;
			for(n = this.vertexColors.length; t < n; t++) e.vertexColors[t] = this.vertexColors[t].clone();
			t = 0;
			for(n = this.vertexTangents.length; t < n; t++) e.vertexTangents[t] = this.vertexTangents[t].clone();
			return e
		}
	}, THREE.Face4 = function(e, t, n, r, i, s, o) {
		return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, n, i, s, o)
	}, THREE.BufferAttribute = function(e, t) {
		this.array = e, this.itemSize = t
	}, THREE.BufferAttribute.prototype = {
		constructor: THREE.BufferAttribute,
		get length() {
			return this.array.length
		},
		set: function(e) {
			return this.array.set(e), this
		},
		setX: function(e, t) {
			return this.array[e * this.itemSize] = t, this
		},
		setY: function(e, t) {
			return this.array[e * this.itemSize + 1] = t, this
		},
		setZ: function(e, t) {
			return this.array[e * this.itemSize + 2] = t, this
		},
		setXY: function(e, t, n) {
			return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this
		},
		setXYZ: function(e, t, n, r) {
			return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
		},
		setXYZW: function(e, t, n, r, i) {
			return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
		}
	}, THREE.Int8Attribute = function(e, t) {
		return console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Uint8Attribute = function(e, t) {
		return console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Uint8ClampedAttribute = function(e, t) {
		return console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Int16Attribute = function(e, t) {
		return console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Uint16Attribute = function(e, t) {
		return console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Int32Attribute = function(e, t) {
		return console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Uint32Attribute = function(e, t) {
		return console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Float32Attribute = function(e, t) {
		return console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.Float64Attribute = function(e, t) {
		return console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
	}, THREE.BufferGeometry = function() {
		this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.attributes = {}, this.offsets = this.drawcalls = [], this.boundingSphere = this.boundingBox = null
	}, THREE.BufferGeometry.prototype = {
		constructor: THREE.BufferGeometry,
		addAttribute: function(e, t, n) {
			0 == t instanceof THREE.BufferAttribute ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.attributes[e] = {
				array: t,
				itemSize: n
			}) : this.attributes[e] = t
		},
		getAttribute: function(e) {
			return this.attributes[e]
		},
		addDrawCall: function(e, t, n) {
			this.drawcalls.push({
				start: e,
				count: t,
				index: void 0 !== n ? n : 0
			})
		},
		applyMatrix: function(e) {
			var t = this.attributes.position;
			void 0 !== t && (e.applyToVector3Array(t.array), t.needsUpdate = !0), t = this.attributes.normal, void 0 !== t && ((new THREE.Matrix3).getNormalMatrix(e).applyToVector3Array(t.array), t.needsUpdate = !0)
		},
		fromGeometry: function(e, t) {
			t = t || {
				vertexColors: THREE.NoColors
			};
			var n = e.vertices,
				r = e.faces,
				i = e.faceVertexUvs,
				s = t.vertexColors,
				o = 0 < i[0].length,
				u = 3 == r[0].vertexNormals.length,
				a = new Float32Array(9 * r.length);
			this.addAttribute("position", new THREE.BufferAttribute(a, 3));
			var f = new Float32Array(9 * r.length);
			this.addAttribute("normal", new THREE.BufferAttribute(f, 3));
			if(s !== THREE.NoColors) {
				var l = new Float32Array(9 * r.length);
				this.addAttribute("color", new THREE.BufferAttribute(l, 3))
			}
			if(!0 === o) {
				var c = new Float32Array(6 * r.length);
				this.addAttribute("uvs", new THREE.BufferAttribute(c, 2))
			}
			for(var h = 0, p = 0, d = 0; h < r.length; h++, p += 6, d += 9) {
				var v = r[h],
					m = n[v.a],
					g = n[v.b],
					y = n[v.c];
				a[d] = m.x, a[d + 1] = m.y, a[d + 2] = m.z, a[d + 3] = g.x, a[d + 4] = g.y, a[d + 5] = g.z, a[d + 6] = y.x, a[d + 7] = y.y, a[d + 8] = y.z, !0 === u ? (m = v.vertexNormals[0], g = v.vertexNormals[1], y = v.vertexNormals[2], f[d] = m.x, f[d + 1] = m.y, f[d + 2] = m.z, f[d + 3] = g.x, f[d + 4] = g.y, f[d + 5] = g.z, f[d + 6] = y.x, f[d + 7] = y.y, f[d + 8] = y.z) : (m = v.normal, f[d] = m.x, f[d + 1] = m.y, f[d + 2] = m.z, f[d + 3] = m.x, f[d + 4] = m.y, f[d + 5] = m.z, f[d + 6] = m.x, f[d + 7] = m.y, f[d + 8] = m.z), s === THREE.FaceColors ? (v = v.color, l[d] = v.r, l[d + 1] = v.g, l[d + 2] = v.b, l[d + 3] = v.r, l[d + 4] = v.g, l[d + 5] = v.b, l[d + 6] = v.r, l[d + 7] = v.g, l[d + 8] = v.b) : s === THREE.VertexColors && (m = v.vertexColors[0], g = v.vertexColors[1], v = v.vertexColors[2], l[d] = m.r, l[d + 1] = m.g, l[d + 2] = m.b, l[d + 3] = g.r, l[d + 4] = g.g, l[d + 5] = g.b, l[d + 6] = v.r, l[d + 7] = v.g, l[d + 8] = v.b), !0 === o && (v = i[0][h][0], m = i[0][h][1], g = i[0][h][2], c[p] = v.x, c[p + 1] = v.y, c[p + 2] = m.x, c[p + 3] = m.y, c[p + 4] = g.x, c[p + 5] = g.y)
			}
			return this.computeBoundingSphere(), this
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new THREE.Box3);
			var e = this.attributes.position.array;
			if(e) {
				var t = this.boundingBox;
				3 <= e.length && (t.min.x = t.max.x = e[0], t.min.y = t.max.y = e[1], t.min.z = t.max.z = e[2]);
				for(var n = 3, r = e.length; n < r; n += 3) {
					var i = e[n],
						s = e[n + 1],
						o = e[n + 2];
					i < t.min.x ? t.min.x = i : i > t.max.x && (t.max.x = i), s < t.min.y ? t.min.y = s : s > t.max.y && (t.max.y = s), o < t.min.z ? t.min.z = o : o > t.max.z && (t.max.z = o)
				}
			}
			if(void 0 === e || 0 === e.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
			(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
		},
		computeBoundingSphere: function() {
			var e = new THREE.Box3,
				t = new THREE.Vector3;
			return function() {
				null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
				var n = this.attributes.position.array;
				if(n) {
					e.makeEmpty();
					for(var r = this.boundingSphere.center, i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), e.expandByPoint(t);
					e.center(r);
					for(var o = 0, i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), o = Math.max(o, r.distanceToSquared(t));
					this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
				}
			}
		}(),
		computeFaceNormals: function() {},
		computeVertexNormals: function() {
			if(this.attributes.position) {
				var e, t, n, r;
				e = this.attributes.position.array.length;
				if(void 0 === this.attributes.normal) this.attributes.normal = {
					itemSize: 3,
					array: new Float32Array(e)
				};
				else
					for(e = 0, t = this.attributes.normal.array.length; e < t; e++) this.attributes.normal.array[e] = 0;
				var i = this.attributes.position.array,
					s = this.attributes.normal.array,
					o, u, a, f, l, c, h = new THREE.Vector3,
					p = new THREE.Vector3,
					d = new THREE.Vector3,
					v = new THREE.Vector3,
					m = new THREE.Vector3;
				if(this.attributes.index) {
					var g = this.attributes.index.array,
						y = 0 < this.offsets.length ? this.offsets : [{
							start: 0,
							count: g.length,
							index: 0
						}];
					n = 0;
					for(r = y.length; n < r; ++n) {
						t = y[n].start, o = y[n].count;
						var b = y[n].index;
						e = t;
						for(t += o; e < t; e += 3) o = b + g[e], u = b + g[e + 1], a = b + g[e + 2], f = i[3 * o], l = i[3 * o + 1], c = i[3 * o + 2], h.set(f, l, c), f = i[3 * u], l = i[3 * u + 1], c = i[3 * u + 2], p.set(f, l, c), f = i[3 * a], l = i[3 * a + 1], c = i[3 * a + 2], d.set(f, l, c), v.subVectors(d, p), m.subVectors(h, p), v.cross(m), s[3 * o] += v.x, s[3 * o + 1] += v.y, s[3 * o + 2] += v.z, s[3 * u] += v.x, s[3 * u + 1] += v.y, s[3 * u + 2] += v.z, s[3 * a] += v.x, s[3 * a + 1] += v.y, s[3 * a + 2] += v.z
					}
				} else
					for(e = 0, t = i.length; e < t; e += 9) f = i[e], l = i[e + 1], c = i[e + 2], h.set(f, l, c), f = i[e + 3], l = i[e + 4], c = i[e + 5], p.set(f, l, c), f = i[e + 6], l = i[e + 7], c = i[e + 8], d.set(f, l, c), v.subVectors(d, p), m.subVectors(h, p), v.cross(m), s[e] = v.x, s[e + 1] = v.y, s[e + 2] = v.z, s[e + 3] = v.x, s[e + 4] = v.y, s[e + 5] = v.z, s[e + 6] = v.x, s[e + 7] = v.y, s[e + 8] = v.z;
				this.normalizeNormals(), this.normalsNeedUpdate = !0
			}
		},
		computeTangents: function() {
			function e(e, t, n) {
				c = r[3 * e], h = r[3 * e + 1], p = r[3 * e + 2], d = r[3 * t], v = r[3 * t + 1], m = r[3 * t + 2], g = r[3 * n], y = r[3 * n + 1], b = r[3 * n + 2], w = s[2 * e], E = s[2 * e + 1], S = s[2 * t], x = s[2 * t + 1], T = s[2 * n], N = s[2 * n + 1], C = d - c, k = g - c, L = v - h, A = y - h, O = m - p, M = b - p, _ = S - w, D = T - w, P = x - E, H = N - E, B = 1 / (_ * H - D * P), j.set((H * C - P * k) * B, (H * L - P * A) * B, (H * O - P * M) * B), F.set((_ * k - D * C) * B, (_ * A - D * L) * B, (_ * M - D * O) * B), a[e].add(j), a[t].add(j), a[n].add(j), f[e].add(F), f[t].add(F), f[n].add(F)
			}

			function t(e) {
				J.x = i[3 * e], J.y = i[3 * e + 1], J.z = i[3 * e + 2], K.copy(J), G = a[e], V.copy(G), V.sub(J.multiplyScalar(J.dot(G))).normalize(), $.crossVectors(K, G), Y = $.dot(f[e]), Q = 0 > Y ? -1 : 1, u[4 * e] = V.x, u[4 * e + 1] = V.y, u[4 * e + 2] = V.z, u[4 * e + 3] = Q
			}
			if(void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
			else {
				var n = this.attributes.index.array,
					r = this.attributes.position.array,
					i = this.attributes.normal.array,
					s = this.attributes.uv.array,
					o = r.length / 3;
				void 0 === this.attributes.tangent && (this.attributes.tangent = {
					itemSize: 4,
					array: new Float32Array(4 * o)
				});
				for(var u = this.attributes.tangent.array, a = [], f = [], l = 0; l < o; l++) a[l] = new THREE.Vector3, f[l] = new THREE.Vector3;
				var c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _, D, P, H, B, j = new THREE.Vector3,
					F = new THREE.Vector3,
					I, q, R, U, z, W = this.offsets,
					l = 0;
				for(q = W.length; l < q; ++l) {
					I = W[l].start, R = W[l].count;
					var X = W[l].index,
						o = I;
					for(I += R; o < I; o += 3) R = X + n[o], U = X + n[o + 1], z = X + n[o + 2], e(R, U, z)
				}
				var V = new THREE.Vector3,
					$ = new THREE.Vector3,
					J = new THREE.Vector3,
					K = new THREE.Vector3,
					Q, G, Y, l = 0;
				for(q = W.length; l < q; ++l)
					for(I = W[l].start, R = W[l].count, X = W[l].index, o = I, I += R; o < I; o += 3) R = X + n[o], U = X + n[o + 1], z = X + n[o + 2], t(R), t(U), t(z)
			}
		},
		computeOffsets: function(e) {
			var t = e;
			void 0 === e && (t = 65535), Date.now(), e = this.attributes.index.array;
			for(var n = this.attributes.position.array, r = e.length / 3, i = new Uint16Array(e.length), s = 0, o = 0, u = [{
					start: 0,
					count: 0,
					index: 0
				}], a = u[0], f = 0, l = 0, c = new Int32Array(6), h = new Int32Array(n.length), p = new Int32Array(n.length), d = 0; d < n.length; d++) h[d] = -1, p[d] = -1;
			for(n = 0; n < r; n++) {
				for(var v = l = 0; 3 > v; v++) d = e[3 * n + v], -1 == h[d] ? (c[2 * v] = d, c[2 * v + 1] = -1, l++) : h[d] < a.index ? (c[2 * v] = d, c[2 * v + 1] = -1, f++) : (c[2 * v] = d, c[2 * v + 1] = h[d]);
				if(o + l > a.index + t)
					for(a = {
							start: s,
							count: 0,
							index: o
						}, u.push(a), l = 0; 6 > l; l += 2) v = c[l + 1], -1 < v && v < a.index && (c[l + 1] = -1);
				for(l = 0; 6 > l; l += 2) d = c[l], v = c[l + 1], -1 === v && (v = o++), h[d] = v, p[v] = d, i[s++] = v - a.index, a.count++
			}
			return this.reorderBuffers(i, p, o), this.offsets = u
		},
		merge: function() {
			console.log("BufferGeometry.merge(): TODO")
		},
		normalizeNormals: function() {
			for(var e = this.attributes.normal.array, t, n, r, i = 0, s = e.length; i < s; i += 3) t = e[i], n = e[i + 1], r = e[i + 2], t = 1 / Math.sqrt(t * t + n * n + r * r), e[i] *= t, e[i + 1] *= t, e[i + 2] *= t
		},
		reorderBuffers: function(e, t, n) {
			var r = {},
				i = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
				s;
			for(s in this.attributes)
				if("index" != s)
					for(var o = this.attributes[s].array, u = 0, a = i.length; u < a; u++) {
						var f = i[u];
						if(o instanceof f) {
							r[s] = new f(this.attributes[s].itemSize * n);
							break
						}
					}
			for(i = 0; i < n; i++)
				for(s in o = t[i], this.attributes)
					if("index" != s)
						for(var u = this.attributes[s].array, a = this.attributes[s].itemSize, f = r[s], l = 0; l < a; l++) f[i * a + l] = u[o * a + l];
			this.attributes.index.array = e;
			for(s in this.attributes) "index" != s && (this.attributes[s].array = r[s], this.attributes[s].numItems = this.attributes[s].itemSize * n)
		},
		clone: function() {
			var e = new THREE.BufferGeometry,
				t = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
				n;
			for(n in this.attributes) {
				for(var r = this.attributes[n], i = r.array, s = {
						itemSize: r.itemSize,
						array: null
					}, r = 0, o = t.length; r < o; r++) {
					var u = t[r];
					if(i instanceof u) {
						s.array = new u(i);
						break
					}
				}
				e.attributes[n] = s
			}
			r = 0;
			for(o = this.offsets.length; r < o; r++) t = this.offsets[r], e.offsets.push({
				start: t.start,
				index: t.index,
				count: t.count
			});
			return e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function() {
		this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
			[]
		], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.hasTangents = !1, this.dynamic = !0, this.groupsNeedUpdate = this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
	}, THREE.Geometry.prototype = {
		constructor: THREE.Geometry,
		applyMatrix: function(e) {
			for(var t = (new THREE.Matrix3).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(e);
			n = 0;
			for(r = this.faces.length; n < r; n++) {
				e = this.faces[n], e.normal.applyMatrix3(t).normalize();
				for(var i = 0, s = e.vertexNormals.length; i < s; i++) e.vertexNormals[i].applyMatrix3(t).normalize()
			}
			this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
		},
		center: function() {
			this.computeBoundingBox();
			var e = new THREE.Vector3;
			return e.addVectors(this.boundingBox.min, this.boundingBox.max), e.multiplyScalar(-0.5), this.applyMatrix((new THREE.Matrix4).makeTranslation(e.x, e.y, e.z)), this.computeBoundingBox(), e
		},
		computeFaceNormals: function() {
			for(var e = new THREE.Vector3, t = new THREE.Vector3, n = 0, r = this.faces.length; n < r; n++) {
				var i = this.faces[n],
					s = this.vertices[i.a],
					o = this.vertices[i.b];
				e.subVectors(this.vertices[i.c], o), t.subVectors(s, o), e.cross(t), e.normalize(), i.normal.copy(e)
			}
		},
		computeVertexNormals: function(e) {
			var t, n, r;
			r = Array(this.vertices.length), t = 0;
			for(n = this.vertices.length; t < n; t++) r[t] = new THREE.Vector3;
			if(e) {
				var i, s, o, u = new THREE.Vector3,
					a = new THREE.Vector3;
				new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, e = 0;
				for(t = this.faces.length; e < t; e++) n = this.faces[e], i = this.vertices[n.a], s = this.vertices[n.b], o = this.vertices[n.c], u.subVectors(o, s), a.subVectors(i, s), u.cross(a), r[n.a].add(u), r[n.b].add(u), r[n.c].add(u)
			} else
				for(e = 0, t = this.faces.length; e < t; e++) n = this.faces[e], r[n.a].add(n.normal), r[n.b].add(n.normal), r[n.c].add(n.normal);
			t = 0;
			for(n = this.vertices.length; t < n; t++) r[t].normalize();
			e = 0;
			for(t = this.faces.length; e < t; e++) n = this.faces[e], n.vertexNormals[0] = r[n.a].clone(), n.vertexNormals[1] = r[n.b].clone(), n.vertexNormals[2] = r[n.c].clone()
		},
		computeMorphNormals: function() {
			var e, t, n, r, i;
			n = 0;
			for(r = this.faces.length; n < r; n++)
				for(i = this.faces[n], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
			var s = new THREE.Geometry;
			s.faces = this.faces, e = 0;
			for(t = this.morphTargets.length; e < t; e++) {
				if(!this.morphNormals[e]) {
					this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], i = this.morphNormals[e].faceNormals;
					var o = this.morphNormals[e].vertexNormals,
						u, a;
					n = 0;
					for(r = this.faces.length; n < r; n++) u = new THREE.Vector3, a = {
						a: new THREE.Vector3,
						b: new THREE.Vector3,
						c: new THREE.Vector3
					}, i.push(u), o.push(a)
				}
				o = this.morphNormals[e], s.vertices = this.morphTargets[e].vertices, s.computeFaceNormals(), s.computeVertexNormals(), n = 0;
				for(r = this.faces.length; n < r; n++) i = this.faces[n], u = o.faceNormals[n], a = o.vertexNormals[n], u.copy(i.normal), a.a.copy(i.vertexNormals[0]), a.b.copy(i.vertexNormals[1]), a.c.copy(i.vertexNormals[2])
			}
			n = 0;
			for(r = this.faces.length; n < r; n++) i = this.faces[n], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
		},
		computeTangents: function() {
			var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g = [],
				y = [];
			n = new THREE.Vector3;
			var b = new THREE.Vector3,
				w = new THREE.Vector3,
				E = new THREE.Vector3,
				S = new THREE.Vector3;
			e = 0;
			for(t = this.vertices.length; e < t; e++) g[e] = new THREE.Vector3, y[e] = new THREE.Vector3;
			e = 0;
			for(t = this.faces.length; e < t; e++) i = this.faces[e], s = this.faceVertexUvs[0][e], r = i.a, m = i.b, i = i.c, o = this.vertices[r], u = this.vertices[m], a = this.vertices[i], f = s[0], l = s[1], c = s[2], s = u.x - o.x, h = a.x - o.x, p = u.y - o.y, d = a.y - o.y, u = u.z - o.z, o = a.z - o.z, a = l.x - f.x, v = c.x - f.x, l = l.y - f.y, f = c.y - f.y, c = 1 / (a * f - v * l), n.set((f * s - l * h) * c, (f * p - l * d) * c, (f * u - l * o) * c), b.set((a * h - v * s) * c, (a * d - v * p) * c, (a * o - v * u) * c), g[r].add(n), g[m].add(n), g[i].add(n), y[r].add(b), y[m].add(b), y[i].add(b);
			b = ["a", "b", "c", "d"], e = 0;
			for(t = this.faces.length; e < t; e++)
				for(i = this.faces[e], n = 0; n < Math.min(i.vertexNormals.length, 3); n++) S.copy(i.vertexNormals[n]), r = i[b[n]], m = g[r], w.copy(m), w.sub(S.multiplyScalar(S.dot(m))).normalize(), E.crossVectors(i.vertexNormals[n], m), r = E.dot(y[r]), r = 0 > r ? -1 : 1, i.vertexTangents[n] = new THREE.Vector4(w.x, w.y, w.z, r);
			this.hasTangents = !0
		},
		computeLineDistances: function() {
			for(var e = 0, t = this.vertices, n = 0, r = t.length; n < r; n++) 0 < n && (e += t[n].distanceTo(t[n - 1])), this.lineDistances[n] = e
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
		},
		computeBoundingSphere: function() {
			null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
		},
		merge: function(e, t, n) {
			if(0 == e instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
			else {
				var r, i = this.vertices.length,
					s = this.vertices,
					o = e.vertices,
					u = this.faces,
					a = e.faces,
					f = this.faceVertexUvs[0];
				e = e.faceVertexUvs[0], void 0 === n && (n = 0), void 0 !== t && (r = (new THREE.Matrix3).getNormalMatrix(t));
				for(var l = 0, c = o.length; l < c; l++) {
					var h = o[l].clone();
					void 0 !== t && h.applyMatrix4(t), s.push(h)
				}
				l = 0;
				for(c = a.length; l < c; l++) {
					var o = a[l],
						p, d = o.vertexNormals,
						v = o.vertexColors,
						h = new THREE.Face3(o.a + i, o.b + i, o.c + i);
					h.normal.copy(o.normal), void 0 !== r && h.normal.applyMatrix3(r).normalize(), t = 0;
					for(s = d.length; t < s; t++) p = d[t].clone(), void 0 !== r && p.applyMatrix3(r).normalize(), h.vertexNormals.push(p);
					h.color.copy(o.color), t = 0;
					for(s = v.length; t < s; t++) p = v[t], h.vertexColors.push(p.clone());
					h.materialIndex = o.materialIndex + n, u.push(h)
				}
				l = 0;
				for(c = e.length; l < c; l++)
					if(n = e[l], r = [], void 0 !== n) {
						t = 0;
						for(s = n.length; t < s; t++) r.push(new THREE.Vector2(n[t].x, n[t].y));
						f.push(r)
					}
			}
		},
		mergeVertices: function() {
			var e = {},
				t = [],
				n = [],
				r, i = Math.pow(10, 4),
				s, o;
			s = 0;
			for(o = this.vertices.length; s < o; s++) r = this.vertices[s], r = Math.round(r.x * i) + "_" + Math.round(r.y * i) + "_" + Math.round(r.z * i), void 0 === e[r] ? (e[r] = s, t.push(this.vertices[s]), n[s] = t.length - 1) : n[s] = n[e[r]];
			e = [], s = 0;
			for(o = this.faces.length; s < o; s++)
				for(i = this.faces[s], i.a = n[i.a], i.b = n[i.b], i.c = n[i.c], i = [i.a, i.b, i.c], r = 0; 3 > r; r++)
					if(i[r] == i[(r + 1) % 3]) {
						e.push(s);
						break
					}
			for(s = e.length - 1; 0 <= s; s--)
				for(i = e[s], this.faces.splice(i, 1), n = 0, o = this.faceVertexUvs.length; n < o; n++) this.faceVertexUvs[n].splice(i, 1);
			return s = this.vertices.length - t.length, this.vertices = t, s
		},
		makeGroups: function() {
			var e = 0;
			return function(t, n) {
				var r, i, s, o, u = {},
					f, l = this.morphTargets.length,
					c = this.morphNormals.length;
				this.geometryGroups = {}, this.geometryGroupsList = [], r = 0;
				for(i = this.faces.length; r < i; r++) s = this.faces[r], s = t ? s.materialIndex : 0, s in u || (u[s] = {
					hash: s,
					counter: 0
				}), o = u[s].hash + "_" + u[s].counter, o in this.geometryGroups || (f = {
					id: e++,
					faces3: [],
					materialIndex: s,
					vertices: 0,
					numMorphTargets: l,
					numMorphNormals: c
				}, this.geometryGroups[o] = f, this.geometryGroupsList.push(f)), this.geometryGroups[o].vertices + 3 > n && (u[s].counter += 1, o = u[s].hash + "_" + u[s].counter, o in this.geometryGroups || (f = {
					id: e++,
					faces3: [],
					materialIndex: s,
					vertices: 0,
					numMorphTargets: l,
					numMorphNormals: c
				}, this.geometryGroups[o] = f, this.geometryGroupsList.push(f))), this.geometryGroups[o].faces3.push(r), this.geometryGroups[o].vertices += 3
			}
		}(),
		clone: function() {
			for(var e = new THREE.Geometry, t = this.vertices, n = 0, r = t.length; n < r; n++) e.vertices.push(t[n].clone());
			t = this.faces, n = 0;
			for(r = t.length; n < r; n++) e.faces.push(t[n].clone());
			t = this.faceVertexUvs[0], n = 0;
			for(r = t.length; n < r; n++) {
				for(var i = t[n], s = [], o = 0, u = i.length; o < u; o++) s.push(new THREE.Vector2(i[o].x, i[o].y));
				e.faceVertexUvs[0].push(s)
			}
			return e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Camera = function() {
		THREE.Object3D.call(this), this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
	}, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.lookAt = function() {
		var e = new THREE.Matrix4;
		return function(t) {
			e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e)
		}
	}(), THREE.Camera.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, e), e.matrixWorldInverse.copy(this.matrixWorldInverse), e.projectionMatrix.copy(this.projectionMatrix), e
	}, THREE.CubeCamera = function(e, t, n) {
		THREE.Object3D.call(this);
		var r = new THREE.PerspectiveCamera(90, 1, e, t);
		r.up.set(0, -1, 0), r.lookAt(new THREE.Vector3(1, 0, 0)), this.add(r);
		var i = new THREE.PerspectiveCamera(90, 1, e, t);
		i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(i);
		var s = new THREE.PerspectiveCamera(90, 1, e, t);
		s.up.set(0, 0, 1), s.lookAt(new THREE.Vector3(0, 1, 0)), this.add(s);
		var o = new THREE.PerspectiveCamera(90, 1, e, t);
		o.up.set(0, 0, -1), o.lookAt(new THREE.Vector3(0, -1, 0)), this.add(o);
		var u = new THREE.PerspectiveCamera(90, 1, e, t);
		u.up.set(0, -1, 0), u.lookAt(new THREE.Vector3(0, 0, 1)), this.add(u);
		var a = new THREE.PerspectiveCamera(90, 1, e, t);
		a.up.set(0, -1, 0), a.lookAt(new THREE.Vector3(0, 0, -1)), this.add(a), this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, {
			format: THREE.RGBFormat,
			magFilter: THREE.LinearFilter,
			minFilter: THREE.LinearFilter
		}), this.updateCubeMap = function(e, t) {
			var n = this.renderTarget,
				l = n.generateMipmaps;
			n.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, r, n), n.activeCubeFace = 1, e.render(t, i, n), n.activeCubeFace = 2, e.render(t, s, n), n.activeCubeFace = 3, e.render(t, o, n), n.activeCubeFace = 4, e.render(t, u, n), n.generateMipmaps = l, n.activeCubeFace = 5, e.render(t, a, n)
		}
	}, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.OrthographicCamera = function(e, t, n, r, i, s) {
		THREE.Camera.call(this), this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
	}, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
		this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
	}, THREE.OrthographicCamera.prototype.clone = function() {
		var e = new THREE.OrthographicCamera;
		return THREE.Camera.prototype.clone.call(this, e), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e
	}, THREE.PerspectiveCamera = function(e, t, n, r) {
		THREE.Camera.call(this), this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
	}, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.setLens = function(e, t) {
		void 0 === t && (t = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
	}, THREE.PerspectiveCamera.prototype.setViewOffset = function(e, t, n, r, i, s) {
		this.fullWidth = e, this.fullHeight = t, this.x = n, this.y = r, this.width = i, this.height = s, this.updateProjectionMatrix()
	}, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
		if(this.fullWidth) {
			var e = this.fullWidth / this.fullHeight,
				t = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near,
				n = -t,
				r = e * n,
				e = Math.abs(e * t - r),
				n = Math.abs(t - n);
			this.projectionMatrix.makeFrustum(r + this.x * e / this.fullWidth, r + (this.x + this.width) * e / this.fullWidth, t - (this.y + this.height) * n / this.fullHeight, t - this.y * n / this.fullHeight, this.near, this.far)
		} else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
	}, THREE.PerspectiveCamera.prototype.clone = function() {
		var e = new THREE.PerspectiveCamera;
		return THREE.Camera.prototype.clone.call(this, e), e.fov = this.fov, e.aspect = this.aspect, e.near = this.near, e.far = this.far, e
	}, THREE.Light = function(e) {
		THREE.Object3D.call(this), this.color = new THREE.Color(e)
	}, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Light), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e
	}, THREE.AmbientLight = function(e) {
		THREE.Light.call(this, e)
	}, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.clone = function() {
		var e = new THREE.AmbientLight;
		return THREE.Light.prototype.clone.call(this, e), e
	}, THREE.AreaLight = function(e, t) {
		THREE.Light.call(this, e), this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== t ? t : 1, this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
	}, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight = function(e, t) {
		THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
	}, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.clone = function() {
		var e = new THREE.DirectionalLight;
		return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraLeft = this.shadowCameraLeft, e.shadowCameraRight = this.shadowCameraRight, e.shadowCameraTop = this.shadowCameraTop, e.shadowCameraBottom = this.shadowCameraBottom, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e.shadowCascade = this.shadowCascade, e.shadowCascadeOffset.copy(this.shadowCascadeOffset), e.shadowCascadeCount = this.shadowCascadeCount, e.shadowCascadeBias = this.shadowCascadeBias.slice(0), e.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), e.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), e.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), e.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), e
	}, THREE.HemisphereLight = function(e, t, n) {
		THREE.Light.call(this, e), this.position.set(0, 100, 0), this.groundColor = new THREE.Color(t), this.intensity = void 0 !== n ? n : 1
	}, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.clone = function() {
		var e = new THREE.HemisphereLight;
		return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), e.intensity = this.intensity, e
	}, THREE.PointLight = function(e, t, n) {
		THREE.Light.call(this, e), this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0
	}, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.clone = function() {
		var e = new THREE.PointLight;
		return THREE.Light.prototype.clone.call(this, e), e.intensity = this.intensity, e.distance = this.distance, e
	}, THREE.SpotLight = function(e, t, n, r, i) {
		THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.exponent = void 0 !== i ? i : 10, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
	}, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.clone = function() {
		var e = new THREE.SpotLight;
		return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.distance = this.distance, e.angle = this.angle, e.exponent = this.exponent, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraFov = this.shadowCameraFov, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e
	}, THREE.Cache = function() {
		this.files = {}
	}, THREE.Cache.prototype = {
		constructor: THREE.Cache,
		add: function(e, t) {
			this.files[e] = t
		},
		get: function(e) {
			return this.files[e]
		},
		remove: function(e) {
			delete this.files[e]
		},
		clear: function() {
			this.files = {}
		}
	}, THREE.Loader = function(e) {
		this.statusDomElement = (this.showStatus = e) ? THREE.Loader.prototype.addStatusElement() : null, this.imageLoader = new THREE.ImageLoader, this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
	}, THREE.Loader.prototype = {
		constructor: THREE.Loader,
		crossOrigin: void 0,
		addStatusElement: function() {
			var e = document.createElement("div");
			return e.style.position = "absolute", e.style.right = "0px", e.style.top = "0px", e.style.fontSize = "0.8em", e.style.textAlign = "left", e.style.background = "rgba(0,0,0,0.25)", e.style.color = "#fff", e.style.width = "120px", e.style.padding = "0.5em 0.5em 0.5em 0.5em", e.style.zIndex = 1e3, e.innerHTML = "Loading ...", e
		},
		updateProgress: function(e) {
			var t = "Loaded ",
				t = e.total ? t + ((100 * e.loaded / e.total).toFixed(0) + "%") : t + ((e.loaded / 1024).toFixed(2) + " KB");
			this.statusDomElement.innerHTML = t
		},
		extractUrlBase: function(e) {
			return e = e.split("/"), 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
		},
		initMaterials: function(e, t) {
			for(var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t);
			return n
		},
		needsTangents: function(e) {
			for(var t = 0, n = e.length; t < n; t++)
				if(e[t] instanceof THREE.ShaderMaterial) return !0;
			return !1
		},
		createMaterial: function(e, t) {
			function n(e) {
				return e = Math.log(e) / Math.LN2, Math.pow(2, Math.round(e))
			}

			function r(e, r, i, o, u, a, l) {
				var h = t + i,
					p, d = THREE.Loader.Handlers.get(h);
				null !== d ? p = d.load(h) : (p = new THREE.Texture, d = s.imageLoader, d.crossOrigin = s.crossOrigin, d.load(h, function(e) {
					if(!1 === THREE.Math.isPowerOfTwo(e.width) || !1 === THREE.Math.isPowerOfTwo(e.height)) {
						var t = n(e.width),
							r = n(e.height),
							i = document.createElement("canvas");
						i.width = t, i.height = r, i.getContext("2d").drawImage(e, 0, 0, t, r), p.image = i
					} else p.image = e;
					p.needsUpdate = !0
				})), p.sourceFile = i, o && (p.repeat.set(o[0], o[1]), 1 !== o[0] && (p.wrapS = THREE.RepeatWrapping), 1 !== o[1] && (p.wrapT = THREE.RepeatWrapping)), u && p.offset.set(u[0], u[1]), a && (i = {
					repeat: THREE.RepeatWrapping,
					mirror: THREE.MirroredRepeatWrapping
				}, void 0 !== i[a[0]] && (p.wrapS = i[a[0]]), void 0 !== i[a[1]] && (p.wrapT = i[a[1]])), l && (p.anisotropy = l), e[r] = p
			}

			function i(e) {
				return(255 * e[0] << 16) + (255 * e[1] << 8) + 255 * e[2]
			}
			var s = this,
				o = "MeshLambertMaterial",
				u = {
					color: 15658734,
					opacity: 1,
					map: null,
					lightMap: null,
					normalMap: null,
					bumpMap: null,
					wireframe: !1
				};
			if(e.shading) {
				var a = e.shading.toLowerCase();
				"phong" === a ? o = "MeshPhongMaterial" : "basic" === a && (o = "MeshBasicMaterial")
			}
			void 0 !== e.blending && void 0 !== THREE[e.blending] && (u.blending = THREE[e.blending]);
			if(void 0 !== e.transparent || 1 > e.opacity) u.transparent = e.transparent;
			return void 0 !== e.depthTest && (u.depthTest = e.depthTest), void 0 !== e.depthWrite && (u.depthWrite = e.depthWrite), void 0 !== e.visible && (u.visible = e.visible), void 0 !== e.flipSided && (u.side = THREE.BackSide), void 0 !== e.doubleSided && (u.side = THREE.DoubleSide), void 0 !== e.wireframe && (u.wireframe = e.wireframe), void 0 !== e.vertexColors && ("face" === e.vertexColors ? u.vertexColors = THREE.FaceColors : e.vertexColors && (u.vertexColors = THREE.VertexColors)), e.colorDiffuse ? u.color = i(e.colorDiffuse) : e.DbgColor && (u.color = e.DbgColor), e.colorSpecular && (u.specular = i(e.colorSpecular)), e.colorAmbient && (u.ambient = i(e.colorAmbient)), e.colorEmissive && (u.emissive = i(e.colorEmissive)), e.transparency && (u.opacity = e.transparency), e.specularCoef && (u.shininess = e.specularCoef), e.mapDiffuse && t && r(u, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy), e.mapLight && t && r(u, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy), e.mapBump && t && r(u, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy), e.mapNormal && t && r(u, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy), e.mapSpecular && t && r(u, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy), e.mapAlpha && t && r(u, "alphaMap", e.mapAlpha, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy), e.mapBumpScale && (u.bumpScale = e.mapBumpScale), e.mapNormal ? (o = THREE.ShaderLib.normalmap, a = THREE.UniformsUtils.clone(o.uniforms), a.tNormal.value = u.normalMap, e.mapNormalFactor && a.uNormalScale.value.set(e.mapNormalFactor, e.mapNormalFactor), u.map && (a.tDiffuse.value = u.map, a.enableDiffuse.value = !0), u.specularMap && (a.tSpecular.value = u.specularMap, a.enableSpecular.value = !0), u.lightMap && (a.tAO.value = u.lightMap, a.enableAO.value = !0), a.diffuse.value.setHex(u.color), a.specular.value.setHex(u.specular), a.ambient.value.setHex(u.ambient), a.shininess.value = u.shininess, void 0 !== u.opacity && (a.opacity.value = u.opacity), o = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: a,
				lights: !0,
				fog: !0
			}), u.transparent && (o.transparent = !0)) : o = new THREE[o](u), void 0 !== e.DbgName && (o.name = e.DbgName), o
		}
	}, THREE.Loader.Handlers = {
		handlers: [],
		add: function(e, t) {
			this.handlers.push(e, t)
		},
		get: function(e) {
			for(var t = 0, n = this.handlers.length; t < n; t += 2) {
				var r = this.handlers[t + 1];
				if(this.handlers[t].test(e)) return r
			}
			return null
		}
	}, THREE.XHRLoader = function(e) {
		this.cache = new THREE.Cache, this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.XHRLoader.prototype = {
		constructor: THREE.XHRLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = i.cache.get(e);
			void 0 !== s ? t && t(s) : (s = new XMLHttpRequest, s.open("GET", e, !0), s.addEventListener("load", function(n) {
				i.cache.add(e, this.response), t && t(this.response), i.manager.itemEnd(e)
			}, !1), void 0 !== n && s.addEventListener("progress", function(e) {
				n(e)
			}, !1), void 0 !== r && s.addEventListener("error", function(e) {
				r(e)
			}, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (s.responseType = this.responseType), s.send(null), i.manager.itemStart(e))
		},
		setResponseType: function(e) {
			this.responseType = e
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		}
	}, THREE.ImageLoader = function(e) {
		this.cache = new THREE.Cache, this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.ImageLoader.prototype = {
		constructor: THREE.ImageLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = i.cache.get(e);
			if(void 0 === s) return s = document.createElement("img"), void 0 !== t && s.addEventListener("load", function(n) {
				i.cache.add(e, this), t(this), i.manager.itemEnd(e)
			}, !1), void 0 !== n && s.addEventListener("progress", function(e) {
				n(e)
			}, !1), void 0 !== r && s.addEventListener("error", function(e) {
				r(e)
			}, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), s.src = e, i.manager.itemStart(e), s;
			t(s)
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		}
	}, THREE.JSONLoader = function(e) {
		THREE.Loader.call(this, e), this.withCredentials = !1
	}, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.load = function(e, t, n) {
		n = n && "string" == typeof n ? n : this.extractUrlBase(e), this.onLoadStart(), this.loadAjaxJSON(this, e, t, n)
	}, THREE.JSONLoader.prototype.loadAjaxJSON = function(e, t, n, r, i) {
		var s = new XMLHttpRequest,
			o = 0;
		s.onreadystatechange = function() {
			if(s.readyState === s.DONE)
				if(200 === s.status || 0 === s.status) {
					if(s.responseText) {
						var u = JSON.parse(s.responseText);
						if(void 0 !== u.metadata && "scene" === u.metadata.type) {
							console.error('THREE.JSONLoader: "' + t + '" seems to be a Scene. Use THREE.SceneLoader instead.');
							return
						}
						u = e.parse(u, r), n(u.geometry, u.materials)
					} else console.error('THREE.JSONLoader: "' + t + '" seems to be unreachable or the file is empty.');
					e.onLoadComplete()
				} else console.error("THREE.JSONLoader: Couldn't load \"" + t + '" (' + s.status + ")");
			else s.readyState === s.LOADING ? i && (0 === o && (o = s.getResponseHeader("Content-Length")), i({
				total: o,
				loaded: s.responseText.length
			})) : s.readyState === s.HEADERS_RECEIVED && void 0 !== i && (o = s.getResponseHeader("Content-Length"))
		}, s.open("GET", t, !0), s.withCredentials = this.withCredentials, s.send(null)
	}, THREE.JSONLoader.prototype.parse = function(e, t) {
		var n = new THREE.Geometry,
			r = void 0 !== e.scale ? 1 / e.scale : 1;
		return function(t) {
				var r, i, s, o, u, f, l, h, p, d, v, m, g, y = e.faces;
				f = e.vertices;
				var b = e.normals,
					w = e.colors,
					E = 0;
				if(void 0 !== e.uvs) {
					for(r = 0; r < e.uvs.length; r++) e.uvs[r].length && E++;
					for(r = 0; r < E; r++) n.faceVertexUvs[r] = []
				}
				o = 0;
				for(u = f.length; o < u;) r = new THREE.Vector3, r.x = f[o++] * t, r.y = f[o++] * t, r.z = f[o++] * t, n.vertices.push(r);
				o = 0;
				for(u = y.length; o < u;)
					if(t = y[o++], p = t & 1, s = t & 2, r = t & 8, l = t & 16, d = t & 32, f = t & 64, t &= 128, p) {
						p = new THREE.Face3, p.a = y[o], p.b = y[o + 1], p.c = y[o + 3], v = new THREE.Face3, v.a = y[o + 1], v.b = y[o + 2], v.c = y[o + 3], o += 4, s && (s = y[o++], p.materialIndex = s, v.materialIndex = s), s = n.faces.length;
						if(r)
							for(r = 0; r < E; r++)
								for(m = e.uvs[r], n.faceVertexUvs[r][s] = [], n.faceVertexUvs[r][s + 1] = [], i = 0; 4 > i; i++) h = y[o++], g = m[2 * h], h = m[2 * h + 1], g = new THREE.Vector2(g, h), 2 !== i && n.faceVertexUvs[r][s].push(g), 0 !== i && n.faceVertexUvs[r][s + 1].push(g);
						l && (l = 3 * y[o++], p.normal.set(b[l++], b[l++], b[l]), v.normal.copy(p.normal));
						if(d)
							for(r = 0; 4 > r; r++) l = 3 * y[o++], d = new THREE.Vector3(b[l++], b[l++], b[l]), 2 !== r && p.vertexNormals.push(d), 0 !== r && v.vertexNormals.push(d);
						f && (f = y[o++], f = w[f], p.color.setHex(f), v.color.setHex(f));
						if(t)
							for(r = 0; 4 > r; r++) f = y[o++], f = w[f], 2 !== r && p.vertexColors.push(new THREE.Color(f)), 0 !== r && v.vertexColors.push(new THREE.Color(f));
						n.faces.push(p), n.faces.push(v)
					} else {
						p = new THREE.Face3, p.a = y[o++], p.b = y[o++], p.c = y[o++], s && (s = y[o++], p.materialIndex = s), s = n.faces.length;
						if(r)
							for(r = 0; r < E; r++)
								for(m = e.uvs[r], n.faceVertexUvs[r][s] = [], i = 0; 3 > i; i++) h = y[o++], g = m[2 * h], h = m[2 * h + 1], g = new THREE.Vector2(g, h), n.faceVertexUvs[r][s].push(g);
						l && (l = 3 * y[o++], p.normal.set(b[l++], b[l++], b[l]));
						if(d)
							for(r = 0; 3 > r; r++) l = 3 * y[o++], d = new THREE.Vector3(b[l++], b[l++], b[l]), p.vertexNormals.push(d);
						f && (f = y[o++], p.color.setHex(w[f]));
						if(t)
							for(r = 0; 3 > r; r++) f = y[o++], p.vertexColors.push(new THREE.Color(w[f]));
						n.faces.push(p)
					}
			}(r),
			function() {
				var t = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
				if(e.skinWeights)
					for(var r = 0, i = e.skinWeights.length; r < i; r += t) n.skinWeights.push(new THREE.Vector4(e.skinWeights[r], 1 < t ? e.skinWeights[r + 1] : 0, 2 < t ? e.skinWeights[r + 2] : 0, 3 < t ? e.skinWeights[r + 3] : 0));
				if(e.skinIndices)
					for(r = 0, i = e.skinIndices.length; r < i; r += t) n.skinIndices.push(new THREE.Vector4(e.skinIndices[r], 1 < t ? e.skinIndices[r + 1] : 0, 2 < t ? e.skinIndices[r + 2] : 0, 3 < t ? e.skinIndices[r + 3] : 0));
				n.bones = e.bones, n.bones && 0 < n.bones.length && (n.skinWeights.length !== n.skinIndices.length || n.skinIndices.length !== n.vertices.length) && console.warn("When skinning, number of vertices (" + n.vertices.length + "), skinIndices (" + n.skinIndices.length + "), and skinWeights (" + n.skinWeights.length + ") should match."), n.animation = e.animation, n.animations = e.animations
			}(),
			function(t) {
				if(void 0 !== e.morphTargets) {
					var r, i, s, o, u, f;
					r = 0;
					for(i = e.morphTargets.length; r < i; r++)
						for(n.morphTargets[r] = {}, n.morphTargets[r].name = e.morphTargets[r].name, n.morphTargets[r].vertices = [], u = n.morphTargets[r].vertices, f = e.morphTargets[r].vertices, s = 0, o = f.length; s < o; s += 3) {
							var l = new THREE.Vector3;
							l.x = f[s] * t, l.y = f[s + 1] * t, l.z = f[s + 2] * t, u.push(l)
						}
				}
				if(void 0 !== e.morphColors)
					for(r = 0, i = e.morphColors.length; r < i; r++)
						for(n.morphColors[r] = {}, n.morphColors[r].name = e.morphColors[r].name, n.morphColors[r].colors = [], o = n.morphColors[r].colors, u = e.morphColors[r].colors, t = 0, s = u.length; t < s; t += 3) f = new THREE.Color(16755200), f.setRGB(u[t], u[t + 1], u[t + 2]), o.push(f)
			}(r), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? {
				geometry: n
			} : (r = this.initMaterials(e.materials, t), this.needsTangents(r) && n.computeTangents(), {
				geometry: n,
				materials: r
			})
	}, THREE.LoadingManager = function(e, t, n) {
		var r = this,
			i = 0,
			s = 0;
		this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
			s++
		}, this.itemEnd = function(e) {
			i++, void 0 !== r.onProgress && r.onProgress(e, i, s), i === s && void 0 !== r.onLoad && r.onLoad()
		}
	}, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.BufferGeometryLoader.prototype = {
		constructor: THREE.BufferGeometryLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = new THREE.XHRLoader;
			s.setCrossOrigin(this.crossOrigin), s.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			}, n, r)
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = new THREE.BufferGeometry,
				n = e.attributes,
				r;
			for(r in n) {
				var i = n[r];
				t.attributes[r] = {
					itemSize: i.itemSize,
					array: new self[i.type](i.array)
				}
			}
			return n = e.offsets, void 0 !== n && (t.offsets = JSON.parse(JSON.stringify(n))), e = e.boundingSphere, void 0 !== e && (t.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== e.center ? e.center : [0, 0, 0]), e.radius)), t
		}
	}, THREE.MaterialLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.MaterialLoader.prototype = {
		constructor: THREE.MaterialLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = new THREE.XHRLoader;
			s.setCrossOrigin(this.crossOrigin), s.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			}, n, r)
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = new THREE[e.type];
			void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.ambient && t.ambient.setHex(e.ambient), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.uniforms && (t.uniforms = e.uniforms), void 0 !== e.vertexShader && (t.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (t.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.wireframe && (t.wireframe = e.wireframe);
			if(void 0 !== e.materials)
				for(var n = 0, r = e.materials.length; n < r; n++) t.materials.push(this.parse(e.materials[n]));
			return t
		}
	}, THREE.ObjectLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.ObjectLoader.prototype = {
		constructor: THREE.ObjectLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = new THREE.XHRLoader(i.manager);
			s.setCrossOrigin(this.crossOrigin), s.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			}, n, r)
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = this.parseGeometries(e.geometries),
				n = this.parseMaterials(e.materials);
			return this.parseObject(e.object, t, n)
		},
		parseGeometries: function(e) {
			var t = {};
			if(void 0 !== e)
				for(var n = new THREE.JSONLoader, r = new THREE.BufferGeometryLoader, i = 0, s = e.length; i < s; i++) {
					var o, u = e[i];
					switch(u.type) {
						case "PlaneGeometry":
							o = new THREE.PlaneGeometry(u.width, u.height, u.widthSegments, u.heightSegments);
							break;
						case "BoxGeometry":
						case "CubeGeometry":
							o = new THREE.BoxGeometry(u.width, u.height, u.depth, u.widthSegments, u.heightSegments, u.depthSegments);
							break;
						case "CircleGeometry":
							o = new THREE.CircleGeometry(u.radius, u.segments);
							break;
						case "CylinderGeometry":
							o = new THREE.CylinderGeometry(u.radiusTop, u.radiusBottom, u.height, u.radialSegments, u.heightSegments, u.openEnded);
							break;
						case "SphereGeometry":
							o = new THREE.SphereGeometry(u.radius, u.widthSegments, u.heightSegments, u.phiStart, u.phiLength, u.thetaStart, u.thetaLength);
							break;
						case "IcosahedronGeometry":
							o = new THREE.IcosahedronGeometry(u.radius, u.detail);
							break;
						case "TorusGeometry":
							o = new THREE.TorusGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.arc);
							break;
						case "TorusKnotGeometry":
							o = new THREE.TorusKnotGeometry(u.radius, u.tube, u.radialSegments, u.tubularSegments, u.p, u.q, u.heightScale);
							break;
						case "BufferGeometry":
							o = r.parse(u.data);
							break;
						case "Geometry":
							o = n.parse(u.data).geometry
					}
					o.uuid = u.uuid, void 0 !== u.name && (o.name = u.name), t[u.uuid] = o
				}
			return t
		},
		parseMaterials: function(e) {
			var t = {};
			if(void 0 !== e)
				for(var n = new THREE.MaterialLoader, r = 0, i = e.length; r < i; r++) {
					var s = e[r],
						o = n.parse(s);
					o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), t[s.uuid] = o
				}
			return t
		},
		parseObject: function() {
			var e = new THREE.Matrix4;
			return function(t, n, r) {
				var i;
				switch(t.type) {
					case "Scene":
						i = new THREE.Scene;
						break;
					case "PerspectiveCamera":
						i = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
						break;
					case "OrthographicCamera":
						i = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
						break;
					case "AmbientLight":
						i = new THREE.AmbientLight(t.color);
						break;
					case "DirectionalLight":
						i = new THREE.DirectionalLight(t.color, t.intensity);
						break;
					case "PointLight":
						i = new THREE.PointLight(t.color, t.intensity, t.distance);
						break;
					case "SpotLight":
						i = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent);
						break;
					case "HemisphereLight":
						i = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
						break;
					case "Mesh":
						i = n[t.geometry];
						var s = r[t.material];
						void 0 === i && console.error("THREE.ObjectLoader: Undefined geometry " + t.geometry), void 0 === s && console.error("THREE.ObjectLoader: Undefined material " + t.material), i = new THREE.Mesh(i, s);
						break;
					case "Sprite":
						s = r[t.material], void 0 === s && console.error("THREE.ObjectLoader: Undefined material " + t.material), i = new THREE.Sprite(s);
						break;
					default:
						i = new THREE.Object3D
				}
				i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData);
				if(void 0 !== t.children)
					for(var o in t.children) i.add(this.parseObject(t.children[o], n, r));
				return i
			}
		}()
	}, THREE.TextureLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.TextureLoader.prototype = {
		constructor: THREE.TextureLoader,
		load: function(e, t, n, r) {
			var i = new THREE.ImageLoader(this.manager);
			i.setCrossOrigin(this.crossOrigin), i.load(e, function(e) {
				e = new THREE.Texture(e), e.needsUpdate = !0, void 0 !== t && t(e)
			}, n, r)
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		}
	}, THREE.Material = function() {
		this.id = THREE.MaterialIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.needsUpdate = this.visible = !0
	}, THREE.Material.prototype = {
		constructor: THREE.Material,
		setValues: function(e) {
			if(void 0 !== e)
				for(var t in e) {
					var n = e[t];
					if(void 0 === n) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
					else if(t in this) {
						var r = this[t];
						r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : this[t] = "overdraw" == t ? Number(n) : n
					}
				}
		},
		clone: function(e) {
			return void 0 === e && (e = new THREE.Material), e.name = this.name, e.side = this.side, e.opacity = this.opacity, e.transparent = this.transparent, e.blending = this.blending, e.blendSrc = this.blendSrc, e.blendDst = this.blendDst, e.blendEquation = this.blendEquation, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.alphaTest = this.alphaTest, e.overdraw = this.overdraw, e.visible = this.visible, e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e)
	}, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.clone = function() {
		var e = new THREE.LineBasicMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.linecap = this.linecap, e.linejoin = this.linejoin, e.vertexColors = this.vertexColors, e.fog = this.fog, e
	}, THREE.LineDashedMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(e)
	}, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.clone = function() {
		var e = new THREE.LineDashedMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.scale = this.scale, e.dashSize = this.dashSize, e.gapSize = this.gapSize, e.vertexColors = this.vertexColors, e.fog = this.fog, e
	}, THREE.MeshBasicMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphTargets = this.skinning = !1, this.setValues(e)
	}, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.clone = function() {
		var e = new THREE.MeshBasicMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e
	}, THREE.MeshLambertMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.clone = function() {
		var e = new THREE.MeshLambertMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
	}, THREE.MeshPhongMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.bumpMap = this.lightMap = this.map = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.envMap = this.alphaMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.clone = function() {
		var e = new THREE.MeshPhongMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.specular.copy(this.specular), e.shininess = this.shininess, e.metal = this.metal, e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.bumpMap = this.bumpMap, e.bumpScale = this.bumpScale, e.normalMap = this.normalMap, e.normalScale.copy(this.normalScale), e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
	}, THREE.MeshDepthMaterial = function(e) {
		THREE.Material.call(this), this.wireframe = this.morphTargets = !1, this.wireframeLinewidth = 1, this.setValues(e)
	}, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.clone = function() {
		var e = new THREE.MeshDepthMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
	}, THREE.MeshNormalMaterial = function(e) {
		THREE.Material.call(this, e), this.shading = THREE.FlatShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
	}, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.clone = function() {
		var e = new THREE.MeshNormalMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
	}, THREE.MeshFaceMaterial = function(e) {
		this.materials = e instanceof Array ? e : []
	}, THREE.MeshFaceMaterial.prototype.clone = function() {
		for(var e = new THREE.MeshFaceMaterial, t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
		return e
	}, THREE.PointCloudMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e)
	}, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointCloudMaterial.prototype.clone = function() {
		var e = new THREE.PointCloudMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.vertexColors = this.vertexColors, e.fog = this.fog, e
	}, THREE.ParticleBasicMaterial = function(e) {
		return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(e)
	}, THREE.ParticleSystemMaterial = function(e) {
		return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(e)
	}, THREE.ShaderMaterial = function(e) {
		THREE.Material.call(this), this.defines = {}, this.uniforms = {}, this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0]
		}, this.index0AttributeName = void 0, this.setValues(e)
	}, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.clone = function() {
		var e = new THREE.ShaderMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.fragmentShader = this.fragmentShader, e.vertexShader = this.vertexShader, e.uniforms = THREE.UniformsUtils.clone(this.uniforms), e.attributes = this.attributes, e.defines = this.defines, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
	}, THREE.RawShaderMaterial = function(e) {
		THREE.ShaderMaterial.call(this, e)
	}, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.clone = function() {
		var e = new THREE.RawShaderMaterial;
		return THREE.ShaderMaterial.prototype.clone.call(this, e), e
	}, THREE.SpriteMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
	}, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.clone = function() {
		var e = new THREE.SpriteMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.rotation = this.rotation, e.fog = this.fog, e
	}, THREE.SpriteCanvasMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.program = function(e, t) {}, this.setValues(e)
	}, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.clone = function() {
		var e = new THREE.SpriteCanvasMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.program = this.program, e
	}, THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial, THREE.Texture = function(e, t, n, r, i, s, o, u, a) {
		this.id = THREE.TextureIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.image = void 0 !== e ? e : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i ? i : THREE.LinearFilter, this.minFilter = void 0 !== s ? s : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== a ? a : 1, this.format = void 0 !== o ? o : THREE.RGBAFormat, this.type = void 0 !== u ? u : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
	}, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping, THREE.Texture.prototype = {
		constructor: THREE.Texture,
		get needsUpdate() {
			return this._needsUpdate
		},
		set needsUpdate(e) {
			!0 === e && this.update(), this._needsUpdate = e
		},
		clone: function(e) {
			return void 0 === e && (e = new THREE.Texture), e.image = this.image, e.mipmaps = this.mipmaps.slice(0), e.mapping = this.mapping, e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.format = this.format, e.type = this.type, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.generateMipmaps = this.generateMipmaps, e.premultiplyAlpha = this.premultiplyAlpha, e.flipY = this.flipY, e.unpackAlignment = this.unpackAlignment, e
		},
		update: function() {
			this.dispatchEvent({
				type: "update"
			})
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CubeTexture = function(e, t, n, r, i, s, o, u, a) {
		THREE.Texture.call(this, e, t, n, r, i, s, o, u, a), this.images = e
	}, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.clone = function(e) {
		return void 0 === e && (e = new THREE.CubeTexture), THREE.Texture.prototype.clone.call(this, e), e.images = this.images, e
	}, THREE.CompressedTexture = function(e, t, n, r, i, s, o, u, a, f, l) {
		THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), this.image = {
			width: t,
			height: n
		}, this.mipmaps = e, this.generateMipmaps = !1
	}, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.clone = function() {
		var e = new THREE.CompressedTexture;
		return THREE.Texture.prototype.clone.call(this, e), e
	}, THREE.DataTexture = function(e, t, n, r, i, s, o, u, a, f, l) {
		THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), this.image = {
			data: e,
			width: t,
			height: n
		}
	}, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.clone = function() {
		var e = new THREE.DataTexture;
		return THREE.Texture.prototype.clone.call(this, e), e
	}, THREE.PointCloud = function(e, t) {
		THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.PointCloudMaterial({
			color: 16777215 * Math.random()
		}), this.sortParticles = !1
	}, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.raycast = function() {
		var e = new THREE.Matrix4,
			t = new THREE.Ray;
		return function(n, r) {
			var i = this,
				s = i.geometry,
				o = n.params.PointCloud.threshold;
			e.getInverse(this.matrixWorld), t.copy(n.ray).applyMatrix4(e);
			if(null === s.boundingBox || !1 !== t.isIntersectionBox(s.boundingBox)) {
				var u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					f = new THREE.Vector3,
					o = function(e, s) {
						var o = t.distanceToPoint(e);
						if(o < u) {
							var a = t.closestPointToPoint(e);
							a.applyMatrix4(i.matrixWorld);
							var f = n.ray.origin.distanceTo(a);
							r.push({
								distance: f,
								distanceToRay: o,
								point: a.clone(),
								index: s,
								face: null,
								object: i
							})
						}
					};
				if(s instanceof THREE.BufferGeometry) {
					var l = s.attributes,
						c = l.position.array;
					if(void 0 !== l.index) {
						var l = l.index.array,
							h = s.offsets;
						0 === h.length && (h = [{
							start: 0,
							count: l.length,
							index: 0
						}]);
						for(var p = 0, d = h.length; p < d; ++p)
							for(var v = h[p].start, m = h[p].index, s = v, v = v + h[p].count; s < v; s++) {
								var g = m + l[s];
								f.set(c[3 * g], c[3 * g + 1], c[3 * g + 2]), o(f, g)
							}
					} else
						for(l = c.length / 3, s = 0; s < l; s++) f.set(c[3 * s], c[3 * s + 1], c[3 * s + 2]), o(f, s)
				} else
					for(f = this.geometry.vertices, s = 0; s < f.length; s++) o(f[s], s)
			}
		}
	}(), THREE.PointCloud.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.PointCloud(this.geometry, this.material)), e.sortParticles = this.sortParticles, THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.ParticleSystem = function(e, t) {
		return console.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), new THREE.PointCloud(e, t)
	}, THREE.Line = function(e, t, n) {
		THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.LineBasicMaterial({
			color: 16777215 * Math.random()
		}), this.type = void 0 !== n ? n : THREE.LineStrip
	}, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.raycast = function() {
		var e = new THREE.Matrix4,
			t = new THREE.Ray,
			n = new THREE.Sphere;
		return function(r, i) {
			var s = r.linePrecision,
				s = s * s,
				o = this.geometry;
			null === o.boundingSphere && o.computeBoundingSphere(), n.copy(o.boundingSphere), n.applyMatrix4(this.matrixWorld);
			if(!1 !== r.ray.isIntersectionSphere(n) && (e.getInverse(this.matrixWorld), t.copy(r.ray).applyMatrix4(e), o instanceof THREE.Geometry))
				for(var o = o.vertices, u = o.length, f = new THREE.Vector3, l = new THREE.Vector3, h = this.type === THREE.LineStrip ? 1 : 2, p = 0; p < u - 1; p += h)
					if(!(t.distanceSqToSegment(o[p], o[p + 1], l, f) > s)) {
						var d = t.origin.distanceTo(l);
						d < r.near || d > r.far || i.push({
							distance: d,
							point: f.clone().applyMatrix4(this.matrixWorld),
							face: null,
							faceIndex: null,
							object: this
						})
					}
		}
	}(), THREE.Line.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.Mesh = function(e, t) {
		THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.MeshBasicMaterial({
			color: 16777215 * Math.random()
		}), this.updateMorphTargets()
	}, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.updateMorphTargets = function() {
		if(void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
			this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
			for(var e = 0, t = this.geometry.morphTargets.length; e < t; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
		}
	}, THREE.Mesh.prototype.getMorphTargetIndexByName = function(e) {
		return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
	}, THREE.Mesh.prototype.raycast = function() {
		var e = new THREE.Matrix4,
			t = new THREE.Ray,
			n = new THREE.Sphere,
			r = new THREE.Vector3,
			i = new THREE.Vector3,
			s = new THREE.Vector3;
		return function(o, u) {
			var l = this.geometry;
			null === l.boundingSphere && l.computeBoundingSphere(), n.copy(l.boundingSphere), n.applyMatrix4(this.matrixWorld);
			if(!1 !== o.ray.isIntersectionSphere(n) && (e.getInverse(this.matrixWorld), t.copy(o.ray).applyMatrix4(e), null === l.boundingBox || !1 !== t.isIntersectionBox(l.boundingBox)))
				if(l instanceof THREE.BufferGeometry) {
					var h = this.material;
					if(void 0 !== h) {
						var p = l.attributes,
							v, m, g = o.precision;
						if(void 0 !== p.index) {
							var y = p.index.array,
								w = p.position.array,
								E = l.offsets;
							0 === E.length && (E = [{
								start: 0,
								count: y.length,
								index: 0
							}]);
							for(var S = 0, x = E.length; S < x; ++S)
								for(var p = E[S].start, T = E[S].index, l = p, N = p + E[S].count; l < N; l += 3) {
									p = T + y[l], v = T + y[l + 1], m = T + y[l + 2], r.set(w[3 * p], w[3 * p + 1], w[3 * p + 2]), i.set(w[3 * v], w[3 * v + 1], w[3 * v + 2]), s.set(w[3 * m], w[3 * m + 1], w[3 * m + 2]);
									var C = h.side === THREE.BackSide ? t.intersectTriangle(s, i, r, !0) : t.intersectTriangle(r, i, s, h.side !== THREE.DoubleSide);
									if(null !== C) {
										C.applyMatrix4(this.matrixWorld);
										var k = o.ray.origin.distanceTo(C);
										k < g || k < o.near || k > o.far || u.push({
											distance: k,
											point: C,
											indices: [p, v, m],
											face: null,
											faceIndex: null,
											object: this
										})
									}
								}
						} else
							for(w = p.position.array, y = l = 0, N = w.length; l < N; l += 3, y += 9) p = l, v = l + 1, m = l + 2, r.set(w[y], w[y + 1], w[y + 2]), i.set(w[y + 3], w[y + 4], w[y + 5]), s.set(w[y + 6], w[y + 7], w[y + 8]), C = h.side === THREE.BackSide ? t.intersectTriangle(s, i, r, !0) : t.intersectTriangle(r, i, s, h.side !== THREE.DoubleSide), null !== C && (C.applyMatrix4(this.matrixWorld), k = o.ray.origin.distanceTo(C), k < g || k < o.near || k > o.far || u.push({
								distance: k,
								point: C,
								indices: [p, v, m],
								face: null,
								faceIndex: null,
								object: this
							}))
					}
				} else if(l instanceof THREE.Geometry)
				for(y = this.material instanceof THREE.MeshFaceMaterial, w = !0 === y ? this.material.materials : null, g = o.precision, E = l.vertices, S = 0, x = l.faces.length; S < x; S++)
					if(T = l.faces[S], h = !0 === y ? w[T.materialIndex] : this.material, void 0 !== h) {
						p = E[T.a], v = E[T.b], m = E[T.c];
						if(!0 === h.morphTargets) {
							C = l.morphTargets, k = this.morphTargetInfluences, r.set(0, 0, 0), i.set(0, 0, 0), s.set(0, 0, 0);
							for(var N = 0, L = C.length; N < L; N++) {
								var A = k[N];
								if(0 !== A) {
									var O = C[N].vertices;
									r.x += (O[T.a].x - p.x) * A, r.y += (O[T.a].y - p.y) * A, r.z += (O[T.a].z - p.z) * A, i.x += (O[T.b].x - v.x) * A, i.y += (O[T.b].y - v.y) * A, i.z += (O[T.b].z - v.z) * A, s.x += (O[T.c].x - m.x) * A, s.y += (O[T.c].y - m.y) * A, s.z += (O[T.c].z - m.z) * A
								}
							}
							r.add(p), i.add(v), s.add(m), p = r, v = i, m = s
						}
						C = h.side === THREE.BackSide ? t.intersectTriangle(m, v, p, !0) : t.intersectTriangle(p, v, m, h.side !== THREE.DoubleSide), null !== C && (C.applyMatrix4(this.matrixWorld), k = o.ray.origin.distanceTo(C), k < g || k < o.near || k > o.far || u.push({
							distance: k,
							point: C,
							face: T,
							faceIndex: S,
							object: this
						}))
					}
		}
	}(), THREE.Mesh.prototype.clone = function(e, t) {
		return void 0 === e && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e, t), e
	}, THREE.Bone = function(e) {
		THREE.Object3D.call(this), this.skin = e, this.accumulatedSclWeight = this.accumulatedPosWeight = this.accumulatedRotWeight = 0
	}, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.updateMatrixWorld = function(e) {
		THREE.Object3D.prototype.updateMatrixWorld.call(this, e), this.accumulatedSclWeight = this.accumulatedPosWeight = this.accumulatedRotWeight = 0
	}, THREE.Skeleton = function(e, t, n) {
		this.useVertexTexture = void 0 !== n ? n : !0, this.identityMatrix = new THREE.Matrix4, e = e || [], this.bones = e.slice(0), this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = e = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length);
		if(void 0 === t) this.calculateInverses();
		else if(this.bones.length === t.length) this.boneInverses = t.slice(0);
		else
			for(console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new THREE.Matrix4)
	}, THREE.Skeleton.prototype.calculateInverses = function() {
		this.boneInverses = [];
		for(var e = 0, t = this.bones.length; e < t; e++) {
			var n = new THREE.Matrix4;
			this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
		}
	}, THREE.Skeleton.prototype.pose = function() {
		for(var e, t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
		t = 0;
		for(n = this.bones.length; t < n; t++)
			if(e = this.bones[t]) e.parent ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)
	}, THREE.Skeleton.prototype.update = function() {
		for(var e = new THREE.Matrix4, t = 0, n = this.bones.length; t < n; t++) e.multiplyMatrices(this.bones[t] ? this.bones[t].matrixWorld : this.identityMatrix, this.boneInverses[t]), e.flattenToArrayOffset(this.boneMatrices, 16 * t);
		this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
	}, THREE.SkinnedMesh = function(e, t, n) {
		THREE.Mesh.call(this, e, t), this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4, e = [];
		if(this.geometry && void 0 !== this.geometry.bones) {
			for(var r, i, s, o, u = 0, a = this.geometry.bones.length; u < a; ++u) r = this.geometry.bones[u], i = r.pos, s = r.rotq, o = r.scl, t = new THREE.Bone(this), e.push(t), t.name = r.name, t.position.set(i[0], i[1], i[2]), t.quaternion.set(s[0], s[1], s[2], s[3]), void 0 !== o ? t.scale.set(o[0], o[1], o[2]) : t.scale.set(1, 1, 1);
			u = 0;
			for(a = this.geometry.bones.length; u < a; ++u) r = this.geometry.bones[u], -1 !== r.parent ? e[r.parent].add(e[u]) : this.add(e[u])
		}
		this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(e, void 0, n))
	}, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.bind = function(e, t) {
		this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
	}, THREE.SkinnedMesh.prototype.pose = function() {
		this.skeleton.pose()
	}, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
		if(this.geometry instanceof THREE.Geometry)
			for(var e = 0; e < this.geometry.skinIndices.length; e++) {
				var t = this.geometry.skinWeights[e],
					n = 1 / t.lengthManhattan();
				Infinity !== n ? t.multiplyScalar(n) : t.set(1)
			}
	}, THREE.SkinnedMesh.prototype.updateMatrixWorld = function(e) {
		THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
	}, THREE.SkinnedMesh.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e
	}, THREE.MorphAnimMesh = function(e, t) {
		THREE.Mesh.call(this, e, t), this.duration = 1e3, this.mirroredLoop = !1, this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
	}, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.setFrameRange = function(e, t) {
		this.startKeyframe = e, this.endKeyframe = t, this.length = this.endKeyframe - this.startKeyframe + 1
	}, THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
		this.direction = 1, this.directionBackwards = !1
	}, THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
		this.direction = -1, this.directionBackwards = !0
	}, THREE.MorphAnimMesh.prototype.parseAnimations = function() {
		var e = this.geometry;
		e.animations || (e.animations = {});
		for(var t, n = e.animations, r = /([a-z]+)_?(\d+)/, i = 0, s = e.morphTargets.length; i < s; i++) {
			var o = e.morphTargets[i].name.match(r);
			if(o && 1 < o.length) {
				o = o[1], n[o] || (n[o] = {
					start: Infinity,
					end: -Infinity
				});
				var u = n[o];
				i < u.start && (u.start = i), i > u.end && (u.end = i), t || (t = o)
			}
		}
		e.firstAnimation = t
	}, THREE.MorphAnimMesh.prototype.setAnimationLabel = function(e, t, n) {
		this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[e] = {
			start: t,
			end: n
		}
	}, THREE.MorphAnimMesh.prototype.playAnimation = function(e, t) {
		var n = this.geometry.animations[e];
		n ? (this.setFrameRange(n.start, n.end), this.duration = (n.end - n.start) / t * 1e3, this.time = 0) : console.warn("animation[" + e + "] undefined")
	}, THREE.MorphAnimMesh.prototype.updateAnimation = function(e) {
		var t = this.duration / this.length;
		this.time += this.direction * e;
		if(this.mirroredLoop) {
			if(this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)
		} else this.time %= this.duration, 0 > this.time && (this.time += this.duration);
		e = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1), e !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[e] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = e), t = this.time % t / t, this.directionBackwards && (t = 1 - t), this.morphTargetInfluences[this.currentKeyframe] = t, this.morphTargetInfluences[this.lastKeyframe] = 1 - t
	}, THREE.MorphAnimMesh.prototype.interpolateTargets = function(e, t, n) {
		for(var r = this.morphTargetInfluences, i = 0, s = r.length; i < s; i++) r[i] = 0; - 1 < e && (r[e] = 1 - n), -1 < t && (r[t] = n)
	}, THREE.MorphAnimMesh.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.MorphAnimMesh(this.geometry, this.material)), e.duration = this.duration, e.mirroredLoop = this.mirroredLoop, e.time = this.time, e.lastKeyframe = this.lastKeyframe, e.currentKeyframe = this.currentKeyframe, e.direction = this.direction, e.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, e), e
	}, THREE.LOD = function() {
		THREE.Object3D.call(this), this.objects = []
	}, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.addLevel = function(e, t) {
		void 0 === t && (t = 0), t = Math.abs(t);
		for(var n = 0; n < this.objects.length && !(t < this.objects[n].distance); n++);
		this.objects.splice(n, 0, {
			distance: t,
			object: e
		}), this.add(e)
	}, THREE.LOD.prototype.getObjectForDistance = function(e) {
		for(var t = 1, n = this.objects.length; t < n && !(e < this.objects[t].distance); t++);
		return this.objects[t - 1].object
	}, THREE.LOD.prototype.raycast = function() {
		var e = new THREE.Vector3;
		return function(t, n) {
			e.setFromMatrixPosition(this.matrixWorld);
			var r = t.ray.origin.distanceTo(e);
			this.getObjectForDistance(r).raycast(t, n)
		}
	}(), THREE.LOD.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3;
		return function(n) {
			if(1 < this.objects.length) {
				e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), n = e.distanceTo(t), this.objects[0].object.visible = !0;
				for(var r = 1, i = this.objects.length; r < i; r++) {
					if(!(n >= this.objects[r].distance)) break;
					this.objects[r - 1].object.visible = !1, this.objects[r].object.visible = !0
				}
				for(; r < i; r++) this.objects[r].object.visible = !1
			}
		}
	}(), THREE.LOD.prototype.clone = function(e) {
		void 0 === e && (e = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, e);
		for(var t = 0, n = this.objects.length; t < n; t++) {
			var r = this.objects[t].object.clone();
			r.visible = 0 === t, e.addLevel(r, this.objects[t].distance)
		}
		return e
	}, THREE.Sprite = function() {
		var e = new Float32Array([-0.5, -0.5, 0, .5, -0.5, 0, .5, .5, 0]),
			t = new THREE.BufferGeometry;
		return t.addAttribute("position", new THREE.BufferAttribute(e, 3)),
			function(e) {
				THREE.Object3D.call(this), this.geometry = t, this.material = void 0 !== e ? e : new THREE.SpriteMaterial
			}
	}(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.raycast = function() {
		var e = new THREE.Vector3;
		return function(t, n) {
			e.setFromMatrixPosition(this.matrixWorld);
			var r = t.ray.distanceToPoint(e);
			r > this.scale.x || n.push({
				distance: r,
				point: this.position,
				face: null,
				object: this
			})
		}
	}(), THREE.Sprite.prototype.updateMatrix = function() {
		this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
	}, THREE.Sprite.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.Particle = THREE.Sprite, THREE.Scene = function() {
		THREE.Object3D.call(this), this.overrideMaterial = this.fog = null, this.autoUpdate = !0, this.matrixAutoUpdate = !1, this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = []
	}, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.__addObject = function(e) {
		if(e instanceof THREE.Light) - 1 === this.__lights.indexOf(e) && this.__lights.push(e), e.target && void 0 === e.target.parent && this.add(e.target);
		else if(!(e instanceof THREE.Camera || e instanceof THREE.Bone)) {
			this.__objectsAdded.push(e);
			var t = this.__objectsRemoved.indexOf(e); - 1 !== t && this.__objectsRemoved.splice(t, 1)
		}
		this.dispatchEvent({
			type: "objectAdded",
			object: e
		}), e.dispatchEvent({
			type: "addedToScene",
			scene: this
		});
		for(t = 0; t < e.children.length; t++) this.__addObject(e.children[t])
	}, THREE.Scene.prototype.__removeObject = function(e) {
		if(e instanceof THREE.Light) {
			var t = this.__lights.indexOf(e); - 1 !== t && this.__lights.splice(t, 1);
			if(e.shadowCascadeArray)
				for(t = 0; t < e.shadowCascadeArray.length; t++) this.__removeObject(e.shadowCascadeArray[t])
		} else e instanceof THREE.Camera || (this.__objectsRemoved.push(e), t = this.__objectsAdded.indexOf(e), -1 !== t && this.__objectsAdded.splice(t, 1));
		this.dispatchEvent({
			type: "objectRemoved",
			object: e
		}), e.dispatchEvent({
			type: "removedFromScene",
			scene: this
		});
		for(t = 0; t < e.children.length; t++) this.__removeObject(e.children[t])
	}, THREE.Scene.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, e), null !== this.fog && (e.fog = this.fog.clone()), null !== this.overrideMaterial && (e.overrideMaterial = this.overrideMaterial.clone()), e.autoUpdate = this.autoUpdate, e.matrixAutoUpdate = this.matrixAutoUpdate, e
	}, THREE.Fog = function(e, t, n) {
		this.name = "", this.color = new THREE.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
	}, THREE.Fog.prototype.clone = function() {
		return new THREE.Fog(this.color.getHex(), this.near, this.far)
	}, THREE.FogExp2 = function(e, t) {
		this.name = "", this.color = new THREE.Color(e), this.density = void 0 !== t ? t : 25e-5
	}, THREE.FogExp2.prototype.clone = function() {
		return new THREE.FogExp2(this.color.getHex(), this.density)
	}, THREE.CanvasRenderer = function(e) {
		function t(e, t, n, r) {
			f(t), l(n), c(r), h(e.getStyle()), O.stroke(), ct.expandByScalar(2 * t)
		}

		function n(e) {
			p(e.getStyle()), O.fill()
		}

		function r(e) {
			i(e.target)
		}

		function i(e) {
			if(!(e instanceof THREE.CompressedTexture)) {
				var t = e.wrapS === THREE.RepeatWrapping,
					n = e.wrapT === THREE.RepeatWrapping,
					r = e.image,
					i = document.createElement("canvas");
				i.width = r.width, i.height = r.height;
				var s = i.getContext("2d");
				s.setTransform(1, 0, 0, -1, 0, r.height), s.drawImage(r, 0, 0), tt[e.id] = O.createPattern(i, !0 === t && !0 === n ? "repeat" : !0 === t && !1 === n ? "repeat-x" : !1 === t && !0 === n ? "repeat-y" : "no-repeat")
			}
		}

		function s(e, t, n, s, o, u, a, f, l, c, h, d, v) {
			if(!(v instanceof THREE.DataTexture)) {
				!1 === v.hasEventListener("update", r) && (void 0 !== v.image && 0 < v.image.width && i(v), v.addEventListener("update", r));
				var m = tt[v.id];
				if(void 0 !== m) {
					p(m);
					var m = v.offset.x / v.repeat.x,
						g = v.offset.y / v.repeat.y,
						y = v.image.width * v.repeat.x;
					v = v.image.height * v.repeat.y, a = (a + m) * y, f = (f + g) * v, n -= e, s -= t, o -= e, u -= t, l = (l + m) * y - a, c = (c + g) * v - f, h = (h + m) * y - a, d = (d + g) * v - f, v = l * d - h * c, 0 !== v && (m = 1 / v, v = (d * n - c * o) * m, c = (d * s - c * u) * m, n = (l * o - h * n) * m, s = (l * u - h * s) * m, e = e - v * a - n * f, t = t - c * a - s * f, O.save(), O.transform(v, c, n, s, e, t), O.fill(), O.restore())
				} else p("rgba(0,0,0,1)"), O.fill()
			}
		}

		function o(e, t, n) {
			var r = t.x - e.x,
				i = t.y - e.y,
				s = r * r + i * i;
			0 !== s && (n /= Math.sqrt(s), r *= n, i *= n, t.x += r, t.y += i, e.x -= r, e.y -= i)
		}

		function u(e) {
			D !== e && (D = O.globalAlpha = e)
		}

		function a(e) {
			P !== e && (e === THREE.NormalBlending ? O.globalCompositeOperation = "source-over" : e === THREE.AdditiveBlending ? O.globalCompositeOperation = "lighter" : e === THREE.SubtractiveBlending && (O.globalCompositeOperation = "darker"), P = e)
		}

		function f(e) {
			j !== e && (j = O.lineWidth = e)
		}

		function l(e) {
			F !== e && (F = O.lineCap = e)
		}

		function c(e) {
			I !== e && (I = O.lineJoin = e)
		}

		function h(e) {
			H !== e && (H = O.strokeStyle = e)
		}

		function p(e) {
			B !== e && (B = O.fillStyle = e)
		}

		function d(e) {
			q.length !== e.length && (O.setLineDash(e), q = e)
		}
		console.log("THREE.CanvasRenderer", THREE.REVISION);
		var v = THREE.Math.smoothstep;
		e = e || {};
		var m = this,
			g, y, b, w = new THREE.Projector,
			E = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
			S = E.width,
			x = E.height,
			T = Math.floor(S / 2),
			N = Math.floor(x / 2),
			C = 0,
			k = 0,
			L = S,
			A = x,
			O = E.getContext("2d", {
				alpha: !0 === e.alpha
			}),
			M = new THREE.Color(0),
			_ = 0,
			D = 1,
			P = 0,
			H = null,
			B = null,
			j = null,
			F = null,
			I = null,
			q = [],
			R, U, z, W;
		new THREE.RenderableVertex, new THREE.RenderableVertex;
		var X, V, $, J, K, Q, G = new THREE.Color;
		new THREE.Color, new THREE.Color, new THREE.Color, new THREE.Color;
		var Y = new THREE.Color,
			Z = new THREE.Color,
			et = new THREE.Color,
			tt = {},
			nt, rt, it, st, ot, ut, at, ft = new THREE.Box2,
			lt = new THREE.Box2,
			ct = new THREE.Box2,
			ht = new THREE.Color,
			pt = new THREE.Color,
			dt = new THREE.Color,
			vt = new THREE.Vector3,
			mt = new THREE.Vector3,
			gt = new THREE.Vector3,
			yt = new THREE.Matrix3;
		void 0 === O.setLineDash && (O.setLineDash = function() {}), this.domElement = E, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.sortElements = this.sortObjects = this.autoClear = !0, this.info = {
			render: {
				vertices: 0,
				faces: 0
			}
		}, this.supportsVertexTextures = function() {}, this.setFaceCulling = function() {}, this.setSize = function(e, t, n) {
			S = e * this.devicePixelRatio, x = t * this.devicePixelRatio, E.width = S, E.height = x, T = Math.floor(S / 2), N = Math.floor(x / 2), !1 !== n && (E.style.width = e + "px", E.style.height = t + "px"), ft.min.set(-T, -N), ft.max.set(T, N), lt.min.set(-T, -N), lt.max.set(T, N), D = 1, P = 0, I = F = j = B = H = null, this.setViewport(0, 0, e, t)
		}, this.setViewport = function(e, t, n, r) {
			C = e * this.devicePixelRatio, k = t * this.devicePixelRatio, L = n * this.devicePixelRatio, A = r * this.devicePixelRatio
		}, this.setScissor = function() {}, this.enableScissorTest = function() {}, this.setClearColor = function(e, t) {
			M.set(e), _ = void 0 !== t ? t : 1, lt.min.set(-T, -N), lt.max.set(T, N)
		}, this.setClearColorHex = function(e, t) {
			console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
		}, this.getClearColor = function() {
			return M
		}, this.getClearAlpha = function() {
			return _
		}, this.getMaxAnisotropy = function() {
			return 0
		}, this.clear = function() {
			!1 === lt.empty() && (lt.intersect(ft), lt.expandByScalar(2), lt.min.x += T, lt.min.y = -lt.min.y + N, lt.max.x += T, lt.max.y = -lt.max.y + N, 1 > _ && O.clearRect(lt.min.x | 0, lt.min.y | 0, lt.max.x - lt.min.x | 0, lt.max.y - lt.min.y | 0), 0 < _ && (a(THREE.NormalBlending), u(1), p("rgba(" + Math.floor(255 * M.r) + "," + Math.floor(255 * M.g) + "," + Math.floor(255 * M.b) + "," + _ + ")"), O.fillRect(lt.min.x | 0, lt.min.y | 0, lt.max.x - lt.min.x | 0, lt.max.y - lt.min.y | 0)), lt.makeEmpty())
		}, this.clearColor = function() {}, this.clearDepth = function() {}, this.clearStencil = function() {}, this.render = function(e, E) {
			if(0 == E instanceof THREE.Camera) console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
			else {
				!0 === this.autoClear && this.clear(), m.info.render.vertices = 0, m.info.render.faces = 0, O.setTransform(L / S, 0, 0, -A / x, C, x - k), O.translate(T, N), g = w.projectScene(e, E, this.sortObjects, this.sortElements), y = g.elements, b = g.lights, R = E, yt.getNormalMatrix(E.matrixWorldInverse), ht.setRGB(0, 0, 0), pt.setRGB(0, 0, 0), dt.setRGB(0, 0, 0);
				for(var M = 0, _ = b.length; M < _; M++) {
					var D = b[M],
						P = D.color;
					D instanceof THREE.AmbientLight ? ht.add(P) : D instanceof THREE.DirectionalLight ? pt.add(P) : D instanceof THREE.PointLight && dt.add(P)
				}
				M = 0;
				for(_ = y.length; M < _; M++) {
					var H = y[M],
						B = H.material;
					if(void 0 !== B && 0 !== B.opacity) {
						ct.makeEmpty();
						if(H instanceof THREE.RenderableSprite) {
							U = H, U.x *= T, U.y *= N;
							var D = U,
								j = H,
								P = B;
							u(P.opacity), a(P.blending);
							var F = j.scale.x * T,
								j = j.scale.y * N,
								H = .5 * Math.sqrt(F * F + j * j);
							ct.min.set(D.x - H, D.y - H), ct.max.set(D.x + H, D.y + H);
							if(P instanceof THREE.SpriteMaterial) {
								var I = P.map;
								if(null !== I && void 0 !== I.image) {
									!1 === I.hasEventListener("update", r) && (0 < I.image.width && i(I), I.addEventListener("update", r)), H = tt[I.id], void 0 !== H ? p(H) : p("rgba( 0, 0, 0, 1 )");
									var q = I.image,
										H = q.width * I.offset.x,
										B = q.height * I.offset.y,
										bt = q.width * I.repeat.x,
										I = q.height * I.repeat.y,
										q = F / bt,
										wt = j / I;
									O.save(), O.translate(D.x, D.y), 0 !== P.rotation && O.rotate(P.rotation), O.translate(-F / 2, -j / 2), O.scale(q, wt), O.translate(-H, -B), O.fillRect(H, B, bt, I)
								} else p(P.color.getStyle()), O.save(), O.translate(D.x, D.y), 0 !== P.rotation && O.rotate(P.rotation), O.scale(F, -j), O.fillRect(-0.5, -0.5, 1, 1);
								O.restore()
							} else P instanceof THREE.SpriteCanvasMaterial && (h(P.color.getStyle()), p(P.color.getStyle()), O.save(), O.translate(D.x, D.y), 0 !== P.rotation && O.rotate(P.rotation), O.scale(F, j), P.program(O), O.restore())
						} else if(H instanceof THREE.RenderableLine) {
							if(U = H.v1, z = H.v2, U.positionScreen.x *= T, U.positionScreen.y *= N, z.positionScreen.x *= T, z.positionScreen.y *= N, ct.setFromPoints([U.positionScreen, z.positionScreen]), !0 === ft.isIntersectionBox(ct))
								if(D = U, P = z, F = H, j = B, u(j.opacity), a(j.blending), O.beginPath(), O.moveTo(D.positionScreen.x, D.positionScreen.y), O.lineTo(P.positionScreen.x, P.positionScreen.y), j instanceof THREE.LineBasicMaterial) {
									f(j.linewidth), l(j.linecap), c(j.linejoin);
									if(j.vertexColors !== THREE.VertexColors) h(j.color.getStyle());
									else if(H = F.vertexColors[0].getStyle(), F = F.vertexColors[1].getStyle(), H === F) h(H);
									else {
										try {
											var Et = O.createLinearGradient(D.positionScreen.x, D.positionScreen.y, P.positionScreen.x, P.positionScreen.y);
											Et.addColorStop(0, H), Et.addColorStop(1, F)
										} catch(St) {
											Et = H
										}
										h(Et)
									}
									O.stroke(), ct.expandByScalar(2 * j.linewidth)
								} else j instanceof THREE.LineDashedMaterial && (f(j.linewidth), l(j.linecap), c(j.linejoin), h(j.color.getStyle()), d([j.dashSize, j.gapSize]), O.stroke(), ct.expandByScalar(2 * j.linewidth), d([]))
						} else if(H instanceof THREE.RenderableFace) {
							U = H.v1, z = H.v2, W = H.v3;
							if(-1 > U.positionScreen.z || 1 < U.positionScreen.z) continue;
							if(-1 > z.positionScreen.z || 1 < z.positionScreen.z) continue;
							if(-1 > W.positionScreen.z || 1 < W.positionScreen.z) continue;
							U.positionScreen.x *= T, U.positionScreen.y *= N, z.positionScreen.x *= T, z.positionScreen.y *= N, W.positionScreen.x *= T, W.positionScreen.y *= N, 0 < B.overdraw && (o(U.positionScreen, z.positionScreen, B.overdraw), o(z.positionScreen, W.positionScreen, B.overdraw), o(W.positionScreen, U.positionScreen, B.overdraw)), ct.setFromPoints([U.positionScreen, z.positionScreen, W.positionScreen]);
							if(!0 === ft.isIntersectionBox(ct)) {
								P = U, F = z, j = W, D = B, m.info.render.vertices += 3, m.info.render.faces++, u(D.opacity), a(D.blending), X = P.positionScreen.x, V = P.positionScreen.y, $ = F.positionScreen.x, J = F.positionScreen.y, K = j.positionScreen.x, Q = j.positionScreen.y;
								var B = X,
									bt = V,
									I = $,
									q = J,
									wt = K,
									xt = Q;
								O.beginPath(), O.moveTo(B, bt), O.lineTo(I, q), O.lineTo(wt, xt), O.closePath();
								if((D instanceof THREE.MeshLambertMaterial || D instanceof THREE.MeshPhongMaterial) && null === D.map) {
									Y.copy(D.color), Z.copy(D.emissive), D.vertexColors === THREE.FaceColors && Y.multiply(H.color), G.copy(ht), mt.copy(P.positionWorld).add(F.positionWorld).add(j.positionWorld).divideScalar(3), P = mt, F = H.normalModel, j = G, H = 0;
									for(B = b.length; H < B; H++) bt = b[H], et.copy(bt.color), bt instanceof THREE.DirectionalLight ? (I = vt.setFromMatrixPosition(bt.matrixWorld).normalize(), q = F.dot(I), 0 >= q || (q *= bt.intensity, j.add(et.multiplyScalar(q)))) : bt instanceof THREE.PointLight && (I = vt.setFromMatrixPosition(bt.matrixWorld), q = F.dot(vt.subVectors(I, P).normalize()), 0 >= q || (q *= 0 == bt.distance ? 1 : 1 - Math.min(P.distanceTo(I) / bt.distance, 1), 0 != q && (q *= bt.intensity, j.add(et.multiplyScalar(q)))));
									G.multiply(Y).add(Z), !0 === D.wireframe ? t(G, D.wireframeLinewidth, D.wireframeLinecap, D.wireframeLinejoin) : n(G)
								} else D instanceof THREE.MeshBasicMaterial || D instanceof THREE.MeshLambertMaterial || D instanceof THREE.MeshPhongMaterial ? null !== D.map ? D.map.mapping instanceof THREE.UVMapping && (nt = H.uvs, s(X, V, $, J, K, Q, nt[0].x, nt[0].y, nt[1].x, nt[1].y, nt[2].x, nt[2].y, D.map)) : null !== D.envMap ? D.envMap.mapping instanceof THREE.SphericalReflectionMapping ? (gt.copy(H.vertexNormalsModel[0]).applyMatrix3(yt), rt = .5 * gt.x + .5, it = .5 * gt.y + .5, gt.copy(H.vertexNormalsModel[1]).applyMatrix3(yt), st = .5 * gt.x + .5, ot = .5 * gt.y + .5, gt.copy(H.vertexNormalsModel[2]).applyMatrix3(yt), ut = .5 * gt.x + .5, at = .5 * gt.y + .5, s(X, V, $, J, K, Q, rt, it, st, ot, ut, at, D.envMap)) : D.envMap.mapping instanceof THREE.SphericalRefractionMapping && (gt.copy(H.vertexNormalsModel[0]).applyMatrix3(yt), rt = -0.5 * gt.x + .5, it = -0.5 * gt.y + .5, gt.copy(H.vertexNormalsModel[1]).applyMatrix3(yt), st = -0.5 * gt.x + .5, ot = -0.5 * gt.y + .5, gt.copy(H.vertexNormalsModel[2]).applyMatrix3(yt), ut = -0.5 * gt.x + .5, at = -0.5 * gt.y + .5, s(X, V, $, J, K, Q, rt, it, st, ot, ut, at, D.envMap)) : (G.copy(D.color), D.vertexColors === THREE.FaceColors && G.multiply(H.color), !0 === D.wireframe ? t(G, D.wireframeLinewidth, D.wireframeLinecap, D.wireframeLinejoin) : n(G)) : (D instanceof THREE.MeshDepthMaterial ? G.r = G.g = G.b = 1 - v(P.positionScreen.z * P.positionScreen.w, R.near, R.far) : D instanceof THREE.MeshNormalMaterial ? (gt.copy(H.normalModel).applyMatrix3(yt), G.setRGB(gt.x, gt.y, gt.z).multiplyScalar(.5).addScalar(.5)) : G.setRGB(1, 1, 1), !0 === D.wireframe ? t(G, D.wireframeLinewidth, D.wireframeLinecap, D.wireframeLinejoin) : n(G))
							}
						}
						lt.union(ct)
					}
				}
				O.setTransform(1, 0, 0, 1, 0, 0)
			}
		}
	}, THREE.ShaderChunk = {}, THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n", THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif", THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.default_vertex = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.lights_phong_fragment = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif", THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif", THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif", THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif", THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif", THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n", THREE.ShaderChunk.linear_to_gamma_fragment = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif", THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif", THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif", THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif", THREE.ShaderChunk.defaultnormal_vertex = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;", THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif", THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif", THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif", THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n", THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif", THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", THREE.UniformsUtils = {
		merge: function(e) {
			var t, n, r, i = {};
			for(t = 0; t < e.length; t++)
				for(n in r = this.clone(e[t]), r) i[n] = r[n];
			return i
		},
		clone: function(e) {
			var t, n, r, i = {};
			for(t in e)
				for(n in i[t] = {}, e[t]) r = e[t][n], i[t][n] = r instanceof THREE.Color || r instanceof THREE.Vector2 || r instanceof THREE.Vector3 || r instanceof THREE.Vector4 || r instanceof THREE.Matrix4 || r instanceof THREE.Texture ? r.clone() : r instanceof Array ? r.slice() : r;
			return i
		}
	}, THREE.UniformsLib = {
		common: {
			diffuse: {
				type: "c",
				value: new THREE.Color(15658734)
			},
			opacity: {
				type: "f",
				value: 1
			},
			map: {
				type: "t",
				value: null
			},
			offsetRepeat: {
				type: "v4",
				value: new THREE.Vector4(0, 0, 1, 1)
			},
			lightMap: {
				type: "t",
				value: null
			},
			specularMap: {
				type: "t",
				value: null
			},
			alphaMap: {
				type: "t",
				value: null
			},
			envMap: {
				type: "t",
				value: null
			},
			flipEnvMap: {
				type: "f",
				value: -1
			},
			useRefract: {
				type: "i",
				value: 0
			},
			reflectivity: {
				type: "f",
				value: 1
			},
			refractionRatio: {
				type: "f",
				value: .98
			},
			combine: {
				type: "i",
				value: 0
			},
			morphTargetInfluences: {
				type: "f",
				value: 0
			}
		},
		bump: {
			bumpMap: {
				type: "t",
				value: null
			},
			bumpScale: {
				type: "f",
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				type: "t",
				value: null
			},
			normalScale: {
				type: "v2",
				value: new THREE.Vector2(1, 1)
			}
		},
		fog: {
			fogDensity: {
				type: "f",
				value: 25e-5
			},
			fogNear: {
				type: "f",
				value: 1
			},
			fogFar: {
				type: "f",
				value: 2e3
			},
			fogColor: {
				type: "c",
				value: new THREE.Color(16777215)
			}
		},
		lights: {
			ambientLightColor: {
				type: "fv",
				value: []
			},
			directionalLightDirection: {
				type: "fv",
				value: []
			},
			directionalLightColor: {
				type: "fv",
				value: []
			},
			hemisphereLightDirection: {
				type: "fv",
				value: []
			},
			hemisphereLightSkyColor: {
				type: "fv",
				value: []
			},
			hemisphereLightGroundColor: {
				type: "fv",
				value: []
			},
			pointLightColor: {
				type: "fv",
				value: []
			},
			pointLightPosition: {
				type: "fv",
				value: []
			},
			pointLightDistance: {
				type: "fv1",
				value: []
			},
			spotLightColor: {
				type: "fv",
				value: []
			},
			spotLightPosition: {
				type: "fv",
				value: []
			},
			spotLightDirection: {
				type: "fv",
				value: []
			},
			spotLightDistance: {
				type: "fv1",
				value: []
			},
			spotLightAngleCos: {
				type: "fv1",
				value: []
			},
			spotLightExponent: {
				type: "fv1",
				value: []
			}
		},
		particle: {
			psColor: {
				type: "c",
				value: new THREE.Color(15658734)
			},
			opacity: {
				type: "f",
				value: 1
			},
			size: {
				type: "f",
				value: 1
			},
			scale: {
				type: "f",
				value: 1
			},
			map: {
				type: "t",
				value: null
			},
			fogDensity: {
				type: "f",
				value: 25e-5
			},
			fogNear: {
				type: "f",
				value: 1
			},
			fogFar: {
				type: "f",
				value: 2e3
			},
			fogColor: {
				type: "c",
				value: new THREE.Color(16777215)
			}
		},
		shadowmap: {
			shadowMap: {
				type: "tv",
				value: []
			},
			shadowMapSize: {
				type: "v2v",
				value: []
			},
			shadowBias: {
				type: "fv1",
				value: []
			},
			shadowDarkness: {
				type: "fv1",
				value: []
			},
			shadowMatrix: {
				type: "m4v",
				value: []
			}
		}
	}, THREE.ShaderLib = {
		basic: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
			vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		lambert: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				ambient: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				emissive: {
					type: "c",
					value: new THREE.Color(0)
				},
				wrapRGB: {
					type: "v3",
					value: new THREE.Vector3(1, 1, 1)
				}
			}]),
			vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED\n		if ( gl_FrontFacing )\n			gl_FragColor.xyz *= vLightFront;\n		else\n			gl_FragColor.xyz *= vLightBack;\n	#else\n		gl_FragColor.xyz *= vLightFront;\n	#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		phong: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				ambient: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				emissive: {
					type: "c",
					value: new THREE.Color(0)
				},
				specular: {
					type: "c",
					value: new THREE.Color(1118481)
				},
				shininess: {
					type: "f",
					value: 30
				},
				wrapRGB: {
					type: "v3",
					value: new THREE.Vector3(1, 1, 1)
				}
			}]),
			vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		particle_basic: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
			vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n	#else\n		gl_PointSize = size;\n	#endif\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		dashed: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
				scale: {
					type: "f",
					value: 1
				},
				dashSize: {
					type: "f",
					value: 1
				},
				totalSize: {
					type: "f",
					value: 2
				}
			}]),
			vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	gl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		depth: {
			uniforms: {
				mNear: {
					type: "f",
					value: 1
				},
				mFar: {
					type: "f",
					value: 2e3
				},
				opacity: {
					type: "f",
					value: 1
				}
			},
			vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
			fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")
		},
		normal: {
			uniforms: {
				opacity: {
					type: "f",
					value: 1
				}
			},
			vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
			fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
		},
		normalmap: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				enableAO: {
					type: "i",
					value: 0
				},
				enableDiffuse: {
					type: "i",
					value: 0
				},
				enableSpecular: {
					type: "i",
					value: 0
				},
				enableReflection: {
					type: "i",
					value: 0
				},
				enableDisplacement: {
					type: "i",
					value: 0
				},
				tDisplacement: {
					type: "t",
					value: null
				},
				tDiffuse: {
					type: "t",
					value: null
				},
				tCube: {
					type: "t",
					value: null
				},
				tNormal: {
					type: "t",
					value: null
				},
				tSpecular: {
					type: "t",
					value: null
				},
				tAO: {
					type: "t",
					value: null
				},
				uNormalScale: {
					type: "v2",
					value: new THREE.Vector2(1, 1)
				},
				uDisplacementBias: {
					type: "f",
					value: 0
				},
				uDisplacementScale: {
					type: "f",
					value: 1
				},
				diffuse: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				specular: {
					type: "c",
					value: new THREE.Color(1118481)
				},
				ambient: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				shininess: {
					type: "f",
					value: 30
				},
				opacity: {
					type: "f",
					value: 1
				},
				useRefract: {
					type: "i",
					value: 0
				},
				refractionRatio: {
					type: "f",
					value: .98
				},
				reflectivity: {
					type: "f",
					value: .5
				},
				uOffset: {
					type: "v2",
					value: new THREE.Vector2(0, 0)
				},
				uRepeat: {
					type: "v2",
					value: new THREE.Vector2(1, 1)
				},
				wrapRGB: {
					type: "v3",
					value: new THREE.Vector3(1, 1, 1)
				}
			}]),
			fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\n	uniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	gl_FragColor = vec4( vec3( 1.0 ), opacity );\n	vec3 specularTex = vec3( 1.0 );\n	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\n	normalTex.xy *= uNormalScale;\n	normalTex = normalize( normalTex );\n	if( enableDiffuse ) {\n		#ifdef GAMMA_INPUT\n			vec4 texelColor = texture2D( tDiffuse, vUv );\n			texelColor.xyz *= texelColor.xyz;\n			gl_FragColor = gl_FragColor * texelColor;\n		#else\n			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n		#endif\n	}\n	if( enableAO ) {\n		#ifdef GAMMA_INPUT\n			vec4 aoColor = texture2D( tAO, vUv );\n			aoColor.xyz *= aoColor.xyz;\n			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n		#else\n			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n		#endif\n	}", THREE.ShaderChunk.alphatest_fragment, "	if( enableSpecular )\n		specularTex = texture2D( tSpecular, vUv ).xyz;\n	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\n	vec3 finalNormal = tsb * normalTex;\n	#ifdef FLIP_SIDED\n		finalNormal = -finalNormal;\n	#endif\n	vec3 normal = normalize( finalNormal );\n	vec3 viewPosition = normalize( vViewPosition );\n	#if MAX_POINT_LIGHTS > 0\n		vec3 pointDiffuse = vec3( 0.0 );\n		vec3 pointSpecular = vec3( 0.0 );\n		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\n			float pointDistance = 1.0;\n			if ( pointLightDistance[ i ] > 0.0 )\n				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\n			pointVector = normalize( pointVector );\n			#ifdef WRAP_AROUND\n				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\n				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\n				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n			#else\n				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n			#endif\n			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\n			vec3 pointHalfVector = normalize( pointVector + viewPosition );\n			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );\n			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n		}\n	#endif\n	#if MAX_SPOT_LIGHTS > 0\n		vec3 spotDiffuse = vec3( 0.0 );\n		vec3 spotSpecular = vec3( 0.0 );\n		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\n			float spotDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\n			spotVector = normalize( spotVector );\n			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n			if ( spotEffect > spotLightAngleCos[ i ] ) {\n				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n				#ifdef WRAP_AROUND\n					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\n					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\n					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n				#else\n					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n				#endif\n				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\n				vec3 spotHalfVector = normalize( spotVector + viewPosition );\n				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n				float specularNormalization = ( shininess + 2.0 ) / 8.0;\n				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );\n				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n			}\n		}\n	#endif\n	#if MAX_DIR_LIGHTS > 0\n		vec3 dirDiffuse = vec3( 0.0 );\n		vec3 dirSpecular = vec3( 0.0 );\n		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\n			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n			vec3 dirVector = normalize( lDirection.xyz );\n			#ifdef WRAP_AROUND\n				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\n				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\n				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n			#else\n				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n			#endif\n			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\n			vec3 dirHalfVector = normalize( dirVector + viewPosition );\n			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n		}\n	#endif\n	#if MAX_HEMI_LIGHTS > 0\n		vec3 hemiDiffuse = vec3( 0.0 );\n		vec3 hemiSpecular = vec3( 0.0 );\n		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n			vec3 lVector = normalize( lDirection.xyz );\n			float dotProduct = dot( normal, lVector );\n			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n			hemiDiffuse += diffuse * hemiColor;\n			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n			vec3 lVectorGround = -lVector;\n			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n			float dotProductGround = dot( normal, lVectorGround );\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n		}\n	#endif\n	vec3 totalDiffuse = vec3( 0.0 );\n	vec3 totalSpecular = vec3( 0.0 );\n	#if MAX_DIR_LIGHTS > 0\n		totalDiffuse += dirDiffuse;\n		totalSpecular += dirSpecular;\n	#endif\n	#if MAX_HEMI_LIGHTS > 0\n		totalDiffuse += hemiDiffuse;\n		totalSpecular += hemiSpecular;\n	#endif\n	#if MAX_POINT_LIGHTS > 0\n		totalDiffuse += pointDiffuse;\n		totalSpecular += pointSpecular;\n	#endif\n	#if MAX_SPOT_LIGHTS > 0\n		totalDiffuse += spotDiffuse;\n		totalSpecular += spotSpecular;\n	#endif\n	#ifdef METAL\n		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n	#else\n		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n	#endif\n	if ( enableReflection ) {\n		vec3 vReflect;\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		if ( useRefract ) {\n			vReflect = refract( cameraToVertex, normal, refractionRatio );\n		} else {\n			vReflect = reflect( cameraToVertex, normal );\n		}\n		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n		#ifdef GAMMA_INPUT\n			cubeColor.xyz *= cubeColor.xyz;\n		#endif\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n	}", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
			vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\n	uniform sampler2D tDisplacement;\n	uniform float uDisplacementScale;\n	uniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "	#ifdef USE_SKINNING\n		vNormal = normalize( normalMatrix * skinnedNormal.xyz );\n		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\n		vTangent = normalize( normalMatrix * skinnedTangent.xyz );\n	#else\n		vNormal = normalize( normalMatrix * normal );\n		vTangent = normalize( normalMatrix * tangent.xyz );\n	#endif\n	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n	vUv = uv * uRepeat + uOffset;\n	vec3 displacedPosition;\n	#ifdef VERTEX_TEXTURES\n		if ( enableDisplacement ) {\n			vec3 dv = texture2D( tDisplacement, uv ).xyz;\n			float df = uDisplacementScale * dv.x + uDisplacementBias;\n			displacedPosition = position + normalize( normal ) * df;\n		} else {\n			#ifdef USE_SKINNING\n				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n				vec4 skinned = vec4( 0.0 );\n				skinned += boneMatX * skinVertex * skinWeight.x;\n				skinned += boneMatY * skinVertex * skinWeight.y;\n				skinned += boneMatZ * skinVertex * skinWeight.z;\n				skinned += boneMatW * skinVertex * skinWeight.w;\n				skinned  = bindMatrixInverse * skinned;\n				displacedPosition = skinned.xyz;\n			#else\n				displacedPosition = position;\n			#endif\n		}\n	#else\n		#ifdef USE_SKINNING\n			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n			vec4 skinned = vec4( 0.0 );\n			skinned += boneMatX * skinVertex * skinWeight.x;\n			skinned += boneMatY * skinVertex * skinWeight.y;\n			skinned += boneMatZ * skinVertex * skinWeight.z;\n			skinned += boneMatW * skinVertex * skinWeight.w;\n			skinned  = bindMatrixInverse * skinned;\n			displacedPosition = skinned.xyz;\n		#else\n			displacedPosition = position;\n		#endif\n	#endif\n	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "	vWorldPosition = worldPosition.xyz;\n	vViewPosition = -mvPosition.xyz;\n	#ifdef USE_SHADOWMAP\n		for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n		}\n	#endif\n}"].join("\n")
		},
		cube: {
			uniforms: {
				tCube: {
					type: "t",
					value: null
				},
				tFlip: {
					type: "f",
					value: -1
				}
			},
			vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n	vWorldPosition = worldPosition.xyz;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
			fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
		},
		depthRGBA: {
			uniforms: {},
			vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
			fragmentShader: [THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}"].join("\n")
		}
	}, THREE.WebGLRenderer = function(e) {
		function t(e, t) {
			var n = e.vertices.length,
				r = t.material;
			if(r.attributes) {
				void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
				for(var i in r.attributes) {
					var s = r.attributes[i];
					if(!s.__webglInitialized || s.createUniqueBuffers) {
						s.__webglInitialized = !0;
						var o = 1;
						"v2" === s.type ? o = 2 : "v3" === s.type ? o = 3 : "v4" === s.type ? o = 4 : "c" === s.type && (o = 3), s.size = o, s.array = new Float32Array(n * o), s.buffer = _t.createBuffer(), s.buffer.belongsToAttribute = i, s.needsUpdate = !0
					}
					e.__webglCustomAttributesList.push(s)
				}
			}
		}

		function n(e, t) {
			var n = t.geometry,
				o = e.faces3,
				u = 3 * o.length,
				a = 1 * o.length,
				f = 3 * o.length,
				o = r(t, e),
				l = s(o),
				c = i(o),
				h = o.vertexColors ? o.vertexColors : !1;
			e.__vertexArray = new Float32Array(3 * u), c && (e.__normalArray = new Float32Array(3 * u)), n.hasTangents && (e.__tangentArray = new Float32Array(4 * u)), h && (e.__colorArray = new Float32Array(3 * u)), l && (0 < n.faceVertexUvs.length && (e.__uvArray = new Float32Array(2 * u)), 1 < n.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * u))), t.geometry.skinWeights.length && t.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * u), e.__skinWeightArray = new Float32Array(4 * u)), n = null !== jt && 21845 < a ? Uint32Array : Uint16Array, e.__typeArray = n, e.__faceArray = new n(3 * a), e.__lineArray = new n(2 * f);
			if(e.numMorphTargets)
				for(e.__morphTargetsArrays = [], n = 0, l = e.numMorphTargets; n < l; n++) e.__morphTargetsArrays.push(new Float32Array(3 * u));
			if(e.numMorphNormals)
				for(e.__morphNormalsArrays = [], n = 0, l = e.numMorphNormals; n < l; n++) e.__morphNormalsArrays.push(new Float32Array(3 * u));
			e.__webglFaceCount = 3 * a, e.__webglLineCount = 2 * f;
			if(o.attributes) {
				void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
				for(var p in o.attributes) {
					var a = o.attributes[p],
						f = {},
						d;
					for(d in a) f[d] = a[d];
					if(!f.__webglInitialized || f.createUniqueBuffers) f.__webglInitialized = !0, n = 1, "v2" === f.type ? n = 2 : "v3" === f.type ? n = 3 : "v4" === f.type ? n = 4 : "c" === f.type && (n = 3), f.size = n, f.array = new Float32Array(u * n), f.buffer = _t.createBuffer(), f.buffer.belongsToAttribute = p, a.needsUpdate = !0, f.__original = a;
					e.__webglCustomAttributesList.push(f)
				}
			}
			e.__inittedArrays = !0
		}

		function r(e, t) {
			return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material
		}

		function i(e) {
			return e instanceof THREE.MeshBasicMaterial && !e.envMap || e instanceof THREE.MeshDepthMaterial ? !1 : e && void 0 !== e.shading && e.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading
		}

		function s(e) {
			return e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e instanceof THREE.ShaderMaterial ? !0 : !1
		}

		function o(e) {
			for(var t in e.attributes) {
				var n = "index" === t ? _t.ELEMENT_ARRAY_BUFFER : _t.ARRAY_BUFFER,
					r = e.attributes[t];
				r.buffer = _t.createBuffer(), _t.bindBuffer(n, r.buffer), _t.bufferData(n, r.array, _t.STATIC_DRAW)
			}
		}

		function u(e, t, n, r) {
			for(var i in t) {
				var s = t[i],
					o = n[i];
				if(0 <= s)
					if(o) {
						var u = o.itemSize;
						_t.bindBuffer(_t.ARRAY_BUFFER, o.buffer), f(s), _t.vertexAttribPointer(s, u, _t.FLOAT, !1, 0, r * u * 4)
					} else e.defaultAttributeValues && (2 === e.defaultAttributeValues[i].length ? _t.vertexAttrib2fv(s, e.defaultAttributeValues[i]) : 3 === e.defaultAttributeValues[i].length && _t.vertexAttrib3fv(s, e.defaultAttributeValues[i]))
			}
			l()
		}

		function a() {
			for(var e = 0, t = xt.length; e < t; e++) xt[e] = 0
		}

		function f(e) {
			xt[e] = 1, 0 === Tt[e] && (_t.enableVertexAttribArray(e), Tt[e] = 1)
		}

		function l() {
			for(var e = 0, t = Tt.length; e < t; e++) Tt[e] !== xt[e] && (_t.disableVertexAttribArray(e), Tt[e] = 0)
		}

		function c(e, t) {
			return e.z !== t.z ? t.z - e.z : e.id - t.id
		}

		function h(e, t) {
			return e.z !== t.z ? e.z - t.z : e.id - t.id
		}

		function p(e, t) {
			return t[0] - e[0]
		}

		function d(e, t, u) {
			if(!1 !== t.visible) {
				var a = e.__webglObjects[t.id];
				if(a && (!1 === t.frustumCulled || !0 === Nt.intersectsObject(t))) {
					var f = t.geometry,
						l, c, h;
					if(f instanceof THREE.BufferGeometry) {
						var v = _t.DYNAMIC_DRAW,
							m = f.attributes,
							g, y;
						for(g in m) y = m[g], y.needsUpdate && ("index" === g ? (_t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, y.buffer), _t.bufferData(_t.ELEMENT_ARRAY_BUFFER, y.array, v)) : (_t.bindBuffer(_t.ARRAY_BUFFER, y.buffer), _t.bufferData(_t.ARRAY_BUFFER, y.array, v)), y.needsUpdate = !1)
					} else if(t instanceof THREE.Mesh) {
						if(f.buffersNeedUpdate || f.groupsNeedUpdate) f instanceof THREE.BufferGeometry ? o(f) : t instanceof THREE.Mesh && b(e, t, f);
						for(var w = 0, x = f.geometryGroupsList.length; w < x; w++)
							if(l = f.geometryGroupsList[w], h = r(t, l), (f.buffersNeedUpdate || f.groupsNeedUpdate) && n(l, t), c = h.attributes && E(h), f.verticesNeedUpdate || f.morphTargetsNeedUpdate || f.elementsNeedUpdate || f.uvsNeedUpdate || f.normalsNeedUpdate || f.colorsNeedUpdate || f.tangentsNeedUpdate || c) {
								var T = l,
									N = t,
									C = _t.DYNAMIC_DRAW,
									k = !f.dynamic,
									L = h;
								if(T.__inittedArrays) {
									var A = i(L),
										O = L.vertexColors ? L.vertexColors : !1,
										M = s(L),
										_ = A === THREE.SmoothShading,
										D = void 0,
										P = void 0,
										H = void 0,
										B = void 0,
										j = void 0,
										F = void 0,
										I = void 0,
										q = void 0,
										R = void 0,
										U = void 0,
										z = void 0,
										W = void 0,
										X = void 0,
										V = void 0,
										$ = void 0,
										J = void 0,
										Y = void 0,
										Z = void 0,
										et = void 0,
										tt = void 0,
										nt = void 0,
										rt = void 0,
										it = void 0,
										st = void 0,
										ot = void 0,
										ut = void 0,
										at = void 0,
										ft = void 0,
										lt = void 0,
										ct = void 0,
										ht = void 0,
										pt = void 0,
										dt = void 0,
										vt = void 0,
										mt = void 0,
										gt = void 0,
										yt = void 0,
										bt = void 0,
										wt = void 0,
										Et = void 0,
										St = 0,
										xt = 0,
										Tt = 0,
										At = 0,
										Ot = 0,
										Mt = 0,
										Dt = 0,
										Pt = 0,
										Ht = 0,
										Bt = 0,
										jt = 0,
										Ft = 0,
										It = void 0,
										qt = T.__vertexArray,
										Rt = T.__uvArray,
										Ut = T.__uv2Array,
										zt = T.__normalArray,
										Wt = T.__tangentArray,
										Xt = T.__colorArray,
										Vt = T.__skinIndexArray,
										$t = T.__skinWeightArray,
										Jt = T.__morphTargetsArrays,
										Kt = T.__morphNormalsArrays,
										Qt = T.__webglCustomAttributesList,
										Gt = void 0,
										Yt = T.__faceArray,
										Zt = T.__lineArray,
										en = N.geometry,
										tn = en.elementsNeedUpdate,
										nn = en.uvsNeedUpdate,
										rn = en.normalsNeedUpdate,
										sn = en.tangentsNeedUpdate,
										on = en.colorsNeedUpdate,
										un = en.morphTargetsNeedUpdate,
										an = en.vertices,
										fn = T.faces3,
										ln = en.faces,
										cn = en.faceVertexUvs[0],
										hn = en.faceVertexUvs[1],
										pn = en.skinIndices,
										dn = en.skinWeights,
										vn = en.morphTargets,
										mn = en.morphNormals;
									if(en.verticesNeedUpdate) {
										D = 0;
										for(P = fn.length; D < P; D++) B = ln[fn[D]], W = an[B.a], X = an[B.b], V = an[B.c], qt[xt] = W.x, qt[xt + 1] = W.y, qt[xt + 2] = W.z, qt[xt + 3] = X.x, qt[xt + 4] = X.y, qt[xt + 5] = X.z, qt[xt + 6] = V.x, qt[xt + 7] = V.y, qt[xt + 8] = V.z, xt += 9;
										_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglVertexBuffer), _t.bufferData(_t.ARRAY_BUFFER, qt, C)
									}
									if(un)
										for(mt = 0, gt = vn.length; mt < gt; mt++) {
											D = jt = 0;
											for(P = fn.length; D < P; D++) wt = fn[D], B = ln[wt], W = vn[mt].vertices[B.a], X = vn[mt].vertices[B.b], V = vn[mt].vertices[B.c], yt = Jt[mt], yt[jt] = W.x, yt[jt + 1] = W.y, yt[jt + 2] = W.z, yt[jt + 3] = X.x, yt[jt + 4] = X.y, yt[jt + 5] = X.z, yt[jt + 6] = V.x, yt[jt + 7] = V.y, yt[jt + 8] = V.z, L.morphNormals && (_ ? (Et = mn[mt].vertexNormals[wt], Z = Et.a, et = Et.b, tt = Et.c) : tt = et = Z = mn[mt].faceNormals[wt], bt = Kt[mt], bt[jt] = Z.x, bt[jt + 1] = Z.y, bt[jt + 2] = Z.z, bt[jt + 3] = et.x, bt[jt + 4] = et.y, bt[jt + 5] = et.z, bt[jt + 6] = tt.x, bt[jt + 7] = tt.y, bt[jt + 8] = tt.z), jt += 9;
											_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglMorphTargetsBuffers[mt]), _t.bufferData(_t.ARRAY_BUFFER, Jt[mt], C), L.morphNormals && (_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglMorphNormalsBuffers[mt]), _t.bufferData(_t.ARRAY_BUFFER, Kt[mt], C))
										}
									if(dn.length) {
										D = 0;
										for(P = fn.length; D < P; D++) B = ln[fn[D]], st = dn[B.a], ot = dn[B.b], ut = dn[B.c], $t[Bt] = st.x, $t[Bt + 1] = st.y, $t[Bt + 2] = st.z, $t[Bt + 3] = st.w, $t[Bt + 4] = ot.x, $t[Bt + 5] = ot.y, $t[Bt + 6] = ot.z, $t[Bt + 7] = ot.w, $t[Bt + 8] = ut.x, $t[Bt + 9] = ut.y, $t[Bt + 10] = ut.z, $t[Bt + 11] = ut.w, at = pn[B.a], ft = pn[B.b], lt = pn[B.c], Vt[Bt] = at.x, Vt[Bt + 1] = at.y, Vt[Bt + 2] = at.z, Vt[Bt + 3] = at.w, Vt[Bt + 4] = ft.x, Vt[Bt + 5] = ft.y, Vt[Bt + 6] = ft.z, Vt[Bt + 7] = ft.w, Vt[Bt + 8] = lt.x, Vt[Bt + 9] = lt.y, Vt[Bt + 10] = lt.z, Vt[Bt + 11] = lt.w, Bt += 12;
										0 < Bt && (_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglSkinIndicesBuffer), _t.bufferData(_t.ARRAY_BUFFER, Vt, C), _t.bindBuffer(_t.ARRAY_BUFFER, T.__webglSkinWeightsBuffer), _t.bufferData(_t.ARRAY_BUFFER, $t, C))
									}
									if(on && O) {
										D = 0;
										for(P = fn.length; D < P; D++) B = ln[fn[D]], I = B.vertexColors, q = B.color, 3 === I.length && O === THREE.VertexColors ? (nt = I[0], rt = I[1], it = I[2]) : it = rt = nt = q, Xt[Ht] = nt.r, Xt[Ht + 1] = nt.g, Xt[Ht + 2] = nt.b, Xt[Ht + 3] = rt.r, Xt[Ht + 4] = rt.g, Xt[Ht + 5] = rt.b, Xt[Ht + 6] = it.r, Xt[Ht + 7] = it.g, Xt[Ht + 8] = it.b, Ht += 9;
										0 < Ht && (_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglColorBuffer), _t.bufferData(_t.ARRAY_BUFFER, Xt, C))
									}
									if(sn && en.hasTangents) {
										D = 0;
										for(P = fn.length; D < P; D++) B = ln[fn[D]], R = B.vertexTangents, $ = R[0], J = R[1], Y = R[2], Wt[Dt] = $.x, Wt[Dt + 1] = $.y, Wt[Dt + 2] = $.z, Wt[Dt + 3] = $.w, Wt[Dt + 4] = J.x, Wt[Dt + 5] = J.y, Wt[Dt + 6] = J.z, Wt[Dt + 7] = J.w, Wt[Dt + 8] = Y.x, Wt[Dt + 9] = Y.y, Wt[Dt + 10] = Y.z, Wt[Dt + 11] = Y.w, Dt += 12;
										_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglTangentBuffer), _t.bufferData(_t.ARRAY_BUFFER, Wt, C)
									}
									if(rn && A) {
										D = 0;
										for(P = fn.length; D < P; D++)
											if(B = ln[fn[D]], j = B.vertexNormals, F = B.normal, 3 === j.length && _)
												for(ct = 0; 3 > ct; ct++) pt = j[ct], zt[Mt] = pt.x, zt[Mt + 1] = pt.y, zt[Mt + 2] = pt.z, Mt += 3;
											else
												for(ct = 0; 3 > ct; ct++) zt[Mt] = F.x, zt[Mt + 1] = F.y, zt[Mt + 2] = F.z, Mt += 3;
										_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglNormalBuffer), _t.bufferData(_t.ARRAY_BUFFER, zt, C)
									}
									if(nn && cn && M) {
										D = 0;
										for(P = fn.length; D < P; D++)
											if(H = fn[D], U = cn[H], void 0 !== U)
												for(ct = 0; 3 > ct; ct++) dt = U[ct], Rt[Tt] = dt.x, Rt[Tt + 1] = dt.y, Tt += 2;
										0 < Tt && (_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglUVBuffer), _t.bufferData(_t.ARRAY_BUFFER, Rt, C))
									}
									if(nn && hn && M) {
										D = 0;
										for(P = fn.length; D < P; D++)
											if(H = fn[D], z = hn[H], void 0 !== z)
												for(ct = 0; 3 > ct; ct++) vt = z[ct], Ut[At] = vt.x, Ut[At + 1] = vt.y, At += 2;
										0 < At && (_t.bindBuffer(_t.ARRAY_BUFFER, T.__webglUV2Buffer), _t.bufferData(_t.ARRAY_BUFFER, Ut, C))
									}
									if(tn) {
										D = 0;
										for(P = fn.length; D < P; D++) Yt[Ot] = St, Yt[Ot + 1] = St + 1, Yt[Ot + 2] = St + 2, Ot += 3, Zt[Pt] = St, Zt[Pt + 1] = St + 1, Zt[Pt + 2] = St, Zt[Pt + 3] = St + 2, Zt[Pt + 4] = St + 1, Zt[Pt + 5] = St + 2, Pt += 6, St += 3;
										_t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, T.__webglFaceBuffer), _t.bufferData(_t.ELEMENT_ARRAY_BUFFER, Yt, C), _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, T.__webglLineBuffer), _t.bufferData(_t.ELEMENT_ARRAY_BUFFER, Zt, C)
									}
									if(Qt)
										for(ct = 0, ht = Qt.length; ct < ht; ct++)
											if(Gt = Qt[ct], Gt.__original.needsUpdate) {
												Ft = 0;
												if(1 === Gt.size) {
													if(void 0 === Gt.boundTo || "vertices" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) B = ln[fn[D]], Gt.array[Ft] = Gt.value[B.a], Gt.array[Ft + 1] = Gt.value[B.b], Gt.array[Ft + 2] = Gt.value[B.c], Ft += 3;
													else if("faces" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) It = Gt.value[fn[D]], Gt.array[Ft] = It, Gt.array[Ft + 1] = It, Gt.array[Ft + 2] = It, Ft += 3
												} else if(2 === Gt.size) {
													if(void 0 === Gt.boundTo || "vertices" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) B = ln[fn[D]], W = Gt.value[B.a], X = Gt.value[B.b], V = Gt.value[B.c], Gt.array[Ft] = W.x, Gt.array[Ft + 1] = W.y, Gt.array[Ft + 2] = X.x, Gt.array[Ft + 3] = X.y, Gt.array[Ft + 4] = V.x, Gt.array[Ft + 5] = V.y, Ft += 6;
													else if("faces" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) V = X = W = It = Gt.value[fn[D]], Gt.array[Ft] = W.x, Gt.array[Ft + 1] = W.y, Gt.array[Ft + 2] = X.x, Gt.array[Ft + 3] = X.y, Gt.array[Ft + 4] = V.x, Gt.array[Ft + 5] = V.y, Ft += 6
												} else if(3 === Gt.size) {
													var gn;
													gn = "c" === Gt.type ? ["r", "g", "b"] : ["x", "y", "z"];
													if(void 0 === Gt.boundTo || "vertices" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) B = ln[fn[D]], W = Gt.value[B.a], X = Gt.value[B.b], V = Gt.value[B.c], Gt.array[Ft] = W[gn[0]], Gt.array[Ft + 1] = W[gn[1]], Gt.array[Ft + 2] = W[gn[2]], Gt.array[Ft + 3] = X[gn[0]], Gt.array[Ft + 4] = X[gn[1]], Gt.array[Ft + 5] = X[gn[2]], Gt.array[Ft + 6] = V[gn[0]], Gt.array[Ft + 7] = V[gn[1]], Gt.array[Ft + 8] = V[gn[2]], Ft += 9;
													else if("faces" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) V = X = W = It = Gt.value[fn[D]], Gt.array[Ft] = W[gn[0]], Gt.array[Ft + 1] = W[gn[1]], Gt.array[Ft + 2] = W[gn[2]], Gt.array[Ft + 3] = X[gn[0]], Gt.array[Ft + 4] = X[gn[1]], Gt.array[Ft + 5] = X[gn[2]], Gt.array[Ft + 6] = V[gn[0]], Gt.array[Ft + 7] = V[gn[1]], Gt.array[Ft + 8] = V[gn[2]], Ft += 9;
													else if("faceVertices" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) It = Gt.value[fn[D]], W = It[0], X = It[1], V = It[2], Gt.array[Ft] = W[gn[0]], Gt.array[Ft + 1] = W[gn[1]], Gt.array[Ft + 2] = W[gn[2]], Gt.array[Ft + 3] = X[gn[0]], Gt.array[Ft + 4] = X[gn[1]], Gt.array[Ft + 5] = X[gn[2]], Gt.array[Ft + 6] = V[gn[0]], Gt.array[Ft + 7] = V[gn[1]], Gt.array[Ft + 8] = V[gn[2]], Ft += 9
												} else if(4 === Gt.size)
													if(void 0 === Gt.boundTo || "vertices" === Gt.boundTo)
														for(D = 0, P = fn.length; D < P; D++) B = ln[fn[D]], W = Gt.value[B.a], X = Gt.value[B.b], V = Gt.value[B.c], Gt.array[Ft] = W.x, Gt.array[Ft + 1] = W.y, Gt.array[Ft + 2] = W.z, Gt.array[Ft + 3] = W.w, Gt.array[Ft + 4] = X.x, Gt.array[Ft + 5] = X.y, Gt.array[Ft + 6] = X.z, Gt.array[Ft + 7] = X.w, Gt.array[Ft + 8] = V.x, Gt.array[Ft + 9] = V.y, Gt.array[Ft + 10] = V.z, Gt.array[Ft + 11] = V.w, Ft += 12;
													else if("faces" === Gt.boundTo)
													for(D = 0, P = fn.length; D < P; D++) V = X = W = It = Gt.value[fn[D]], Gt.array[Ft] = W.x, Gt.array[Ft + 1] = W.y, Gt.array[Ft + 2] = W.z, Gt.array[Ft + 3] = W.w, Gt.array[Ft + 4] = X.x, Gt.array[Ft + 5] = X.y, Gt.array[Ft + 6] = X.z, Gt.array[Ft + 7] = X.w, Gt.array[Ft + 8] = V.x, Gt.array[Ft + 9] = V.y, Gt.array[Ft + 10] = V.z, Gt.array[Ft + 11] = V.w, Ft += 12;
												else if("faceVertices" === Gt.boundTo)
													for(D = 0, P = fn.length; D < P; D++) It = Gt.value[fn[D]], W = It[0], X = It[1], V = It[2], Gt.array[Ft] = W.x, Gt.array[Ft + 1] = W.y, Gt.array[Ft + 2] = W.z, Gt.array[Ft + 3] = W.w, Gt.array[Ft + 4] = X.x, Gt.array[Ft + 5] = X.y, Gt.array[Ft + 6] = X.z, Gt.array[Ft + 7] = X.w, Gt.array[Ft + 8] = V.x, Gt.array[Ft + 9] = V.y, Gt.array[Ft + 10] = V.z, Gt.array[Ft + 11] = V.w, Ft += 12;
												_t.bindBuffer(_t.ARRAY_BUFFER, Gt.buffer), _t.bufferData(_t.ARRAY_BUFFER, Gt.array, C)
											}
									k && (delete T.__inittedArrays, delete T.__colorArray, delete T.__normalArray, delete T.__tangentArray, delete T.__uvArray, delete T.__uv2Array, delete T.__faceArray, delete T.__vertexArray, delete T.__lineArray, delete T.__skinIndexArray, delete T.__skinWeightArray)
								}
							}
						f.verticesNeedUpdate = !1, f.morphTargetsNeedUpdate = !1, f.elementsNeedUpdate = !1, f.uvsNeedUpdate = !1, f.normalsNeedUpdate = !1, f.colorsNeedUpdate = !1, f.tangentsNeedUpdate = !1, f.buffersNeedUpdate = !1, h.attributes && S(h)
					} else if(t instanceof THREE.Line) {
						h = r(t, f), c = h.attributes && E(h);
						if(f.verticesNeedUpdate || f.colorsNeedUpdate || f.lineDistancesNeedUpdate || c) {
							var yn = _t.DYNAMIC_DRAW,
								bn, wn, En, Sn, xn, Tn, Nn = f.vertices,
								Cn = f.colors,
								kn = f.lineDistances,
								Ln = Nn.length,
								An = Cn.length,
								On = kn.length,
								Mn = f.__vertexArray,
								_n = f.__colorArray,
								Dn = f.__lineDistanceArray,
								Pn = f.colorsNeedUpdate,
								Hn = f.lineDistancesNeedUpdate,
								Bn = f.__webglCustomAttributesList,
								jn, Fn, In, qn, Rn, Un;
							if(f.verticesNeedUpdate) {
								for(bn = 0; bn < Ln; bn++) Sn = Nn[bn], xn = 3 * bn, Mn[xn] = Sn.x, Mn[xn + 1] = Sn.y, Mn[xn + 2] = Sn.z;
								_t.bindBuffer(_t.ARRAY_BUFFER, f.__webglVertexBuffer), _t.bufferData(_t.ARRAY_BUFFER, Mn, yn)
							}
							if(Pn) {
								for(wn = 0; wn < An; wn++) Tn = Cn[wn], xn = 3 * wn, _n[xn] = Tn.r, _n[xn + 1] = Tn.g, _n[xn + 2] = Tn.b;
								_t.bindBuffer(_t.ARRAY_BUFFER, f.__webglColorBuffer), _t.bufferData(_t.ARRAY_BUFFER, _n, yn)
							}
							if(Hn) {
								for(En = 0; En < On; En++) Dn[En] = kn[En];
								_t.bindBuffer(_t.ARRAY_BUFFER, f.__webglLineDistanceBuffer), _t.bufferData(_t.ARRAY_BUFFER, Dn, yn)
							}
							if(Bn)
								for(jn = 0, Fn = Bn.length; jn < Fn; jn++)
									if(Un = Bn[jn], Un.needsUpdate && (void 0 === Un.boundTo || "vertices" === Un.boundTo)) {
										xn = 0, qn = Un.value.length;
										if(1 === Un.size)
											for(In = 0; In < qn; In++) Un.array[In] = Un.value[In];
										else if(2 === Un.size)
											for(In = 0; In < qn; In++) Rn = Un.value[In], Un.array[xn] = Rn.x, Un.array[xn + 1] = Rn.y, xn += 2;
										else if(3 === Un.size)
											if("c" === Un.type)
												for(In = 0; In < qn; In++) Rn = Un.value[In], Un.array[xn] = Rn.r, Un.array[xn + 1] = Rn.g, Un.array[xn + 2] = Rn.b, xn += 3;
											else
												for(In = 0; In < qn; In++) Rn = Un.value[In], Un.array[xn] = Rn.x, Un.array[xn + 1] = Rn.y, Un.array[xn + 2] = Rn.z, xn += 3;
										else if(4 === Un.size)
											for(In = 0; In < qn; In++) Rn = Un.value[In], Un.array[xn] = Rn.x, Un.array[xn + 1] = Rn.y, Un.array[xn + 2] = Rn.z, Un.array[xn + 3] = Rn.w, xn += 4;
										_t.bindBuffer(_t.ARRAY_BUFFER, Un.buffer), _t.bufferData(_t.ARRAY_BUFFER, Un.array, yn)
									}
						}
						f.verticesNeedUpdate = !1, f.colorsNeedUpdate = !1, f.lineDistancesNeedUpdate = !1, h.attributes && S(h)
					} else if(t instanceof THREE.PointCloud) {
						h = r(t, f), c = h.attributes && E(h);
						if(f.verticesNeedUpdate || f.colorsNeedUpdate || t.sortParticles || c) {
							var zn = _t.DYNAMIC_DRAW,
								Wn, Xn, Vn, $n, Jn, Kn, Qn = f.vertices,
								Gn = Qn.length,
								Yn = f.colors,
								Zn = Yn.length,
								er = f.__vertexArray,
								tr = f.__colorArray,
								nr = f.__sortArray,
								rr = f.verticesNeedUpdate,
								ir = f.colorsNeedUpdate,
								sr = f.__webglCustomAttributesList,
								or, ur, ar, fr, lr, cr;
							if(t.sortParticles) {
								kt.copy(Ct), kt.multiply(t.matrixWorld);
								for(Wn = 0; Wn < Gn; Wn++) Vn = Qn[Wn], Lt.copy(Vn), Lt.applyProjection(kt), nr[Wn] = [Lt.z, Wn];
								nr.sort(p);
								for(Wn = 0; Wn < Gn; Wn++) Vn = Qn[nr[Wn][1]], $n = 3 * Wn, er[$n] = Vn.x, er[$n + 1] = Vn.y, er[$n + 2] = Vn.z;
								for(Xn = 0; Xn < Zn; Xn++) $n = 3 * Xn, Kn = Yn[nr[Xn][1]], tr[$n] = Kn.r, tr[$n + 1] = Kn.g, tr[$n + 2] = Kn.b;
								if(sr)
									for(or = 0, ur = sr.length; or < ur; or++)
										if(cr = sr[or], void 0 === cr.boundTo || "vertices" === cr.boundTo)
											if($n = 0, fr = cr.value.length, 1 === cr.size)
												for(ar = 0; ar < fr; ar++) Jn = nr[ar][1], cr.array[ar] = cr.value[Jn];
											else if(2 === cr.size)
									for(ar = 0; ar < fr; ar++) Jn = nr[ar][1], lr = cr.value[Jn], cr.array[$n] = lr.x, cr.array[$n + 1] = lr.y, $n += 2;
								else if(3 === cr.size)
									if("c" === cr.type)
										for(ar = 0; ar < fr; ar++) Jn = nr[ar][1], lr = cr.value[Jn], cr.array[$n] = lr.r, cr.array[$n + 1] = lr.g, cr.array[$n + 2] = lr.b, $n += 3;
									else
										for(ar = 0; ar < fr; ar++) Jn = nr[ar][1], lr = cr.value[Jn], cr.array[$n] = lr.x, cr.array[$n + 1] = lr.y, cr.array[$n + 2] = lr.z, $n += 3;
								else if(4 === cr.size)
									for(ar = 0; ar < fr; ar++) Jn = nr[ar][1], lr = cr.value[Jn], cr.array[$n] = lr.x, cr.array[$n + 1] = lr.y, cr.array[$n + 2] = lr.z, cr.array[$n + 3] = lr.w, $n += 4
							} else {
								if(rr)
									for(Wn = 0; Wn < Gn; Wn++) Vn = Qn[Wn], $n = 3 * Wn, er[$n] = Vn.x, er[$n + 1] = Vn.y, er[$n + 2] = Vn.z;
								if(ir)
									for(Xn = 0; Xn < Zn; Xn++) Kn = Yn[Xn], $n = 3 * Xn, tr[$n] = Kn.r, tr[$n + 1] = Kn.g, tr[$n + 2] = Kn.b;
								if(sr)
									for(or = 0, ur = sr.length; or < ur; or++)
										if(cr = sr[or], cr.needsUpdate && (void 0 === cr.boundTo || "vertices" === cr.boundTo))
											if(fr = cr.value.length, $n = 0, 1 === cr.size)
												for(ar = 0; ar < fr; ar++) cr.array[ar] = cr.value[ar];
											else if(2 === cr.size)
									for(ar = 0; ar < fr; ar++) lr = cr.value[ar], cr.array[$n] = lr.x, cr.array[$n + 1] = lr.y, $n += 2;
								else if(3 === cr.size)
									if("c" === cr.type)
										for(ar = 0; ar < fr; ar++) lr = cr.value[ar], cr.array[$n] = lr.r, cr.array[$n + 1] = lr.g, cr.array[$n + 2] = lr.b, $n += 3;
									else
										for(ar = 0; ar < fr; ar++) lr = cr.value[ar], cr.array[$n] = lr.x, cr.array[$n + 1] = lr.y, cr.array[$n + 2] = lr.z, $n += 3;
								else if(4 === cr.size)
									for(ar = 0; ar < fr; ar++) lr = cr.value[ar], cr.array[$n] = lr.x, cr.array[$n + 1] = lr.y, cr.array[$n + 2] = lr.z, cr.array[$n + 3] = lr.w, $n += 4
							}
							if(rr || t.sortParticles) _t.bindBuffer(_t.ARRAY_BUFFER, f.__webglVertexBuffer), _t.bufferData(_t.ARRAY_BUFFER, er, zn);
							if(ir || t.sortParticles) _t.bindBuffer(_t.ARRAY_BUFFER, f.__webglColorBuffer), _t.bufferData(_t.ARRAY_BUFFER, tr, zn);
							if(sr)
								for(or = 0, ur = sr.length; or < ur; or++)
									if(cr = sr[or], cr.needsUpdate || t.sortParticles) _t.bindBuffer(_t.ARRAY_BUFFER, cr.buffer), _t.bufferData(_t.ARRAY_BUFFER, cr.array, zn)
						}
						f.verticesNeedUpdate = !1, f.colorsNeedUpdate = !1, h.attributes && S(h)
					}
					for(var hr = 0, pr = a.length; hr < pr; hr++) {
						var dr = a[hr],
							vr = dr,
							mr = vr.object,
							gr = vr.buffer,
							yr = mr.geometry,
							br = mr.material;
						br instanceof THREE.MeshFaceMaterial ? (br = br.materials[yr instanceof THREE.BufferGeometry ? 0 : gr.materialIndex], br.transparent ? (vr.material = br, Q.push(vr)) : (vr.material = br, K.push(vr))) : br && (br.transparent ? (vr.material = br, Q.push(vr)) : (vr.material = br, K.push(vr))), dr.render = !0, !0 === G.sortObjects && (null !== t.renderDepth ? dr.z = t.renderDepth : (Lt.setFromMatrixPosition(t.matrixWorld), Lt.applyProjection(Ct), dr.z = Lt.z))
					}
				}
				hr = 0;
				for(pr = t.children.length; hr < pr; hr++) d(e, t.children[hr], u)
			}
		}

		function v(e, t, n) {
			if(0 !== e.length)
				for(var r = 0, i = e.length; r < i; r++) rt = Z = null, tt = nt = ot = st = ht = ct = ut = -1, Ot = !0, e[r].render(t, n, Et, St), rt = Z = null, tt = nt = ot = st = ht = ct = ut = -1, Ot = !0
		}

		function m(e, t, n, r, i, s) {
			for(var o, u, a, f = e.length - 1; - 1 !== f; f--) {
				o = e[f], u = o.object, a = o.buffer, k(u, t);
				if(s) o = s;
				else {
					o = o.material;
					if(!o) continue;
					i && G.setBlending(o.blending, o.blendEquation, o.blendSrc, o.blendDst), G.setDepthTest(o.depthTest), G.setDepthWrite(o.depthWrite), M(o.polygonOffset, o.polygonOffsetFactor, o.polygonOffsetUnits)
				}
				G.setMaterialFaces(o), a instanceof THREE.BufferGeometry ? G.renderBufferDirect(t, n, r, o, a, u) : G.renderBuffer(t, n, r, o, a, u)
			}
		}

		function g(e, t, n, r, i, s, o) {
			for(var u, a, f = 0, l = e.length; f < l; f++)
				if(u = e[f], a = u.object, a.visible) {
					if(o) u = o;
					else {
						u = u[t];
						if(!u) continue;
						s && G.setBlending(u.blending, u.blendEquation, u.blendSrc, u.blendDst), G.setDepthTest(u.depthTest), G.setDepthWrite(u.depthWrite), M(u.polygonOffset, u.polygonOffsetFactor, u.polygonOffsetUnits)
					}
					G.renderImmediateObject(n, r, i, u, a)
				}
		}

		function y(e) {
			var t = e.object.material;
			t.transparent ? (e.transparent = t, e.opaque = null) : (e.opaque = t, e.transparent = null)
		}

		function b(e, t, r) {
			var i, s = !1;
			i = t.material;
			if(void 0 === r.geometryGroups || r.groupsNeedUpdate) delete e.__webglObjects[t.id], r.makeGroups(i instanceof THREE.MeshFaceMaterial, jt ? 4294967296 : 65535), r.groupsNeedUpdate = !1;
			for(var o = 0, u = r.geometryGroupsList.length; o < u; o++) {
				i = r.geometryGroupsList[o];
				if(i.__webglVertexBuffer) s = !1;
				else {
					s = i, s.__webglVertexBuffer = _t.createBuffer(), s.__webglNormalBuffer = _t.createBuffer(), s.__webglTangentBuffer = _t.createBuffer(), s.__webglColorBuffer = _t.createBuffer(), s.__webglUVBuffer = _t.createBuffer(), s.__webglUV2Buffer = _t.createBuffer(), s.__webglSkinIndicesBuffer = _t.createBuffer(), s.__webglSkinWeightsBuffer = _t.createBuffer(), s.__webglFaceBuffer = _t.createBuffer(), s.__webglLineBuffer = _t.createBuffer();
					var a = void 0,
						f = void 0;
					if(s.numMorphTargets)
						for(s.__webglMorphTargetsBuffers = [], a = 0, f = s.numMorphTargets; a < f; a++) s.__webglMorphTargetsBuffers.push(_t.createBuffer());
					if(s.numMorphNormals)
						for(s.__webglMorphNormalsBuffers = [], a = 0, f = s.numMorphNormals; a < f; a++) s.__webglMorphNormalsBuffers.push(_t.createBuffer());
					G.info.memory.geometries++, n(i, t), r.verticesNeedUpdate = !0, r.morphTargetsNeedUpdate = !0, r.elementsNeedUpdate = !0, r.uvsNeedUpdate = !0, r.normalsNeedUpdate = !0, r.tangentsNeedUpdate = !0, s = r.colorsNeedUpdate = !0
				}(s || void 0 === t.__webglActive) && w(e.__webglObjects, i, t)
			}
			t.__webglActive = !0
		}

		function w(e, t, n) {
			var r = n.id;
			e[r] = e[r] || [], e[r].push({
				id: r,
				buffer: t,
				object: n,
				material: null,
				z: 0
			})
		}

		function E(e) {
			for(var t in e.attributes)
				if(e.attributes[t].needsUpdate) return !0;
			return !1
		}

		function S(e) {
			for(var t in e.attributes) e.attributes[t].needsUpdate = !1
		}

		function x(e, t) {
			if(e instanceof THREE.Mesh || e instanceof THREE.PointCloud || e instanceof THREE.Line) delete t.__webglObjects[e.id];
			else if(e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback)
				for(var n = t.__webglObjectsImmediate, r = n.length - 1; 0 <= r; r--) n[r].object === e && n.splice(r, 1);
			delete e.__webglActive
		}

		function T(e, t, n, r, i) {
			it = 0, r.needsUpdate && (r.program && tn(r), G.initMaterial(r, t, n, i), r.needsUpdate = !1), r.morphTargets && !i.__webglMorphTargetInfluences && (i.__webglMorphTargetInfluences = new Float32Array(G.maxMorphTargets));
			var s = !1,
				o = !1,
				u = !1,
				a = r.program,
				f = a.uniforms,
				l = r.__webglShader.uniforms;
			a.id !== Z && (_t.useProgram(a.program), Z = a.id, u = o = s = !0), r.id !== tt && (-1 === tt && (u = !0), tt = r.id, o = !0);
			if(s || e !== rt) _t.uniformMatrix4fv(f.projectionMatrix, !1, e.projectionMatrix.elements), V && _t.uniform1f(f.logDepthBufFC, 2 / (Math.log(e.far + 1) / Math.LN2)), e !== rt && (rt = e), (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && null !== f.cameraPosition && (Lt.setFromMatrixPosition(e.matrixWorld), _t.uniform3f(f.cameraPosition, Lt.x, Lt.y, Lt.z)), (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.ShaderMaterial || r.skinning) && null !== f.viewMatrix && _t.uniformMatrix4fv(f.viewMatrix, !1, e.matrixWorldInverse.elements);
			r.skinning && (i.bindMatrix && null !== f.bindMatrix && _t.uniformMatrix4fv(f.bindMatrix, !1, i.bindMatrix.elements), i.bindMatrixInverse && null !== f.bindMatrixInverse && _t.uniformMatrix4fv(f.bindMatrixInverse, !1, i.bindMatrixInverse.elements), zt && i.skeleton && i.skeleton.useVertexTexture ? (null !== f.boneTexture && (s = C(), _t.uniform1i(f.boneTexture, s), G.setTexture(i.skeleton.boneTexture, s)), null !== f.boneTextureWidth && _t.uniform1i(f.boneTextureWidth, i.skeleton.boneTextureWidth), null !== f.boneTextureHeight && _t.uniform1i(f.boneTextureHeight, i.skeleton.boneTextureHeight)) : i.skeleton && i.skeleton.boneMatrices && null !== f.boneGlobalMatrices && _t.uniformMatrix4fv(f.boneGlobalMatrices, !1, i.skeleton.boneMatrices));
			if(o) {
				n && r.fog && (l.fogColor.value = n.color, n instanceof THREE.Fog ? (l.fogNear.value = n.near, l.fogFar.value = n.far) : n instanceof THREE.FogExp2 && (l.fogDensity.value = n.density));
				if(r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) {
					if(Ot) {
						var u = !0,
							c, h = s = 0,
							p = 0,
							d, v, m, g = Mt,
							y = g.directional.colors,
							b = g.directional.positions,
							w = g.point.colors,
							E = g.point.positions,
							S = g.point.distances,
							x = g.spot.colors,
							T = g.spot.positions,
							k = g.spot.distances,
							O = g.spot.directions,
							M = g.spot.anglesCos,
							D = g.spot.exponents,
							P = g.hemi.skyColors,
							H = g.hemi.groundColors,
							F = g.hemi.positions,
							I = 0,
							q = 0,
							R = 0,
							U = 0,
							z = 0,
							W = 0,
							X = 0,
							$ = 0,
							J = c = 0;
						n = m = J = 0;
						for(o = t.length; n < o; n++) c = t[n], c.onlyShadow || (d = c.color, v = c.intensity, m = c.distance, c instanceof THREE.AmbientLight ? c.visible && (G.gammaInput ? (s += d.r * d.r, h += d.g * d.g, p += d.b * d.b) : (s += d.r, h += d.g, p += d.b)) : c instanceof THREE.DirectionalLight ? (z += 1, c.visible && (At.setFromMatrixPosition(c.matrixWorld), Lt.setFromMatrixPosition(c.target.matrixWorld), At.sub(Lt), At.normalize(), c = 3 * I, b[c] = At.x, b[c + 1] = At.y, b[c + 2] = At.z, G.gammaInput ? L(y, c, d, v * v) : A(y, c, d, v), I += 1)) : c instanceof THREE.PointLight ? (W += 1, c.visible && (J = 3 * q, G.gammaInput ? L(w, J, d, v * v) : A(w, J, d, v), Lt.setFromMatrixPosition(c.matrixWorld), E[J] = Lt.x, E[J + 1] = Lt.y, E[J + 2] = Lt.z, S[q] = m, q += 1)) : c instanceof THREE.SpotLight ? (X += 1, c.visible && (J = 3 * R, G.gammaInput ? L(x, J, d, v * v) : A(x, J, d, v), Lt.setFromMatrixPosition(c.matrixWorld), T[J] = Lt.x, T[J + 1] = Lt.y, T[J + 2] = Lt.z, k[R] = m, At.copy(Lt), Lt.setFromMatrixPosition(c.target.matrixWorld), At.sub(Lt), At.normalize(), O[J] = At.x, O[J + 1] = At.y, O[J + 2] = At.z, M[R] = Math.cos(c.angle), D[R] = c.exponent, R += 1)) : c instanceof THREE.HemisphereLight && ($ += 1, c.visible && (At.setFromMatrixPosition(c.matrixWorld), At.normalize(), m = 3 * U, F[m] = At.x, F[m + 1] = At.y, F[m + 2] = At.z, d = c.color, c = c.groundColor, G.gammaInput ? (v *= v, L(P, m, d, v), L(H, m, c, v)) : (A(P, m, d, v), A(H, m, c, v)), U += 1)));
						n = 3 * I;
						for(o = Math.max(y.length, 3 * z); n < o; n++) y[n] = 0;
						n = 3 * q;
						for(o = Math.max(w.length, 3 * W); n < o; n++) w[n] = 0;
						n = 3 * R;
						for(o = Math.max(x.length, 3 * X); n < o; n++) x[n] = 0;
						n = 3 * U;
						for(o = Math.max(P.length, 3 * $); n < o; n++) P[n] = 0;
						n = 3 * U;
						for(o = Math.max(H.length, 3 * $); n < o; n++) H[n] = 0;
						g.directional.length = I, g.point.length = q, g.spot.length = R, g.hemi.length = U, g.ambient[0] = s, g.ambient[1] = h, g.ambient[2] = p, Ot = !1
					}
					u ? (u = Mt, l.ambientLightColor.value = u.ambient, l.directionalLightColor.value = u.directional.colors, l.directionalLightDirection.value = u.directional.positions, l.pointLightColor.value = u.point.colors, l.pointLightPosition.value = u.point.positions, l.pointLightDistance.value = u.point.distances, l.spotLightColor.value = u.spot.colors, l.spotLightPosition.value = u.spot.positions, l.spotLightDistance.value = u.spot.distances, l.spotLightDirection.value = u.spot.directions, l.spotLightAngleCos.value = u.spot.anglesCos, l.spotLightExponent.value = u.spot.exponents, l.hemisphereLightSkyColor.value = u.hemi.skyColors, l.hemisphereLightGroundColor.value = u.hemi.groundColors, l.hemisphereLightDirection.value = u.hemi.positions, N(l, !0)) : N(l, !1)
				}
				if(r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) {
					l.opacity.value = r.opacity, G.gammaInput ? l.diffuse.value.copyGammaToLinear(r.color) : l.diffuse.value = r.color, l.map.value = r.map, l.lightMap.value = r.lightMap, l.specularMap.value = r.specularMap, l.alphaMap.value = r.alphaMap, r.bumpMap && (l.bumpMap.value = r.bumpMap, l.bumpScale.value = r.bumpScale), r.normalMap && (l.normalMap.value = r.normalMap, l.normalScale.value.copy(r.normalScale));
					var K;
					r.map ? K = r.map : r.specularMap ? K = r.specularMap : r.normalMap ? K = r.normalMap : r.bumpMap ? K = r.bumpMap : r.alphaMap && (K = r.alphaMap), void 0 !== K && (u = K.offset, K = K.repeat, l.offsetRepeat.value.set(u.x, u.y, K.x, K.y)), l.envMap.value = r.envMap, l.flipEnvMap.value = r.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, l.reflectivity.value = r.reflectivity, l.refractionRatio.value = r.refractionRatio, l.combine.value = r.combine, l.useRefract.value = r.envMap && r.envMap.mapping instanceof THREE.CubeRefractionMapping
				}
				r instanceof THREE.LineBasicMaterial ? (l.diffuse.value = r.color, l.opacity.value = r.opacity) : r instanceof THREE.LineDashedMaterial ? (l.diffuse.value = r.color, l.opacity.value = r.opacity, l.dashSize.value = r.dashSize, l.totalSize.value = r.dashSize + r.gapSize, l.scale.value = r.scale) : r instanceof THREE.PointCloudMaterial ? (l.psColor.value = r.color, l.opacity.value = r.opacity, l.size.value = r.size, l.scale.value = j.height / 2, l.map.value = r.map) : r instanceof THREE.MeshPhongMaterial ? (l.shininess.value = r.shininess, G.gammaInput ? (l.ambient.value.copyGammaToLinear(r.ambient), l.emissive.value.copyGammaToLinear(r.emissive), l.specular.value.copyGammaToLinear(r.specular)) : (l.ambient.value = r.ambient, l.emissive.value = r.emissive, l.specular.value = r.specular), r.wrapAround && l.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshLambertMaterial ? (G.gammaInput ? (l.ambient.value.copyGammaToLinear(r.ambient), l.emissive.value.copyGammaToLinear(r.emissive)) : (l.ambient.value = r.ambient, l.emissive.value = r.emissive), r.wrapAround && l.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshDepthMaterial ? (l.mNear.value = e.near, l.mFar.value = e.far, l.opacity.value = r.opacity) : r instanceof THREE.MeshNormalMaterial && (l.opacity.value = r.opacity);
				if(i.receiveShadow && !r._shadowPass && l.shadowMatrix)
					for(K = e = 0, u = t.length; K < u; K++) n = t[K], n.castShadow && (n instanceof THREE.SpotLight || n instanceof THREE.DirectionalLight && !n.shadowCascade) && (l.shadowMap.value[e] = n.shadowMap, l.shadowMapSize.value[e] = n.shadowMapSize, l.shadowMatrix.value[e] = n.shadowMatrix, l.shadowDarkness.value[e] = n.shadowDarkness, l.shadowBias.value[e] = n.shadowBias, e++);
				t = r.uniformsList, r = 0;
				for(l = t.length; r < l; r++)
					if(e = t[r][0], !1 !== e.needsUpdate) switch(n = e.type, u = e.value, K = t[r][1], n) {
						case "1i":
							_t.uniform1i(K, u);
							break;
						case "1f":
							_t.uniform1f(K, u);
							break;
						case "2f":
							_t.uniform2f(K, u[0], u[1]);
							break;
						case "3f":
							_t.uniform3f(K, u[0], u[1], u[2]);
							break;
						case "4f":
							_t.uniform4f(K, u[0], u[1], u[2], u[3]);
							break;
						case "1iv":
							_t.uniform1iv(K, u);
							break;
						case "3iv":
							_t.uniform3iv(K, u);
							break;
						case "1fv":
							_t.uniform1fv(K, u);
							break;
						case "2fv":
							_t.uniform2fv(K, u);
							break;
						case "3fv":
							_t.uniform3fv(K, u);
							break;
						case "4fv":
							_t.uniform4fv(K, u);
							break;
						case "Matrix3fv":
							_t.uniformMatrix3fv(K, !1, u);
							break;
						case "Matrix4fv":
							_t.uniformMatrix4fv(K, !1, u);
							break;
						case "i":
							_t.uniform1i(K, u);
							break;
						case "f":
							_t.uniform1f(K, u);
							break;
						case "v2":
							_t.uniform2f(K, u.x, u.y);
							break;
						case "v3":
							_t.uniform3f(K, u.x, u.y, u.z);
							break;
						case "v4":
							_t.uniform4f(K, u.x, u.y, u.z, u.w);
							break;
						case "c":
							_t.uniform3f(K, u.r, u.g, u.b);
							break;
						case "iv1":
							_t.uniform1iv(K, u);
							break;
						case "iv":
							_t.uniform3iv(K, u);
							break;
						case "fv1":
							_t.uniform1fv(K, u);
							break;
						case "fv":
							_t.uniform3fv(K, u);
							break;
						case "v2v":
							void 0 === e._array && (e._array = new Float32Array(2 * u.length)), n = 0;
							for(o = u.length; n < o; n++) s = 2 * n, e._array[s] = u[n].x, e._array[s + 1] = u[n].y;
							_t.uniform2fv(K, e._array);
							break;
						case "v3v":
							void 0 === e._array && (e._array = new Float32Array(3 * u.length)), n = 0;
							for(o = u.length; n < o; n++) s = 3 * n, e._array[s] = u[n].x, e._array[s + 1] = u[n].y, e._array[s + 2] = u[n].z;
							_t.uniform3fv(K, e._array);
							break;
						case "v4v":
							void 0 === e._array && (e._array = new Float32Array(4 * u.length)), n = 0;
							for(o = u.length; n < o; n++) s = 4 * n, e._array[s] = u[n].x, e._array[s + 1] = u[n].y, e._array[s + 2] = u[n].z, e._array[s + 3] = u[n].w;
							_t.uniform4fv(K, e._array);
							break;
						case "m3":
							_t.uniformMatrix3fv(K, !1, u.elements);
							break;
						case "m3v":
							void 0 === e._array && (e._array = new Float32Array(9 * u.length)), n = 0;
							for(o = u.length; n < o; n++) u[n].flattenToArrayOffset(e._array, 9 * n);
							_t.uniformMatrix3fv(K, !1, e._array);
							break;
						case "m4":
							_t.uniformMatrix4fv(K, !1, u.elements);
							break;
						case "m4v":
							void 0 === e._array && (e._array = new Float32Array(16 * u.length)), n = 0;
							for(o = u.length; n < o; n++) u[n].flattenToArrayOffset(e._array, 16 * n);
							_t.uniformMatrix4fv(K, !1, e._array);
							break;
						case "t":
							s = u, u = C(), _t.uniform1i(K, u);
							if(!s) continue;
							if(s instanceof THREE.CubeTexture || s.image instanceof Array && 6 === s.image.length) {
								if(e = s, K = u, 6 === e.image.length)
									if(e.needsUpdate) {
										e.image.__webglTextureCube || (e.addEventListener("dispose", Gt), e.image.__webglTextureCube = _t.createTexture(), G.info.memory.textures++), _t.activeTexture(_t.TEXTURE0 + K), _t.bindTexture(_t.TEXTURE_CUBE_MAP, e.image.__webglTextureCube), _t.pixelStorei(_t.UNPACK_FLIP_Y_WEBGL, e.flipY), K = e instanceof THREE.CompressedTexture, u = [];
										for(n = 0; 6 > n; n++) G.autoScaleCubemaps && !K ? (o = u, s = n, h = e.image[n], g = qt, h.width <= g && h.height <= g || (y = Math.max(h.width, h.height), p = Math.floor(h.width * g / y), g = Math.floor(h.height * g / y), y = document.createElement("canvas"), y.width = p, y.height = g, y.getContext("2d").drawImage(h, 0, 0, h.width, h.height, 0, 0, p, g), h = y), o[s] = h) : u[n] = e.image[n];
										n = u[0], o = THREE.Math.isPowerOfTwo(n.width) && THREE.Math.isPowerOfTwo(n.height), s = B(e.format), h = B(e.type), _(_t.TEXTURE_CUBE_MAP, e, o);
										for(n = 0; 6 > n; n++)
											if(K)
												for(g = u[n].mipmaps, y = 0, b = g.length; y < b; y++) p = g[y], e.format !== THREE.RGBAFormat ? _t.compressedTexImage2D(_t.TEXTURE_CUBE_MAP_POSITIVE_X + n, y, s, p.width, p.height, 0, p.data) : _t.texImage2D(_t.TEXTURE_CUBE_MAP_POSITIVE_X + n, y, s, p.width, p.height, 0, s, h, p.data);
											else _t.texImage2D(_t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, s, s, h, u[n]);
										e.generateMipmaps && o && _t.generateMipmap(_t.TEXTURE_CUBE_MAP), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
									} else _t.activeTexture(_t.TEXTURE0 + K), _t.bindTexture(_t.TEXTURE_CUBE_MAP, e.image.__webglTextureCube)
							} else s instanceof THREE.WebGLRenderTargetCube ? (e = s, _t.activeTexture(_t.TEXTURE0 + u), _t.bindTexture(_t.TEXTURE_CUBE_MAP, e.__webglTexture)) : G.setTexture(s, u);
							break;
						case "tv":
							void 0 === e._array && (e._array = []), n = 0;
							for(o = e.value.length; n < o; n++) e._array[n] = C();
							_t.uniform1iv(K, e._array), n = 0;
							for(o = e.value.length; n < o; n++) s = e.value[n], u = e._array[n], s && G.setTexture(s, u);
							break;
						default:
							console.warn("THREE.WebGLRenderer: Unknown uniform type: " + n)
					}
			}
			return _t.uniformMatrix4fv(f.modelViewMatrix, !1, i._modelViewMatrix.elements), f.normalMatrix && _t.uniformMatrix3fv(f.normalMatrix, !1, i._normalMatrix.elements), null !== f.modelMatrix && _t.uniformMatrix4fv(f.modelMatrix, !1, i.matrixWorld.elements), a
		}

		function N(e, t) {
			e.ambientLightColor.needsUpdate = t, e.directionalLightColor.needsUpdate = t, e.directionalLightDirection.needsUpdate = t, e.pointLightColor.needsUpdate = t, e.pointLightPosition.needsUpdate = t, e.pointLightDistance.needsUpdate = t, e.spotLightColor.needsUpdate = t, e.spotLightPosition.needsUpdate = t, e.spotLightDistance.needsUpdate = t, e.spotLightDirection.needsUpdate = t, e.spotLightAngleCos.needsUpdate = t, e.spotLightExponent.needsUpdate = t, e.hemisphereLightSkyColor.needsUpdate = t, e.hemisphereLightGroundColor.needsUpdate = t, e.hemisphereLightDirection.needsUpdate = t
		}

		function C() {
			var e = it;
			return e >= Ft && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Ft), it += 1, e
		}

		function k(e, t) {
			e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e._normalMatrix.getNormalMatrix(e._modelViewMatrix)
		}

		function L(e, t, n, r) {
			e[t] = n.r * n.r * r, e[t + 1] = n.g * n.g * r, e[t + 2] = n.b * n.b * r
		}

		function A(e, t, n, r) {
			e[t] = n.r * r, e[t + 1] = n.g * r, e[t + 2] = n.b * r
		}

		function O(e) {
			e !== mt && (_t.lineWidth(e), mt = e)
		}

		function M(e, t, n) {
			pt !== e && (e ? _t.enable(_t.POLYGON_OFFSET_FILL) : _t.disable(_t.POLYGON_OFFSET_FILL), pt = e), !e || dt === t && vt === n || (_t.polygonOffset(t, n), dt = t, vt = n)
		}

		function _(e, t, n) {
			n ? (_t.texParameteri(e, _t.TEXTURE_WRAP_S, B(t.wrapS)), _t.texParameteri(e, _t.TEXTURE_WRAP_T, B(t.wrapT)), _t.texParameteri(e, _t.TEXTURE_MAG_FILTER, B(t.magFilter)), _t.texParameteri(e, _t.TEXTURE_MIN_FILTER, B(t.minFilter))) : (_t.texParameteri(e, _t.TEXTURE_WRAP_S, _t.CLAMP_TO_EDGE), _t.texParameteri(e, _t.TEXTURE_WRAP_T, _t.CLAMP_TO_EDGE), _t.texParameteri(e, _t.TEXTURE_MAG_FILTER, H(t.magFilter)), _t.texParameteri(e, _t.TEXTURE_MIN_FILTER, H(t.minFilter))), Ht && t.type !== THREE.FloatType && (1 < t.anisotropy || t.__oldAnisotropy) && (_t.texParameterf(e, Ht.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, Rt)), t.__oldAnisotropy = t.anisotropy)
		}

		function D(e, t) {
			_t.bindRenderbuffer(_t.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (_t.renderbufferStorage(_t.RENDERBUFFER, _t.DEPTH_COMPONENT16, t.width, t.height), _t.framebufferRenderbuffer(_t.FRAMEBUFFER, _t.DEPTH_ATTACHMENT, _t.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (_t.renderbufferStorage(_t.RENDERBUFFER, _t.DEPTH_STENCIL, t.width, t.height), _t.framebufferRenderbuffer(_t.FRAMEBUFFER, _t.DEPTH_STENCIL_ATTACHMENT, _t.RENDERBUFFER, e)) : _t.renderbufferStorage(_t.RENDERBUFFER, _t.RGBA4, t.width, t.height)
		}

		function P(e) {
			e instanceof THREE.WebGLRenderTargetCube ? (_t.bindTexture(_t.TEXTURE_CUBE_MAP, e.__webglTexture), _t.generateMipmap(_t.TEXTURE_CUBE_MAP), _t.bindTexture(_t.TEXTURE_CUBE_MAP, null)) : (_t.bindTexture(_t.TEXTURE_2D, e.__webglTexture), _t.generateMipmap(_t.TEXTURE_2D), _t.bindTexture(_t.TEXTURE_2D, null))
		}

		function H(e) {
			return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? _t.NEAREST : _t.LINEAR
		}

		function B(e) {
			if(e === THREE.RepeatWrapping) return _t.REPEAT;
			if(e === THREE.ClampToEdgeWrapping) return _t.CLAMP_TO_EDGE;
			if(e === THREE.MirroredRepeatWrapping) return _t.MIRRORED_REPEAT;
			if(e === THREE.NearestFilter) return _t.NEAREST;
			if(e === THREE.NearestMipMapNearestFilter) return _t.NEAREST_MIPMAP_NEAREST;
			if(e === THREE.NearestMipMapLinearFilter) return _t.NEAREST_MIPMAP_LINEAR;
			if(e === THREE.LinearFilter) return _t.LINEAR;
			if(e === THREE.LinearMipMapNearestFilter) return _t.LINEAR_MIPMAP_NEAREST;
			if(e === THREE.LinearMipMapLinearFilter) return _t.LINEAR_MIPMAP_LINEAR;
			if(e === THREE.UnsignedByteType) return _t.UNSIGNED_BYTE;
			if(e === THREE.UnsignedShort4444Type) return _t.UNSIGNED_SHORT_4_4_4_4;
			if(e === THREE.UnsignedShort5551Type) return _t.UNSIGNED_SHORT_5_5_5_1;
			if(e === THREE.UnsignedShort565Type) return _t.UNSIGNED_SHORT_5_6_5;
			if(e === THREE.ByteType) return _t.BYTE;
			if(e === THREE.ShortType) return _t.SHORT;
			if(e === THREE.UnsignedShortType) return _t.UNSIGNED_SHORT;
			if(e === THREE.IntType) return _t.INT;
			if(e === THREE.UnsignedIntType) return _t.UNSIGNED_INT;
			if(e === THREE.FloatType) return _t.FLOAT;
			if(e === THREE.AlphaFormat) return _t.ALPHA;
			if(e === THREE.RGBFormat) return _t.RGB;
			if(e === THREE.RGBAFormat) return _t.RGBA;
			if(e === THREE.LuminanceFormat) return _t.LUMINANCE;
			if(e === THREE.LuminanceAlphaFormat) return _t.LUMINANCE_ALPHA;
			if(e === THREE.AddEquation) return _t.FUNC_ADD;
			if(e === THREE.SubtractEquation) return _t.FUNC_SUBTRACT;
			if(e === THREE.ReverseSubtractEquation) return _t.FUNC_REVERSE_SUBTRACT;
			if(e === THREE.ZeroFactor) return _t.ZERO;
			if(e === THREE.OneFactor) return _t.ONE;
			if(e === THREE.SrcColorFactor) return _t.SRC_COLOR;
			if(e === THREE.OneMinusSrcColorFactor) return _t.ONE_MINUS_SRC_COLOR;
			if(e === THREE.SrcAlphaFactor) return _t.SRC_ALPHA;
			if(e === THREE.OneMinusSrcAlphaFactor) return _t.ONE_MINUS_SRC_ALPHA;
			if(e === THREE.DstAlphaFactor) return _t.DST_ALPHA;
			if(e === THREE.OneMinusDstAlphaFactor) return _t.ONE_MINUS_DST_ALPHA;
			if(e === THREE.DstColorFactor) return _t.DST_COLOR;
			if(e === THREE.OneMinusDstColorFactor) return _t.ONE_MINUS_DST_COLOR;
			if(e === THREE.SrcAlphaSaturateFactor) return _t.SRC_ALPHA_SATURATE;
			if(void 0 !== Bt) {
				if(e === THREE.RGB_S3TC_DXT1_Format) return Bt.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if(e === THREE.RGBA_S3TC_DXT1_Format) return Bt.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if(e === THREE.RGBA_S3TC_DXT3_Format) return Bt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if(e === THREE.RGBA_S3TC_DXT5_Format) return Bt.COMPRESSED_RGBA_S3TC_DXT5_EXT
			}
			return 0
		}
		console.log("THREE.WebGLRenderer", THREE.REVISION), e = e || {};
		var j = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
			F = void 0 !== e.context ? e.context : null,
			I = void 0 !== e.precision ? e.precision : "highp",
			q = void 0 !== e.alpha ? e.alpha : !1,
			R = void 0 !== e.depth ? e.depth : !0,
			U = void 0 !== e.stencil ? e.stencil : !0,
			z = void 0 !== e.antialias ? e.antialias : !1,
			W = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
			X = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
			V = void 0 !== e.logarithmicDepthBuffer ? e.logarithmicDepthBuffer : !1,
			$ = new THREE.Color(0),
			J = 0,
			K = [],
			Q = [];
		this.domElement = j, this.context = null, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, this.shadowMapAutoUpdate = !0, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapCascade = this.shadowMapDebug = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.renderPluginsPre = [], this.renderPluginsPost = [], this.info = {
			memory: {
				programs: 0,
				geometries: 0,
				textures: 0
			},
			render: {
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0
			}
		};
		var G = this,
			Y = [],
			Z = null,
			et = null,
			tt = -1,
			nt = null,
			rt = null,
			it = 0,
			st = -1,
			ot = -1,
			ut = -1,
			at = -1,
			ft = -1,
			lt = -1,
			ct = -1,
			ht = -1,
			pt = null,
			dt = null,
			vt = null,
			mt = null,
			gt = 0,
			yt = 0,
			bt = j.width,
			wt = j.height,
			Et = 0,
			St = 0,
			xt = new Uint8Array(16),
			Tt = new Uint8Array(16),
			Nt = new THREE.Frustum,
			Ct = new THREE.Matrix4,
			kt = new THREE.Matrix4,
			Lt = new THREE.Vector3,
			At = new THREE.Vector3,
			Ot = !0,
			Mt = {
				ambient: [0, 0, 0],
				directional: {
					length: 0,
					colors: [],
					positions: []
				},
				point: {
					length: 0,
					colors: [],
					positions: [],
					distances: []
				},
				spot: {
					length: 0,
					colors: [],
					positions: [],
					distances: [],
					directions: [],
					anglesCos: [],
					exponents: []
				},
				hemi: {
					length: 0,
					skyColors: [],
					groundColors: [],
					positions: []
				}
			},
			_t, Dt, Pt, Ht, Bt, jt;
		(function() {
			try {
				var e = {
					alpha: q,
					depth: R,
					stencil: U,
					antialias: z,
					premultipliedAlpha: W,
					preserveDrawingBuffer: X
				};
				_t = F || j.getContext("webgl", e) || j.getContext("experimental-webgl", e);
				if(null === _t) throw "Error creating WebGL context."
			} catch(t) {
				console.error(t)
			}
			Dt = _t.getExtension("OES_texture_float"), _t.getExtension("OES_texture_float_linear"), Pt = _t.getExtension("OES_standard_derivatives"), Ht = _t.getExtension("EXT_texture_filter_anisotropic") || _t.getExtension("MOZ_EXT_texture_filter_anisotropic") || _t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), Bt = _t.getExtension("WEBGL_compressed_texture_s3tc") || _t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || _t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"), jt = _t.getExtension("OES_element_index_uint"), null === Dt && console.log("THREE.WebGLRenderer: Float textures not supported."), null === Pt && console.log("THREE.WebGLRenderer: Standard derivatives not supported."), null === Ht && console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."), null === Bt && console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."), null === jt && console.log("THREE.WebGLRenderer: elementindex as unsigned integer not supported."), void 0 === _t.getShaderPrecisionFormat && (_t.getShaderPrecisionFormat = function() {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			}), V && _t.getExtension("EXT_frag_depth")
		})(), _t.clearColor(0, 0, 0, 1), _t.clearDepth(1), _t.clearStencil(0), _t.enable(_t.DEPTH_TEST), _t.depthFunc(_t.LEQUAL), _t.frontFace(_t.CCW), _t.cullFace(_t.BACK), _t.enable(_t.CULL_FACE), _t.enable(_t.BLEND), _t.blendEquation(_t.FUNC_ADD), _t.blendFunc(_t.SRC_ALPHA, _t.ONE_MINUS_SRC_ALPHA), _t.viewport(gt, yt, bt, wt), _t.clearColor($.r, $.g, $.b, J), this.context = _t;
		var Ft = _t.getParameter(_t.MAX_TEXTURE_IMAGE_UNITS),
			It = _t.getParameter(_t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		_t.getParameter(_t.MAX_TEXTURE_SIZE);
		var qt = _t.getParameter(_t.MAX_CUBE_MAP_TEXTURE_SIZE),
			Rt = Ht ? _t.getParameter(Ht.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
			Ut = 0 < It,
			zt = Ut && Dt;
		Bt && _t.getParameter(_t.COMPRESSED_TEXTURE_FORMATS);
		var Wt = _t.getShaderPrecisionFormat(_t.VERTEX_SHADER, _t.HIGH_FLOAT),
			Xt = _t.getShaderPrecisionFormat(_t.VERTEX_SHADER, _t.MEDIUM_FLOAT);
		_t.getShaderPrecisionFormat(_t.VERTEX_SHADER, _t.LOW_FLOAT);
		var Vt = _t.getShaderPrecisionFormat(_t.FRAGMENT_SHADER, _t.HIGH_FLOAT),
			$t = _t.getShaderPrecisionFormat(_t.FRAGMENT_SHADER, _t.MEDIUM_FLOAT);
		_t.getShaderPrecisionFormat(_t.FRAGMENT_SHADER, _t.LOW_FLOAT);
		var Jt = 0 < Wt.precision && 0 < Vt.precision,
			Kt = 0 < Xt.precision && 0 < $t.precision;
		"highp" !== I || Jt || (Kt ? (I = "mediump", console.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (I = "lowp", console.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), "mediump" !== I || Kt || (I = "lowp", console.warn("THREE.WebGLRenderer: mediump not supported, using lowp.")), this.getContext = function() {
			return _t
		}, this.supportsVertexTextures = function() {
			return Ut
		}, this.supportsFloatTextures = function() {
			return Dt
		}, this.supportsStandardDerivatives = function() {
			return Pt
		}, this.supportsCompressedTextureS3TC = function() {
			return Bt
		}, this.getMaxAnisotropy = function() {
			return Rt
		}, this.getPrecision = function() {
			return I
		}, this.setSize = function(e, t, n) {
			j.width = e * this.devicePixelRatio, j.height = t * this.devicePixelRatio, !1 !== n && (j.style.width = e + "px", j.style.height = t + "px"), this.setViewport(0, 0, e, t)
		}, this.setViewport = function(e, t, n, r) {
			gt = e * this.devicePixelRatio, yt = t * this.devicePixelRatio, bt = n * this.devicePixelRatio, wt = r * this.devicePixelRatio, _t.viewport(gt, yt, bt, wt)
		}, this.setScissor = function(e, t, n, r) {
			_t.scissor(e * this.devicePixelRatio, t * this.devicePixelRatio, n * this.devicePixelRatio, r * this.devicePixelRatio)
		}, this.enableScissorTest = function(e) {
			e ? _t.enable(_t.SCISSOR_TEST) : _t.disable(_t.SCISSOR_TEST)
		}, this.setClearColor = function(e, t) {
			$.set(e), J = void 0 !== t ? t : 1, _t.clearColor($.r, $.g, $.b, J)
		}, this.setClearColorHex = function(e, t) {
			console.warn("THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
		}, this.getClearColor = function() {
			return $
		}, this.getClearAlpha = function() {
			return J
		}, this.clear = function(e, t, n) {
			var r = 0;
			if(void 0 === e || e) r |= _t.COLOR_BUFFER_BIT;
			if(void 0 === t || t) r |= _t.DEPTH_BUFFER_BIT;
			if(void 0 === n || n) r |= _t.STENCIL_BUFFER_BIT;
			_t.clear(r)
		}, this.clearColor = function() {
			_t.clear(_t.COLOR_BUFFER_BIT)
		}, this.clearDepth = function() {
			_t.clear(_t.DEPTH_BUFFER_BIT)
		}, this.clearStencil = function() {
			_t.clear(_t.STENCIL_BUFFER_BIT)
		}, this.clearTarget = function(e, t, n, r) {
			this.setRenderTarget(e), this.clear(t, n, r)
		}, this.addPostPlugin = function(e) {
			e.init(this), this.renderPluginsPost.push(e)
		}, this.addPrePlugin = function(e) {
			e.init(this), this.renderPluginsPre.push(e)
		}, this.updateShadowMap = function(e, t) {
			Z = null, tt = nt = ht = ct = ut = -1, Ot = !0, ot = st = -1, nn(e), this.shadowMapPlugin.update(e, t)
		};
		var Qt = function(e) {
				e = e.target, e.removeEventListener("dispose", Qt), e.__webglInit = void 0;
				if(e instanceof THREE.BufferGeometry) {
					e = e.attributes;
					for(var t in e) void 0 !== e[t].buffer && _t.deleteBuffer(e[t].buffer);
					G.info.memory.geometries--
				} else if(void 0 !== e.geometryGroups) {
					t = 0;
					for(var n = e.geometryGroupsList.length; t < n; t++) {
						var r = e.geometryGroupsList[t];
						if(void 0 !== r.numMorphTargets)
							for(var i = 0, s = r.numMorphTargets; i < s; i++) _t.deleteBuffer(r.__webglMorphTargetsBuffers[i]);
						if(void 0 !== r.numMorphNormals)
							for(i = 0, s = r.numMorphNormals; i < s; i++) _t.deleteBuffer(r.__webglMorphNormalsBuffers[i]);
						en(r)
					}
				} else en(e)
			},
			Gt = function(e) {
				e = e.target, e.removeEventListener("dispose", Gt), e.image && e.image.__webglTextureCube ? _t.deleteTexture(e.image.__webglTextureCube) : e.__webglInit && (e.__webglInit = !1, _t.deleteTexture(e.__webglTexture)), G.info.memory.textures--
			},
			Yt = function(e) {
				e = e.target, e.removeEventListener("dispose", Yt);
				if(e && e.__webglTexture)
					if(_t.deleteTexture(e.__webglTexture), e instanceof THREE.WebGLRenderTargetCube)
						for(var t = 0; 6 > t; t++) _t.deleteFramebuffer(e.__webglFramebuffer[t]), _t.deleteRenderbuffer(e.__webglRenderbuffer[t]);
					else _t.deleteFramebuffer(e.__webglFramebuffer), _t.deleteRenderbuffer(e.__webglRenderbuffer);
				G.info.memory.textures--
			},
			Zt = function(e) {
				e = e.target, e.removeEventListener("dispose", Zt), tn(e)
			},
			en = function(e) {
				void 0 !== e.__webglVertexBuffer && _t.deleteBuffer(e.__webglVertexBuffer), void 0 !== e.__webglNormalBuffer && _t.deleteBuffer(e.__webglNormalBuffer), void 0 !== e.__webglTangentBuffer && _t.deleteBuffer(e.__webglTangentBuffer), void 0 !== e.__webglColorBuffer && _t.deleteBuffer(e.__webglColorBuffer), void 0 !== e.__webglUVBuffer && _t.deleteBuffer(e.__webglUVBuffer), void 0 !== e.__webglUV2Buffer && _t.deleteBuffer(e.__webglUV2Buffer), void 0 !== e.__webglSkinIndicesBuffer && _t.deleteBuffer(e.__webglSkinIndicesBuffer), void 0 !== e.__webglSkinWeightsBuffer && _t.deleteBuffer(e.__webglSkinWeightsBuffer), void 0 !== e.__webglFaceBuffer && _t.deleteBuffer(e.__webglFaceBuffer), void 0 !== e.__webglLineBuffer && _t.deleteBuffer(e.__webglLineBuffer), void 0 !== e.__webglLineDistanceBuffer && _t.deleteBuffer(e.__webglLineDistanceBuffer);
				if(void 0 !== e.__webglCustomAttributesList)
					for(var t in e.__webglCustomAttributesList) _t.deleteBuffer(e.__webglCustomAttributesList[t].buffer);
				G.info.memory.geometries--
			},
			tn = function(e) {
				var t = e.program.program;
				if(void 0 !== t) {
					e.program = void 0;
					var n, r, i = !1;
					e = 0;
					for(n = Y.length; e < n; e++)
						if(r = Y[e], r.program === t) {
							r.usedTimes--, 0 === r.usedTimes && (i = !0);
							break
						}
					if(!0 === i) {
						i = [], e = 0;
						for(n = Y.length; e < n; e++) r = Y[e], r.program !== t && i.push(r);
						Y = i, _t.deleteProgram(t), G.info.memory.programs--
					}
				}
			};
		this.renderBufferImmediate = function(e, t, n) {
			a(), e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = _t.createBuffer()), e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = _t.createBuffer()), e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = _t.createBuffer()), e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = _t.createBuffer()), e.hasPositions && (_t.bindBuffer(_t.ARRAY_BUFFER, e.__webglVertexBuffer), _t.bufferData(_t.ARRAY_BUFFER, e.positionArray, _t.DYNAMIC_DRAW), f(t.attributes.position), _t.vertexAttribPointer(t.attributes.position, 3, _t.FLOAT, !1, 0, 0));
			if(e.hasNormals) {
				_t.bindBuffer(_t.ARRAY_BUFFER, e.__webglNormalBuffer);
				if(n.shading === THREE.FlatShading) {
					var r, i, s, o, u, c, h, p, d, v, m, g = 3 * e.count;
					for(m = 0; m < g; m += 9) v = e.normalArray, r = v[m], i = v[m + 1], s = v[m + 2], o = v[m + 3], c = v[m + 4], p = v[m + 5], u = v[m + 6], h = v[m + 7], d = v[m + 8], r = (r + o + u) / 3, i = (i + c + h) / 3, s = (s + p + d) / 3, v[m] = r, v[m + 1] = i, v[m + 2] = s, v[m + 3] = r, v[m + 4] = i, v[m + 5] = s, v[m + 6] = r, v[m + 7] = i, v[m + 8] = s
				}
				_t.bufferData(_t.ARRAY_BUFFER, e.normalArray, _t.DYNAMIC_DRAW), f(t.attributes.normal), _t.vertexAttribPointer(t.attributes.normal, 3, _t.FLOAT, !1, 0, 0)
			}
			e.hasUvs && n.map && (_t.bindBuffer(_t.ARRAY_BUFFER, e.__webglUvBuffer), _t.bufferData(_t.ARRAY_BUFFER, e.uvArray, _t.DYNAMIC_DRAW), f(t.attributes.uv), _t.vertexAttribPointer(t.attributes.uv, 2, _t.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== THREE.NoColors && (_t.bindBuffer(_t.ARRAY_BUFFER, e.__webglColorBuffer), _t.bufferData(_t.ARRAY_BUFFER, e.colorArray, _t.DYNAMIC_DRAW), f(t.attributes.color), _t.vertexAttribPointer(t.attributes.color, 3, _t.FLOAT, !1, 0, 0)), l(), _t.drawArrays(_t.TRIANGLES, 0, e.count), e.count = 0
		}, this.renderBufferDirect = function(e, t, n, r, i, s) {
			if(!1 !== r.visible) {
				var o = T(e, t, n, r, s);
				e = o.attributes, t = i.attributes, n = !1, o = 16777215 * i.id + 2 * o.id + (r.wireframe ? 1 : 0), o !== nt && (nt = o, n = !0), n && a();
				if(s instanceof THREE.Mesh)
					if(o = t.index) {
						var f, l;
						o.array instanceof Uint32Array ? (f = _t.UNSIGNED_INT, l = 4) : (f = _t.UNSIGNED_SHORT, l = 2), i = i.offsets;
						if(0 === i.length) n && (u(r, e, t, 0), _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, o.buffer)), _t.drawElements(_t.TRIANGLES, o.array.length, f, 0), G.info.render.calls++, G.info.render.vertices += o.array.length, G.info.render.faces += o.array.length / 3;
						else {
							n = !0;
							for(var c = 0, h = i.length; c < h; c++) {
								var p = i[c].index;
								n && (u(r, e, t, p), _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, o.buffer)), _t.drawElements(_t.TRIANGLES, i[c].count, f, i[c].start * l), G.info.render.calls++, G.info.render.vertices += i[c].count, G.info.render.faces += i[c].count / 3
							}
						}
					} else n && u(r, e, t, 0), r = i.attributes.position, _t.drawArrays(_t.TRIANGLES, 0, r.array.length / 3), G.info.render.calls++, G.info.render.vertices += r.array.length / 3, G.info.render.faces += r.array.length / 9;
				else if(s instanceof THREE.PointCloud) n && u(r, e, t, 0), r = t.position, _t.drawArrays(_t.POINTS, 0, r.array.length / 3), G.info.render.calls++, G.info.render.points += r.array.length / 3;
				else if(s instanceof THREE.Line)
					if(s = s.type === THREE.LineStrip ? _t.LINE_STRIP : _t.LINES, O(r.linewidth), o = t.index)
						if(o.array instanceof Uint32Array ? (f = _t.UNSIGNED_INT, l = 4) : (f = _t.UNSIGNED_SHORT, l = 2), i = i.offsets, 0 === i.length) n && (u(r, e, t, 0), _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, o.buffer)), _t.drawElements(s, o.array.length, f, 0), G.info.render.calls++, G.info.render.vertices += o.array.length;
						else
							for(1 < i.length && (n = !0), c = 0, h = i.length; c < h; c++) p = i[c].index, n && (u(r, e, t, p), _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, o.buffer)), _t.drawElements(s, i[c].count, f, i[c].start * l), G.info.render.calls++, G.info.render.vertices += i[c].count;
				else n && u(r, e, t, 0), r = t.position, _t.drawArrays(s, 0, r.array.length / 3), G.info.render.calls++, G.info.render.points += r.array.length / 3
			}
		}, this.renderBuffer = function(e, t, n, r, i, s) {
			if(!1 !== r.visible) {
				var o, u;
				n = T(e, t, n, r, s), t = n.attributes, e = !1, n = 16777215 * i.id + 2 * n.id + (r.wireframe ? 1 : 0), n !== nt && (nt = n, e = !0), e && a();
				if(!r.morphTargets && 0 <= t.position) e && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglVertexBuffer), f(t.position), _t.vertexAttribPointer(t.position, 3, _t.FLOAT, !1, 0, 0));
				else if(s.morphTargetBase) {
					n = r.program.attributes, -1 !== s.morphTargetBase && 0 <= n.position ? (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[s.morphTargetBase]), f(n.position), _t.vertexAttribPointer(n.position, 3, _t.FLOAT, !1, 0, 0)) : 0 <= n.position && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglVertexBuffer), f(n.position), _t.vertexAttribPointer(n.position, 3, _t.FLOAT, !1, 0, 0));
					if(s.morphTargetForcedOrder.length) {
						var c = 0;
						u = s.morphTargetForcedOrder;
						for(o = s.morphTargetInfluences; c < r.numSupportedMorphTargets && c < u.length;) 0 <= n["morphTarget" + c] && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[u[c]]), f(n["morphTarget" + c]), _t.vertexAttribPointer(n["morphTarget" + c], 3, _t.FLOAT, !1, 0, 0)), 0 <= n["morphNormal" + c] && r.morphNormals && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglMorphNormalsBuffers[u[c]]), f(n["morphNormal" + c]), _t.vertexAttribPointer(n["morphNormal" + c], 3, _t.FLOAT, !1, 0, 0)), s.__webglMorphTargetInfluences[c] = o[u[c]], c++
					} else {
						u = [], o = s.morphTargetInfluences;
						var h, d = o.length;
						for(h = 0; h < d; h++) c = o[h], 0 < c && u.push([c, h]);
						u.length > r.numSupportedMorphTargets ? (u.sort(p), u.length = r.numSupportedMorphTargets) : u.length > r.numSupportedMorphNormals ? u.sort(p) : 0 === u.length && u.push([0, 0]);
						for(c = 0; c < r.numSupportedMorphTargets;) u[c] ? (h = u[c][1], 0 <= n["morphTarget" + c] && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[h]), f(n["morphTarget" + c]), _t.vertexAttribPointer(n["morphTarget" + c], 3, _t.FLOAT, !1, 0, 0)), 0 <= n["morphNormal" + c] && r.morphNormals && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglMorphNormalsBuffers[h]), f(n["morphNormal" + c]), _t.vertexAttribPointer(n["morphNormal" + c], 3, _t.FLOAT, !1, 0, 0)), s.__webglMorphTargetInfluences[c] = o[h]) : s.__webglMorphTargetInfluences[c] = 0, c++
					}
					null !== r.program.uniforms.morphTargetInfluences && _t.uniform1fv(r.program.uniforms.morphTargetInfluences, s.__webglMorphTargetInfluences)
				}
				if(e) {
					if(i.__webglCustomAttributesList)
						for(o = 0, u = i.__webglCustomAttributesList.length; o < u; o++) n = i.__webglCustomAttributesList[o], 0 <= t[n.buffer.belongsToAttribute] && (_t.bindBuffer(_t.ARRAY_BUFFER, n.buffer), f(t[n.buffer.belongsToAttribute]), _t.vertexAttribPointer(t[n.buffer.belongsToAttribute], n.size, _t.FLOAT, !1, 0, 0));
					0 <= t.color && (0 < s.geometry.colors.length || 0 < s.geometry.faces.length ? (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglColorBuffer), f(t.color), _t.vertexAttribPointer(t.color, 3, _t.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && _t.vertexAttrib3fv(t.color, r.defaultAttributeValues.color)), 0 <= t.normal && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglNormalBuffer), f(t.normal), _t.vertexAttribPointer(t.normal, 3, _t.FLOAT, !1, 0, 0)), 0 <= t.tangent && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglTangentBuffer), f(t.tangent), _t.vertexAttribPointer(t.tangent, 4, _t.FLOAT, !1, 0, 0)), 0 <= t.uv && (s.geometry.faceVertexUvs[0] ? (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglUVBuffer), f(t.uv), _t.vertexAttribPointer(t.uv, 2, _t.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && _t.vertexAttrib2fv(t.uv, r.defaultAttributeValues.uv)), 0 <= t.uv2 && (s.geometry.faceVertexUvs[1] ? (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglUV2Buffer), f(t.uv2), _t.vertexAttribPointer(t.uv2, 2, _t.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && _t.vertexAttrib2fv(t.uv2, r.defaultAttributeValues.uv2)), r.skinning && 0 <= t.skinIndex && 0 <= t.skinWeight && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglSkinIndicesBuffer), f(t.skinIndex), _t.vertexAttribPointer(t.skinIndex, 4, _t.FLOAT, !1, 0, 0), _t.bindBuffer(_t.ARRAY_BUFFER, i.__webglSkinWeightsBuffer), f(t.skinWeight), _t.vertexAttribPointer(t.skinWeight, 4, _t.FLOAT, !1, 0, 0)), 0 <= t.lineDistance && (_t.bindBuffer(_t.ARRAY_BUFFER, i.__webglLineDistanceBuffer), f(t.lineDistance), _t.vertexAttribPointer(t.lineDistance, 1, _t.FLOAT, !1, 0, 0))
				}
				l(), s instanceof THREE.Mesh ? (s = i.__typeArray === Uint32Array ? _t.UNSIGNED_INT : _t.UNSIGNED_SHORT, r.wireframe ? (O(r.wireframeLinewidth), e && _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer), _t.drawElements(_t.LINES, i.__webglLineCount, s, 0)) : (e && _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer), _t.drawElements(_t.TRIANGLES, i.__webglFaceCount, s, 0)), G.info.render.calls++, G.info.render.vertices += i.__webglFaceCount, G.info.render.faces += i.__webglFaceCount / 3) : s instanceof THREE.Line ? (s = s.type === THREE.LineStrip ? _t.LINE_STRIP : _t.LINES, O(r.linewidth), _t.drawArrays(s, 0, i.__webglLineCount), G.info.render.calls++) : s instanceof THREE.PointCloud && (_t.drawArrays(_t.POINTS, 0, i.__webglParticleCount), G.info.render.calls++, G.info.render.points += i.__webglParticleCount)
			}
		}, this.render = function(e, t, n, r) {
			function i(e) {
				e instanceof THREE.SkinnedMesh && e.skeleton.update();
				for(var t = 0, n = e.children.length; t < n; t++) i(e.children[t])
			}
			if(0 == t instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
			else {
				var s, o, u, a, f = e.__lights,
					l = e.fog;
				tt = -1, rt = null, Ot = !0, !0 === e.autoUpdate && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), i(e), t.matrixWorldInverse.getInverse(t.matrixWorld), Ct.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Nt.setFromMatrix(Ct), nn(e), K.length = 0, Q.length = 0, d(e, e, t), !0 === G.sortObjects && (K.sort(c), Q.sort(h)), v(this.renderPluginsPre, e, t), G.info.render.calls = 0, G.info.render.vertices = 0, G.info.render.faces = 0, G.info.render.points = 0, this.setRenderTarget(n), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), a = e.__webglObjectsImmediate, r = 0;
				for(s = a.length; r < s; r++) o = a[r], u = o.object, u.visible && (k(u, t), y(o));
				e.overrideMaterial ? (r = e.overrideMaterial, this.setBlending(r.blending, r.blendEquation, r.blendSrc, r.blendDst), this.setDepthTest(r.depthTest), this.setDepthWrite(r.depthWrite), M(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits), m(K, t, f, l, !0, r), m(Q, t, f, l, !0, r), g(e.__webglObjectsImmediate, "", t, f, l, !1, r)) : (r = null, this.setBlending(THREE.NoBlending), m(K, t, f, l, !1, r), g(e.__webglObjectsImmediate, "opaque", t, f, l, !1, r), m(Q, t, f, l, !0, r), g(e.__webglObjectsImmediate, "transparent", t, f, l, !0, r)), v(this.renderPluginsPost, e, t), n && n.generateMipmaps && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter && P(n), this.setDepthTest(!0), this.setDepthWrite(!0)
			}
		}, this.renderImmediateObject = function(e, t, n, r, i) {
			var s = T(e, t, n, r, i);
			nt = -1, G.setMaterialFaces(r), i.immediateRenderCallback ? i.immediateRenderCallback(s, _t, Nt) : i.render(function(e) {
				G.renderBufferImmediate(e, s, r)
			})
		};
		var nn = function(e) {
			e.__webglObjects || (e.__webglObjects = {}, e.__webglObjectsImmediate = []);
			for(; e.__objectsAdded.length;) {
				var n = e.__objectsAdded[0],
					r = e,
					i = void 0,
					s = void 0;
				void 0 === n.__webglInit && (n.__webglInit = !0, n._modelViewMatrix = new THREE.Matrix4, n._normalMatrix = new THREE.Matrix3), i = n.geometry;
				if(void 0 !== i && void 0 === i.__webglInit)
					if(i.__webglInit = !0, i.addEventListener("dispose", Qt), i instanceof THREE.BufferGeometry) o(i);
					else if(n instanceof THREE.Mesh) void 0 !== n.__webglActive && x(n, r), b(r, n, i);
				else if(n instanceof THREE.Line) {
					if(!i.__webglVertexBuffer) {
						s = i, s.__webglVertexBuffer = _t.createBuffer(), s.__webglColorBuffer = _t.createBuffer(), s.__webglLineDistanceBuffer = _t.createBuffer(), G.info.memory.geometries++;
						var s = i,
							u = n,
							a = s.vertices.length;
						s.__vertexArray = new Float32Array(3 * a), s.__colorArray = new Float32Array(3 * a), s.__lineDistanceArray = new Float32Array(1 * a), s.__webglLineCount = a, t(s, u), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0, i.lineDistancesNeedUpdate = !0
					}
				} else n instanceof THREE.PointCloud && !i.__webglVertexBuffer && (s = i, s.__webglVertexBuffer = _t.createBuffer(), s.__webglColorBuffer = _t.createBuffer(), G.info.memory.geometries++, s = i, u = n, a = s.vertices.length, s.__vertexArray = new Float32Array(3 * a), s.__colorArray = new Float32Array(3 * a), s.__sortArray = [], s.__webglParticleCount = a, t(s, u), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0);
				if(void 0 === n.__webglActive) {
					if(n instanceof THREE.Mesh) {
						if(i = n.geometry, i instanceof THREE.BufferGeometry) w(r.__webglObjects, i, n);
						else if(i instanceof THREE.Geometry)
							for(u = 0, a = i.geometryGroupsList.length; u < a; u++) s = i.geometryGroupsList[u], w(r.__webglObjects, s, n)
					} else n instanceof THREE.Line || n instanceof THREE.PointCloud ? (i = n.geometry, w(r.__webglObjects, i, n)) : (n instanceof THREE.ImmediateRenderObject || n.immediateRenderCallback) && r.__webglObjectsImmediate.push({
						id: null,
						object: n,
						opaque: null,
						transparent: null,
						z: 0
					});
					n.__webglActive = !0
				}
				e.__objectsAdded.splice(0, 1)
			}
			for(; e.__objectsRemoved.length;) x(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1)
		};
		this.initMaterial = function(e, t, n, r) {
			var i, s, o, u;
			e.addEventListener("dispose", Zt);
			var a, f, l, c;
			e instanceof THREE.MeshDepthMaterial ? c = "depth" : e instanceof THREE.MeshNormalMaterial ? c = "normal" : e instanceof THREE.MeshBasicMaterial ? c = "basic" : e instanceof THREE.MeshLambertMaterial ? c = "lambert" : e instanceof THREE.MeshPhongMaterial ? c = "phong" : e instanceof THREE.LineBasicMaterial ? c = "basic" : e instanceof THREE.LineDashedMaterial ? c = "dashed" : e instanceof THREE.PointCloudMaterial && (c = "particle_basic"), c ? (i = THREE.ShaderLib[c], e.__webglShader = {
				uniforms: THREE.UniformsUtils.clone(i.uniforms),
				vertexShader: i.vertexShader,
				fragmentShader: i.fragmentShader
			}) : e.__webglShader = {
				uniforms: e.uniforms,
				vertexShader: e.vertexShader,
				fragmentShader: e.fragmentShader
			}, l = u = o = s = i = 0;
			for(var h = t.length; l < h; l++) {
				var p = t[l];
				p.onlyShadow || !1 === p.visible || (p instanceof THREE.DirectionalLight && i++, p instanceof THREE.PointLight && s++, p instanceof THREE.SpotLight && o++, p instanceof THREE.HemisphereLight && u++)
			}
			h = l = 0;
			for(p = t.length; h < p; h++) {
				var d = t[h];
				d.castShadow && (d instanceof THREE.SpotLight && l++, d instanceof THREE.DirectionalLight && !d.shadowCascade && l++)
			}
			t = l, zt && r && r.skeleton && r.skeleton.useVertexTexture ? l = 1024 : (l = _t.getParameter(_t.MAX_VERTEX_UNIFORM_VECTORS), l = Math.floor((l - 20) / 4), void 0 !== r && r instanceof THREE.SkinnedMesh && (l = Math.min(r.skeleton.bones.length, l), l < r.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + r.skeleton.bones.length + ", this GPU supports just " + l + " (try OpenGL instead of ANGLE)"))), n = {
				precision: I,
				supportsVertexTextures: Ut,
				map: !!e.map,
				envMap: !!e.envMap,
				lightMap: !!e.lightMap,
				bumpMap: !!e.bumpMap,
				normalMap: !!e.normalMap,
				specularMap: !!e.specularMap,
				alphaMap: !!e.alphaMap,
				vertexColors: e.vertexColors,
				fog: n,
				useFog: e.fog,
				fogExp: n instanceof THREE.FogExp2,
				sizeAttenuation: e.sizeAttenuation,
				logarithmicDepthBuffer: V,
				skinning: e.skinning,
				maxBones: l,
				useVertexTexture: zt && r && r.skeleton && r.skeleton.useVertexTexture,
				morphTargets: e.morphTargets,
				morphNormals: e.morphNormals,
				maxMorphTargets: this.maxMorphTargets,
				maxMorphNormals: this.maxMorphNormals,
				maxDirLights: i,
				maxPointLights: s,
				maxSpotLights: o,
				maxHemiLights: u,
				maxShadows: t,
				shadowMapEnabled: this.shadowMapEnabled && r.receiveShadow && 0 < t,
				shadowMapType: this.shadowMapType,
				shadowMapDebug: this.shadowMapDebug,
				shadowMapCascade: this.shadowMapCascade,
				alphaTest: e.alphaTest,
				metal: e.metal,
				wrapAround: e.wrapAround,
				doubleSided: e.side === THREE.DoubleSide,
				flipSided: e.side === THREE.BackSide
			}, r = [], c ? r.push(c) : (r.push(e.fragmentShader), r.push(e.vertexShader));
			for(var v in e.defines) r.push(v), r.push(e.defines[v]);
			for(f in n) r.push(f), r.push(n[f]);
			c = r.join();
			var m;
			f = 0;
			for(v = Y.length; f < v; f++)
				if(r = Y[f], r.code === c) {
					m = r, m.usedTimes++;
					break
				}
			void 0 === m && (m = new THREE.WebGLProgram(this, c, e, n), Y.push(m), G.info.memory.programs = Y.length), e.program = m, m = e.program.attributes;
			if(e.morphTargets)
				for(e.numSupportedMorphTargets = 0, v = "morphTarget", f = 0; f < this.maxMorphTargets; f++) c = v + f, 0 <= m[c] && e.numSupportedMorphTargets++;
			if(e.morphNormals)
				for(e.numSupportedMorphNormals = 0, v = "morphNormal", f = 0; f < this.maxMorphNormals; f++) c = v + f, 0 <= m[c] && e.numSupportedMorphNormals++;
			e.uniformsList = [];
			for(a in e.__webglShader.uniforms)(f = e.program.uniforms[a]) && e.uniformsList.push([e.__webglShader.uniforms[a], f])
		}, this.setFaceCulling = function(e, t) {
			e === THREE.CullFaceNone ? _t.disable(_t.CULL_FACE) : (t === THREE.FrontFaceDirectionCW ? _t.frontFace(_t.CW) : _t.frontFace(_t.CCW), e === THREE.CullFaceBack ? _t.cullFace(_t.BACK) : e === THREE.CullFaceFront ? _t.cullFace(_t.FRONT) : _t.cullFace(_t.FRONT_AND_BACK), _t.enable(_t.CULL_FACE))
		}, this.setMaterialFaces = function(e) {
			var t = e.side === THREE.DoubleSide;
			e = e.side === THREE.BackSide, st !== t && (t ? _t.disable(_t.CULL_FACE) : _t.enable(_t.CULL_FACE), st = t), ot !== e && (e ? _t.frontFace(_t.CW) : _t.frontFace(_t.CCW), ot = e)
		}, this.setDepthTest = function(e) {
			ct !== e && (e ? _t.enable(_t.DEPTH_TEST) : _t.disable(_t.DEPTH_TEST), ct = e)
		}, this.setDepthWrite = function(e) {
			ht !== e && (_t.depthMask(e), ht = e)
		}, this.setBlending = function(e, t, n, r) {
			e !== ut && (e === THREE.NoBlending ? _t.disable(_t.BLEND) : e === THREE.AdditiveBlending ? (_t.enable(_t.BLEND), _t.blendEquation(_t.FUNC_ADD), _t.blendFunc(_t.SRC_ALPHA, _t.ONE)) : e === THREE.SubtractiveBlending ? (_t.enable(_t.BLEND), _t.blendEquation(_t.FUNC_ADD), _t.blendFunc(_t.ZERO, _t.ONE_MINUS_SRC_COLOR)) : e === THREE.MultiplyBlending ? (_t.enable(_t.BLEND), _t.blendEquation(_t.FUNC_ADD), _t.blendFunc(_t.ZERO, _t.SRC_COLOR)) : e === THREE.CustomBlending ? _t.enable(_t.BLEND) : (_t.enable(_t.BLEND), _t.blendEquationSeparate(_t.FUNC_ADD, _t.FUNC_ADD), _t.blendFuncSeparate(_t.SRC_ALPHA, _t.ONE_MINUS_SRC_ALPHA, _t.ONE, _t.ONE_MINUS_SRC_ALPHA)), ut = e);
			if(e === THREE.CustomBlending) {
				if(t !== at && (_t.blendEquation(B(t)), at = t), n !== ft || r !== lt) _t.blendFunc(B(n), B(r)), ft = n, lt = r
			} else lt = ft = at = null
		}, this.setTexture = function(e, t) {
			if(e.needsUpdate) {
				e.__webglInit || (e.__webglInit = !0, e.addEventListener("dispose", Gt), e.__webglTexture = _t.createTexture(), G.info.memory.textures++), _t.activeTexture(_t.TEXTURE0 + t), _t.bindTexture(_t.TEXTURE_2D, e.__webglTexture), _t.pixelStorei(_t.UNPACK_FLIP_Y_WEBGL, e.flipY), _t.pixelStorei(_t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), _t.pixelStorei(_t.UNPACK_ALIGNMENT, e.unpackAlignment);
				var n = e.image,
					r = THREE.Math.isPowerOfTwo(n.width) && THREE.Math.isPowerOfTwo(n.height),
					i = B(e.format),
					s = B(e.type);
				_(_t.TEXTURE_2D, e, r);
				var o = e.mipmaps;
				if(e instanceof THREE.DataTexture)
					if(0 < o.length && r) {
						for(var u = 0, a = o.length; u < a; u++) n = o[u], _t.texImage2D(_t.TEXTURE_2D, u, i, n.width, n.height, 0, i, s, n.data);
						e.generateMipmaps = !1
					} else _t.texImage2D(_t.TEXTURE_2D, 0, i, n.width, n.height, 0, i, s, n.data);
				else if(e instanceof THREE.CompressedTexture)
					for(u = 0, a = o.length; u < a; u++) n = o[u], e.format !== THREE.RGBAFormat ? _t.compressedTexImage2D(_t.TEXTURE_2D, u, i, n.width, n.height, 0, n.data) : _t.texImage2D(_t.TEXTURE_2D, u, i, n.width, n.height, 0, i, s, n.data);
				else if(0 < o.length && r) {
					u = 0;
					for(a = o.length; u < a; u++) n = o[u], _t.texImage2D(_t.TEXTURE_2D, u, i, i, s, n);
					e.generateMipmaps = !1
				} else _t.texImage2D(_t.TEXTURE_2D, 0, i, i, s, e.image);
				e.generateMipmaps && r && _t.generateMipmap(_t.TEXTURE_2D), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
			} else _t.activeTexture(_t.TEXTURE0 + t), _t.bindTexture(_t.TEXTURE_2D, e.__webglTexture)
		}, this.setRenderTarget = function(e) {
			var t = e instanceof THREE.WebGLRenderTargetCube;
			if(e && !e.__webglFramebuffer) {
				void 0 === e.depthBuffer && (e.depthBuffer = !0), void 0 === e.stencilBuffer && (e.stencilBuffer = !0), e.addEventListener("dispose", Yt), e.__webglTexture = _t.createTexture(), G.info.memory.textures++;
				var n = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height),
					r = B(e.format),
					i = B(e.type);
				if(t) {
					e.__webglFramebuffer = [], e.__webglRenderbuffer = [], _t.bindTexture(_t.TEXTURE_CUBE_MAP, e.__webglTexture), _(_t.TEXTURE_CUBE_MAP, e, n);
					for(var s = 0; 6 > s; s++) {
						e.__webglFramebuffer[s] = _t.createFramebuffer(), e.__webglRenderbuffer[s] = _t.createRenderbuffer(), _t.texImage2D(_t.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, r, e.width, e.height, 0, r, i, null);
						var o = e,
							u = _t.TEXTURE_CUBE_MAP_POSITIVE_X + s;
						_t.bindFramebuffer(_t.FRAMEBUFFER, e.__webglFramebuffer[s]), _t.framebufferTexture2D(_t.FRAMEBUFFER, _t.COLOR_ATTACHMENT0, u, o.__webglTexture, 0), D(e.__webglRenderbuffer[s], e)
					}
					n && _t.generateMipmap(_t.TEXTURE_CUBE_MAP)
				} else e.__webglFramebuffer = _t.createFramebuffer(), e.__webglRenderbuffer = e.shareDepthFrom ? e.shareDepthFrom.__webglRenderbuffer : _t.createRenderbuffer(), _t.bindTexture(_t.TEXTURE_2D, e.__webglTexture), _(_t.TEXTURE_2D, e, n), _t.texImage2D(_t.TEXTURE_2D, 0, r, e.width, e.height, 0, r, i, null), r = _t.TEXTURE_2D, _t.bindFramebuffer(_t.FRAMEBUFFER, e.__webglFramebuffer), _t.framebufferTexture2D(_t.FRAMEBUFFER, _t.COLOR_ATTACHMENT0, r, e.__webglTexture, 0), e.shareDepthFrom ? e.depthBuffer && !e.stencilBuffer ? _t.framebufferRenderbuffer(_t.FRAMEBUFFER, _t.DEPTH_ATTACHMENT, _t.RENDERBUFFER, e.__webglRenderbuffer) : e.depthBuffer && e.stencilBuffer && _t.framebufferRenderbuffer(_t.FRAMEBUFFER, _t.DEPTH_STENCIL_ATTACHMENT, _t.RENDERBUFFER, e.__webglRenderbuffer) : D(e.__webglRenderbuffer, e), n && _t.generateMipmap(_t.TEXTURE_2D);
				t ? _t.bindTexture(_t.TEXTURE_CUBE_MAP, null) : _t.bindTexture(_t.TEXTURE_2D, null), _t.bindRenderbuffer(_t.RENDERBUFFER, null), _t.bindFramebuffer(_t.FRAMEBUFFER, null)
			}
			e ? (t = t ? e.__webglFramebuffer[e.activeCubeFace] : e.__webglFramebuffer, n = e.width, e = e.height, i = r = 0) : (t = null, n = bt, e = wt, r = gt, i = yt), t !== et && (_t.bindFramebuffer(_t.FRAMEBUFFER, t), _t.viewport(r, i, n, e), et = t), Et = n, St = e
		}, this.shadowMapPlugin = new THREE.ShadowMapPlugin, this.addPrePlugin(this.shadowMapPlugin), this.addPostPlugin(new THREE.SpritePlugin), this.addPostPlugin(new THREE.LensFlarePlugin)
	}, THREE.WebGLRenderTarget = function(e, t, n) {
		this.width = e, this.height = t, n = n || {}, this.wrapS = void 0 !== n.wrapS ? n.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== n.wrapT ? n.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== n.magFilter ? n.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== n.minFilter ? n.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== n.format ? n.format : THREE.RGBAFormat, this.type = void 0 !== n.type ? n.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== n.depthBuffer ? n.depthBuffer : !0, this.stencilBuffer = void 0 !== n.stencilBuffer ? n.stencilBuffer : !0, this.generateMipmaps = !0, this.shareDepthFrom = null
	}, THREE.WebGLRenderTarget.prototype = {
		constructor: THREE.WebGLRenderTarget,
		setSize: function(e, t) {
			this.width = e, this.height = t
		},
		clone: function() {
			var e = new THREE.WebGLRenderTarget(this.width, this.height);
			return e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.format = this.format, e.type = this.type, e.depthBuffer = this.depthBuffer, e.stencilBuffer = this.stencilBuffer, e.generateMipmaps = this.generateMipmaps, e.shareDepthFrom = this.shareDepthFrom, e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(e, t, n) {
		THREE.WebGLRenderTarget.call(this, e, t, n), this.activeCubeFace = 0
	}, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLProgram = function() {
		var e = 0;
		return function(t, n, r, i) {
			var s = t.context,
				o = r.defines,
				u = r.__webglShader.uniforms,
				f = r.attributes,
				l = r.__webglShader.vertexShader,
				c = r.__webglShader.fragmentShader,
				h = r.index0AttributeName;
			void 0 === h && !0 === i.morphTargets && (h = "position");
			var p = "SHADOWMAP_TYPE_BASIC";
			i.shadowMapType === THREE.PCFShadowMap ? p = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === THREE.PCFSoftShadowMap && (p = "SHADOWMAP_TYPE_PCF_SOFT");
			var d, v;
			d = [];
			for(var m in o) v = o[m], !1 !== v && (v = "#define " + m + " " + v, d.push(v));
			d = d.join("\n"), o = s.createProgram(), r instanceof THREE.RawShaderMaterial ? t = r = "" : (r = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", d, i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.gammaInput ? "#define GAMMA_INPUT" : "", t.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + i.maxDirLights, "#define MAX_POINT_LIGHTS " + i.maxPointLights, "#define MAX_SPOT_LIGHTS " + i.maxSpotLights, "#define MAX_HEMI_LIGHTS " + i.maxHemiLights, "#define MAX_SHADOWS " + i.maxShadows, "#define MAX_BONES " + i.maxBones, i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals ? "#define USE_MORPHNORMALS" : "", i.wrapAround ? "#define WRAP_AROUND" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + p : "", i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n	attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n	attribute vec3 morphTarget0;\n	attribute vec3 morphTarget1;\n	attribute vec3 morphTarget2;\n	attribute vec3 morphTarget3;\n	#ifdef USE_MORPHNORMALS\n		attribute vec3 morphNormal0;\n		attribute vec3 morphNormal1;\n		attribute vec3 morphNormal2;\n		attribute vec3 morphNormal3;\n	#else\n		attribute vec3 morphTarget4;\n		attribute vec3 morphTarget5;\n		attribute vec3 morphTarget6;\n		attribute vec3 morphTarget7;\n	#endif\n#endif\n#ifdef USE_SKINNING\n	attribute vec4 skinIndex;\n	attribute vec4 skinWeight;\n#endif\n"].join("\n"), t = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", i.bumpMap || i.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", d, "#define MAX_DIR_LIGHTS " + i.maxDirLights, "#define MAX_POINT_LIGHTS " + i.maxPointLights, "#define MAX_SPOT_LIGHTS " + i.maxSpotLights, "#define MAX_HEMI_LIGHTS " + i.maxHemiLights, "#define MAX_SHADOWS " + i.maxShadows, i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "", t.gammaInput ? "#define GAMMA_INPUT" : "", t.gammaOutput ? "#define GAMMA_OUTPUT" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.metal ? "#define METAL" : "", i.wrapAround ? "#define WRAP_AROUND" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + p : "", i.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", i.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n")), l = new THREE.WebGLShader(s, s.VERTEX_SHADER, r + l), c = new THREE.WebGLShader(s, s.FRAGMENT_SHADER, t + c), s.attachShader(o, l), s.attachShader(o, c), void 0 !== h && s.bindAttribLocation(o, 0, h), s.linkProgram(o), !1 === s.getProgramParameter(o, s.LINK_STATUS) && (console.error("THREE.WebGLProgram: Could not initialise shader."), console.error("gl.VALIDATE_STATUS", s.getProgramParameter(o, s.VALIDATE_STATUS)), console.error("gl.getError()", s.getError())), "" !== s.getProgramInfoLog(o) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", s.getProgramInfoLog(o)), s.deleteShader(l), s.deleteShader(c), h = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" "), i.useVertexTexture ? (h.push("boneTexture"), h.push("boneTextureWidth"), h.push("boneTextureHeight")) : h.push("boneGlobalMatrices"), i.logarithmicDepthBuffer && h.push("logDepthBufFC");
			for(var g in u) h.push(g);
			u = h, g = {}, h = 0;
			for(t = u.length; h < t; h++) p = u[h], g[p] = s.getUniformLocation(o, p);
			this.uniforms = g, h = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
			for(u = 0; u < i.maxMorphTargets; u++) h.push("morphTarget" + u);
			for(u = 0; u < i.maxMorphNormals; u++) h.push("morphNormal" + u);
			for(var y in f) h.push(y);
			i = h, f = {}, y = 0;
			for(u = i.length; y < u; y++) g = i[y], f[g] = s.getAttribLocation(o, g);
			return this.attributes = f, this.id = e++, this.code = n, this.usedTimes = 1, this.program = o, this.vertexShader = l, this.fragmentShader = c, this
		}
	}(), THREE.WebGLShader = function() {
		var e = function(e) {
			e = e.split("\n");
			for(var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
			return e.join("\n")
		};
		return function(t, n, r) {
			return n = t.createShader(n), t.shaderSource(n, r), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && (console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t.getShaderInfoLog(n)), console.warn(e(r))), n
		}
	}(), THREE.RenderableVertex = function() {
		this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
	}, THREE.RenderableVertex.prototype.copy = function(e) {
		this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen)
	}, THREE.RenderableFace = function() {
		this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.color = new THREE.Color, this.material = null, this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2], this.z = 0
	}, THREE.RenderableObject = function() {
		this.id = 0, this.object = null, this.z = 0
	}, THREE.RenderableSprite = function() {
		this.id = 0, this.object = null, this.rotation = this.z = this.y = this.x = 0, this.scale = new THREE.Vector2, this.material = null
	}, THREE.RenderableLine = function() {
		this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0
	}, THREE.GeometryUtils = {
		merge: function(e, t, n) {
			console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
			var r;
			t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
		},
		center: function(e) {
			return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
		}
	}, THREE.ImageUtils = {
		crossOrigin: void 0,
		loadTexture: function(e, t, n, r) {
			var i = new THREE.ImageLoader;
			i.crossOrigin = this.crossOrigin;
			var s = new THREE.Texture(void 0, t);
			return i.load(e, function(e) {
				s.image = e, s.needsUpdate = !0, n && n(s)
			}, void 0, function(e) {
				r && r(e)
			}), s.sourceFile = e, s
		},
		loadTextureCube: function(e, t, n, r) {
			var i = new THREE.ImageLoader;
			i.crossOrigin = this.crossOrigin;
			var s = new THREE.CubeTexture([], t);
			s.flipY = !1;
			var o = 0;
			t = function(t) {
				i.load(e[t], function(e) {
					s.images[t] = e, o += 1, 6 === o && (s.needsUpdate = !0, n && n(s))
				})
			}, r = 0;
			for(var u = e.length; r < u; ++r) t(r);
			return s
		},
		loadCompressedTexture: function() {
			console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
		},
		loadCompressedTextureCube: function() {
			console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
		},
		getNormalMap: function(e, t) {
			var n = function(e) {
				var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
				return [e[0] / t, e[1] / t, e[2] / t]
			};
			t |= 1;
			var r = e.width,
				i = e.height,
				s = document.createElement("canvas");
			s.width = r, s.height = i;
			var o = s.getContext("2d");
			o.drawImage(e, 0, 0);
			for(var u = o.getImageData(0, 0, r, i).data, a = o.createImageData(r, i), f = a.data, l = 0; l < r; l++)
				for(var c = 0; c < i; c++) {
					var h = 0 > c - 1 ? 0 : c - 1,
						p = c + 1 > i - 1 ? i - 1 : c + 1,
						d = 0 > l - 1 ? 0 : l - 1,
						v = l + 1 > r - 1 ? r - 1 : l + 1,
						m = [],
						g = [0, 0, u[4 * (c * r + l)] / 255 * t];
					m.push([-1, 0, u[4 * (c * r + d)] / 255 * t]), m.push([-1, -1, u[4 * (h * r + d)] / 255 * t]), m.push([0, -1, u[4 * (h * r + l)] / 255 * t]), m.push([1, -1, u[4 * (h * r + v)] / 255 * t]), m.push([1, 0, u[4 * (c * r + v)] / 255 * t]), m.push([1, 1, u[4 * (p * r + v)] / 255 * t]), m.push([0, 1, u[4 * (p * r + l)] / 255 * t]), m.push([-1, 1, u[4 * (p * r + d)] / 255 * t]), h = [], d = m.length;
					for(p = 0; p < d; p++) {
						var v = m[p],
							y = m[(p + 1) % d],
							v = [v[0] - g[0], v[1] - g[1], v[2] - g[2]],
							y = [y[0] - g[0], y[1] - g[1], y[2] - g[2]];
						h.push(n([v[1] * y[2] - v[2] * y[1], v[2] * y[0] - v[0] * y[2], v[0] * y[1] - v[1] * y[0]]))
					}
					m = [0, 0, 0];
					for(p = 0; p < h.length; p++) m[0] += h[p][0], m[1] += h[p][1], m[2] += h[p][2];
					m[0] /= h.length, m[1] /= h.length, m[2] /= h.length, g = 4 * (c * r + l), f[g] = (m[0] + 1) / 2 * 255 | 0, f[g + 1] = (m[1] + 1) / 2 * 255 | 0, f[g + 2] = 255 * m[2] | 0, f[g + 3] = 255
				}
			return o.putImageData(a, 0, 0), s
		},
		generateDataTexture: function(e, t, n) {
			var r = e * t,
				i = new Uint8Array(3 * r),
				s = Math.floor(255 * n.r),
				o = Math.floor(255 * n.g);
			n = Math.floor(255 * n.b);
			for(var u = 0; u < r; u++) i[3 * u] = s, i[3 * u + 1] = o, i[3 * u + 2] = n;
			return e = new THREE.DataTexture(i, e, t, THREE.RGBFormat), e.needsUpdate = !0, e
		}
	}, THREE.SceneUtils = {
		createMultiMaterialObject: function(e, t) {
			for(var n = new THREE.Object3D, r = 0, i = t.length; r < i; r++) n.add(new THREE.Mesh(e, t[r]));
			return n
		},
		detach: function(e, t, n) {
			e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
		},
		attach: function(e, t, n) {
			var r = new THREE.Matrix4;
			r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e)
		}
	}, THREE.FontUtils = {
		faces: {},
		face: "helvetiker",
		weight: "normal",
		style: "normal",
		size: 150,
		divisions: 10,
		getFace: function() {
			try {
				return this.faces[this.face][this.weight][this.style]
			} catch(e) {
				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."
			}
		},
		loadFace: function(e) {
			var t = e.familyName.toLowerCase();
			return this.faces[t] = this.faces[t] || {}, this.faces[t][e.cssFontWeight] = this.faces[t][e.cssFontWeight] || {}, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e
		},
		drawText: function(e) {
			var t = this.getFace(),
				n = this.size / t.resolution,
				r = 0,
				i = String(e).split(""),
				s = i.length,
				o = [];
			for(e = 0; e < s; e++) {
				var u = new THREE.Path,
					u = this.extractGlyphPoints(i[e], t, n, r, u),
					r = r + u.offset;
				o.push(u.path)
			}
			return {
				paths: o,
				offset: r / 2
			}
		},
		extractGlyphPoints: function(e, t, n, r, i) {
			var s = [],
				o, u, a, f, l, c, h, p, d, v, m, g = t.glyphs[e] || t.glyphs["?"];
			if(g) {
				if(g.o)
					for(t = g._cachedOutline || (g._cachedOutline = g.o.split(" ")), f = t.length, e = 0; e < f;) switch(a = t[e++], a) {
						case "m":
							a = t[e++] * n + r, l = t[e++] * n, i.moveTo(a, l);
							break;
						case "l":
							a = t[e++] * n + r, l = t[e++] * n, i.lineTo(a, l);
							break;
						case "q":
							a = t[e++] * n + r, l = t[e++] * n, p = t[e++] * n + r, d = t[e++] * n, i.quadraticCurveTo(p, d, a, l);
							if(o = s[s.length - 1])
								for(c = o.x, h = o.y, o = 1, u = this.divisions; o <= u; o++) {
									var y = o / u;
									THREE.Shape.Utils.b2(y, c, p, a), THREE.Shape.Utils.b2(y, h, d, l)
								}
							break;
						case "b":
							if(a = t[e++] * n + r, l = t[e++] * n, p = t[e++] * n + r, d = t[e++] * n, v = t[e++] * n + r, m = t[e++] * n, i.bezierCurveTo(p, d, v, m, a, l), o = s[s.length - 1])
								for(c = o.x, h = o.y, o = 1, u = this.divisions; o <= u; o++) y = o / u, THREE.Shape.Utils.b3(y, c, p, v, a), THREE.Shape.Utils.b3(y, h, d, m, l)
					}
				return {
					offset: g.ha * n,
					path: i
				}
			}
		}
	}, THREE.FontUtils.generateShapes = function(e, t) {
		t = t || {};
		var n = void 0 !== t.curveSegments ? t.curveSegments : 4,
			r = void 0 !== t.font ? t.font : "helvetiker",
			i = void 0 !== t.weight ? t.weight : "normal",
			s = void 0 !== t.style ? t.style : "normal";
		THREE.FontUtils.size = void 0 !== t.size ? t.size : 100, THREE.FontUtils.divisions = n, THREE.FontUtils.face = r, THREE.FontUtils.weight = i, THREE.FontUtils.style = s, n = THREE.FontUtils.drawText(e).paths, r = [], i = 0;
		for(s = n.length; i < s; i++) Array.prototype.push.apply(r, n[i].toShapes());
		return r
	},
	function(e) {
		var t = function(e) {
			for(var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
			return .5 * n
		};
		return e.Triangulate = function(e, n) {
			var r = e.length;
			if(3 > r) return null;
			var i = [],
				s = [],
				o = [],
				u, a, f;
			if(0 < t(e))
				for(a = 0; a < r; a++) s[a] = a;
			else
				for(a = 0; a < r; a++) s[a] = r - 1 - a;
			var l = 2 * r;
			for(a = r - 1; 2 < r;) {
				if(0 >= l--) {
					console.log("Warning, unable to triangulate polygon!");
					break
				}
				u = a, r <= u && (u = 0), a = u + 1, r <= a && (a = 0), f = a + 1, r <= f && (f = 0);
				var c;
				e: {
					var h = c = void 0,
						p = void 0,
						d = void 0,
						v = void 0,
						m = void 0,
						g = void 0,
						y = void 0,
						w = void 0,
						h = e[s[u]].x,
						p = e[s[u]].y,
						d = e[s[a]].x,
						v = e[s[a]].y,
						m = e[s[f]].x,
						g = e[s[f]].y;
					if(1e-10 > (d - h) * (g - p) - (v - p) * (m - h)) c = !1;
					else {
						var E = void 0,
							S = void 0,
							x = void 0,
							T = void 0,
							N = void 0,
							C = void 0,
							k = void 0,
							L = void 0,
							A = void 0,
							O = void 0,
							A = L = k = w = y = void 0,
							E = m - d,
							S = g - v,
							x = h - m,
							T = p - g,
							N = d - h,
							C = v - p;
						for(c = 0; c < r; c++)
							if(y = e[s[c]].x, w = e[s[c]].y, !(y === h && w === p || y === d && w === v || y === m && w === g) && (k = y - h, L = w - p, A = y - d, O = w - v, y -= m, w -= g, A = E * O - S * A, k = N * L - C * k, L = x * w - T * y, -1e-10 <= A && -1e-10 <= L && -1e-10 <= k)) {
								c = !1;
								break e
							}
						c = !0
					}
				}
				if(c) {
					i.push([e[s[u]], e[s[a]], e[s[f]]]), o.push([s[u], s[a], s[f]]), u = a;
					for(f = a + 1; f < r; u++, f++) s[u] = s[f];
					r--, l = 2 * r
				}
			}
			return n ? o : i
		}, e.Triangulate.area = t, e
	}(THREE.FontUtils), self._typeface_js = {
		faces: THREE.FontUtils.faces,
		loadFace: THREE.FontUtils.loadFace
	}, THREE.typeface_js = self._typeface_js, THREE.Curve = function() {}, THREE.Curve.prototype.getPoint = function(e) {
		return console.log("Warning, getPoint() not implemented!"), null
	}, THREE.Curve.prototype.getPointAt = function(e) {
		return e = this.getUtoTmapping(e), this.getPoint(e)
	}, THREE.Curve.prototype.getPoints = function(e) {
		e || (e = 5);
		var t, n = [];
		for(t = 0; t <= e; t++) n.push(this.getPoint(t / e));
		return n
	}, THREE.Curve.prototype.getSpacedPoints = function(e) {
		e || (e = 5);
		var t, n = [];
		for(t = 0; t <= e; t++) n.push(this.getPointAt(t / e));
		return n
	}, THREE.Curve.prototype.getLength = function() {
		var e = this.getLengths();
		return e[e.length - 1]
	}, THREE.Curve.prototype.getLengths = function(e) {
		e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
		if(this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
		this.needsUpdate = !1;
		var t = [],
			n, r = this.getPoint(0),
			i, s = 0;
		t.push(0);
		for(i = 1; i <= e; i++) n = this.getPoint(i / e), s += n.distanceTo(r), t.push(s), r = n;
		return this.cacheArcLengths = t
	}, THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = !0, this.getLengths()
	}, THREE.Curve.prototype.getUtoTmapping = function(e, t) {
		var n = this.getLengths(),
			r = 0,
			i = n.length,
			s;
		s = t ? t : e * n[i - 1];
		for(var o = 0, u = i - 1, a; o <= u;)
			if(r = Math.floor(o + (u - o) / 2), a = n[r] - s, 0 > a) o = r + 1;
			else {
				if(!(0 < a)) {
					u = r;
					break
				}
				u = r - 1
			}
		return r = u, n[r] == s ? r / (i - 1) : (o = n[r], n = (r + (s - o) / (n[r + 1] - o)) / (i - 1))
	}, THREE.Curve.prototype.getTangent = function(e) {
		var t = e - 1e-4;
		return e += 1e-4, 0 > t && (t = 0), 1 < e && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
	}, THREE.Curve.prototype.getTangentAt = function(e) {
		return e = this.getUtoTmapping(e), this.getTangent(e)
	}, THREE.Curve.Utils = {
		tangentQuadraticBezier: function(e, t, n, r) {
			return 2 * (1 - e) * (n - t) + 2 * e * (r - n)
		},
		tangentCubicBezier: function(e, t, n, r, i) {
			return -3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * i
		},
		tangentSpline: function(e, t, n, r, i) {
			return 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + (-6 * e * e + 6 * e) + (3 * e * e - 2 * e)
		},
		interpolate: function(e, t, n, r, i) {
			e = .5 * (n - e), r = .5 * (r - t);
			var s = i * i;
			return(2 * t - 2 * n + e + r) * i * s + (-3 * t + 3 * n - 2 * e - r) * s + e * i + t
		}
	}, THREE.Curve.create = function(e, t) {
		return e.prototype = Object.create(THREE.Curve.prototype), e.prototype.getPoint = t, e
	}, THREE.CurvePath = function() {
		this.curves = [], this.bends = [], this.autoClose = !1
	}, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.add = function(e) {
		this.curves.push(e)
	}, THREE.CurvePath.prototype.checkConnection = function() {}, THREE.CurvePath.prototype.closePath = function() {
		var e = this.curves[0].getPoint(0),
			t = this.curves[this.curves.length - 1].getPoint(1);
		e.equals(t) || this.curves.push(new THREE.LineCurve(t, e))
	}, THREE.CurvePath.prototype.getPoint = function(e) {
		var t = e * this.getLength(),
			n = this.getCurveLengths();
		for(e = 0; e < n.length;) {
			if(n[e] >= t) return t = n[e] - t, e = this.curves[e], t = 1 - t / e.getLength(), e.getPointAt(t);
			e++
		}
		return null
	}, THREE.CurvePath.prototype.getLength = function() {
		var e = this.getCurveLengths();
		return e[e.length - 1]
	}, THREE.CurvePath.prototype.getCurveLengths = function() {
		if(this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
		var e = [],
			t = 0,
			n, r = this.curves.length;
		for(n = 0; n < r; n++) t += this.curves[n].getLength(), e.push(t);
		return this.cacheLengths = e
	}, THREE.CurvePath.prototype.getBoundingBox = function() {
		var e = this.getPoints(),
			t, n, r, i, s, o;
		t = n = Number.NEGATIVE_INFINITY, i = s = Number.POSITIVE_INFINITY;
		var u, a, f, l, c = e[0] instanceof THREE.Vector3;
		l = c ? new THREE.Vector3 : new THREE.Vector2, a = 0;
		for(f = e.length; a < f; a++) u = e[a], u.x > t ? t = u.x : u.x < i && (i = u.x), u.y > n ? n = u.y : u.y < s && (s = u.y), c && (u.z > r ? r = u.z : u.z < o && (o = u.z)), l.add(u);
		return e = {
			minX: i,
			minY: s,
			maxX: t,
			maxY: n
		}, c && (e.maxZ = r, e.minZ = o), e
	}, THREE.CurvePath.prototype.createPointsGeometry = function(e) {
		return e = this.getPoints(e, !0), this.createGeometry(e)
	}, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(e) {
		return e = this.getSpacedPoints(e, !0), this.createGeometry(e)
	}, THREE.CurvePath.prototype.createGeometry = function(e) {
		for(var t = new THREE.Geometry, n = 0; n < e.length; n++) t.vertices.push(new THREE.Vector3(e[n].x, e[n].y, e[n].z || 0));
		return t
	}, THREE.CurvePath.prototype.addWrapPath = function(e) {
		this.bends.push(e)
	}, THREE.CurvePath.prototype.getTransformedPoints = function(e, t) {
		var n = this.getPoints(e),
			r, i;
		t || (t = this.bends), r = 0;
		for(i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
		return n
	}, THREE.CurvePath.prototype.getTransformedSpacedPoints = function(e, t) {
		var n = this.getSpacedPoints(e),
			r, i;
		t || (t = this.bends), r = 0;
		for(i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
		return n
	}, THREE.CurvePath.prototype.getWrapPoints = function(e, t) {
		var n = this.getBoundingBox(),
			r, i, s, o, u, a;
		r = 0;
		for(i = e.length; r < i; r++) s = e[r], o = s.x, u = s.y, a = o / n.maxX, a = t.getUtoTmapping(a, o), o = t.getPoint(a), a = t.getTangent(a), a.set(-a.y, a.x).multiplyScalar(u), s.x = o.x + a.x, s.y = o.y + a.y;
		return e
	}, THREE.Gyroscope = function() {
		THREE.Object3D.call(this)
	}, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.updateMatrixWorld = function(e) {
		this.matrixAutoUpdate && this.updateMatrix();
		if(this.matrixWorldNeedsUpdate || e) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0;
		for(var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e)
	}, THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3, THREE.Gyroscope.prototype.translationObject = new THREE.Vector3, THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion, THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion, THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3, THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3, THREE.Path = function(e) {
		THREE.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
	}, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.PathActions = {
		MOVE_TO: "moveTo",
		LINE_TO: "lineTo",
		QUADRATIC_CURVE_TO: "quadraticCurveTo",
		BEZIER_CURVE_TO: "bezierCurveTo",
		CSPLINE_THRU: "splineThru",
		ARC: "arc",
		ELLIPSE: "ellipse"
	}, THREE.Path.prototype.fromPoints = function(e) {
		this.moveTo(e[0].x, e[0].y);
		for(var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
	}, THREE.Path.prototype.moveTo = function(e, t) {
		var n = Array.prototype.slice.call(arguments);
		this.actions.push({
			action: THREE.PathActions.MOVE_TO,
			args: n
		})
	}, THREE.Path.prototype.lineTo = function(e, t) {
		var n = Array.prototype.slice.call(arguments),
			r = this.actions[this.actions.length - 1].args,
			r = new THREE.LineCurve(new THREE.Vector2(r[r.length - 2], r[r.length - 1]), new THREE.Vector2(e, t));
		this.curves.push(r), this.actions.push({
			action: THREE.PathActions.LINE_TO,
			args: n
		})
	}, THREE.Path.prototype.quadraticCurveTo = function(e, t, n, r) {
		var i = Array.prototype.slice.call(arguments),
			s = this.actions[this.actions.length - 1].args,
			s = new THREE.QuadraticBezierCurve(new THREE.Vector2(s[s.length - 2], s[s.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r));
		this.curves.push(s), this.actions.push({
			action: THREE.PathActions.QUADRATIC_CURVE_TO,
			args: i
		})
	}, THREE.Path.prototype.bezierCurveTo = function(e, t, n, r, i, s) {
		var o = Array.prototype.slice.call(arguments),
			u = this.actions[this.actions.length - 1].args,
			u = new THREE.CubicBezierCurve(new THREE.Vector2(u[u.length - 2], u[u.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r), new THREE.Vector2(i, s));
		this.curves.push(u), this.actions.push({
			action: THREE.PathActions.BEZIER_CURVE_TO,
			args: o
		})
	}, THREE.Path.prototype.splineThru = function(e) {
		var t = Array.prototype.slice.call(arguments),
			n = this.actions[this.actions.length - 1].args,
			n = [new THREE.Vector2(n[n.length - 2], n[n.length - 1])];
		Array.prototype.push.apply(n, e), n = new THREE.SplineCurve(n), this.curves.push(n), this.actions.push({
			action: THREE.PathActions.CSPLINE_THRU,
			args: t
		})
	}, THREE.Path.prototype.arc = function(e, t, n, r, i, s) {
		var o = this.actions[this.actions.length - 1].args;
		this.absarc(e + o[o.length - 2], t + o[o.length - 1], n, r, i, s)
	}, THREE.Path.prototype.absarc = function(e, t, n, r, i, s) {
		this.absellipse(e, t, n, n, r, i, s)
	}, THREE.Path.prototype.ellipse = function(e, t, n, r, i, s, o) {
		var u = this.actions[this.actions.length - 1].args;
		this.absellipse(e + u[u.length - 2], t + u[u.length - 1], n, r, i, s, o)
	}, THREE.Path.prototype.absellipse = function(e, t, n, r, i, s, o) {
		var u = Array.prototype.slice.call(arguments),
			a = new THREE.EllipseCurve(e, t, n, r, i, s, o);
		this.curves.push(a), a = a.getPoint(1), u.push(a.x), u.push(a.y), this.actions.push({
			action: THREE.PathActions.ELLIPSE,
			args: u
		})
	}, THREE.Path.prototype.getSpacedPoints = function(e, t) {
		e || (e = 40);
		for(var n = [], r = 0; r < e; r++) n.push(this.getPoint(r / e));
		return n
	}, THREE.Path.prototype.getPoints = function(e, t) {
		if(this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
		e = e || 12;
		var n = [],
			r, i, s, o, u, a, f, l, c, h, p, d, v;
		r = 0;
		for(i = this.actions.length; r < i; r++) switch(s = this.actions[r], o = s.action, s = s.args, o) {
			case THREE.PathActions.MOVE_TO:
				n.push(new THREE.Vector2(s[0], s[1]));
				break;
			case THREE.PathActions.LINE_TO:
				n.push(new THREE.Vector2(s[0], s[1]));
				break;
			case THREE.PathActions.QUADRATIC_CURVE_TO:
				u = s[2], a = s[3], c = s[0], h = s[1], 0 < n.length ? (o = n[n.length - 1], p = o.x, d = o.y) : (o = this.actions[r - 1].args, p = o[o.length - 2], d = o[o.length - 1]);
				for(s = 1; s <= e; s++) v = s / e, o = THREE.Shape.Utils.b2(v, p, c, u), v = THREE.Shape.Utils.b2(v, d, h, a), n.push(new THREE.Vector2(o, v));
				break;
			case THREE.PathActions.BEZIER_CURVE_TO:
				u = s[4], a = s[5], c = s[0], h = s[1], f = s[2], l = s[3], 0 < n.length ? (o = n[n.length - 1], p = o.x, d = o.y) : (o = this.actions[r - 1].args, p = o[o.length - 2], d = o[o.length - 1]);
				for(s = 1; s <= e; s++) v = s / e, o = THREE.Shape.Utils.b3(v, p, c, f, u), v = THREE.Shape.Utils.b3(v, d, h, l, a), n.push(new THREE.Vector2(o, v));
				break;
			case THREE.PathActions.CSPLINE_THRU:
				o = this.actions[r - 1].args, v = [new THREE.Vector2(o[o.length - 2], o[o.length - 1])], o = e * s[0].length, v = v.concat(s[0]), v = new THREE.SplineCurve(v);
				for(s = 1; s <= o; s++) n.push(v.getPointAt(s / o));
				break;
			case THREE.PathActions.ARC:
				u = s[0], a = s[1], h = s[2], f = s[3], o = s[4], c = !!s[5], p = o - f, d = 2 * e;
				for(s = 1; s <= d; s++) v = s / d, c || (v = 1 - v), v = f + v * p, o = u + h * Math.cos(v), v = a + h * Math.sin(v), n.push(new THREE.Vector2(o, v));
				break;
			case THREE.PathActions.ELLIPSE:
				for(u = s[0], a = s[1], h = s[2], l = s[3], f = s[4], o = s[5], c = !!s[6], p = o - f, d = 2 * e, s = 1; s <= d; s++) v = s / d, c || (v = 1 - v), v = f + v * p, o = u + h * Math.cos(v), v = a + l * Math.sin(v), n.push(new THREE.Vector2(o, v))
		}
		return r = n[n.length - 1], 1e-10 > Math.abs(r.x - n[0].x) && 1e-10 > Math.abs(r.y - n[0].y) && n.splice(n.length - 1, 1), t && n.push(n[0]), n
	}, THREE.Path.prototype.toShapes = function(e, t) {
		function n(e) {
			for(var t = [], n = 0, r = e.length; n < r; n++) {
				var i = e[n],
					s = new THREE.Shape;
				s.actions = i.actions, s.curves = i.curves, t.push(s)
			}
			return t
		}

		function r(e, t) {
			for(var n = t.length, r = !1, i = n - 1, s = 0; s < n; i = s++) {
				var o = t[i],
					u = t[s],
					a = u.x - o.x,
					f = u.y - o.y;
				if(1e-10 < Math.abs(f)) {
					if(0 > f && (o = t[s], a = -a, u = t[i], f = -f), !(e.y < o.y || e.y > u.y))
						if(e.y == o.y) {
							if(e.x == o.x) return !0
						} else {
							i = f * (e.x - o.x) - a * (e.y - o.y);
							if(0 == i) return !0;
							0 > i || (r = !r)
						}
				} else if(e.y == o.y && (u.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= u.x)) return !0
			}
			return r
		}
		var i = function(e) {
			var t, n, r, i, s = [],
				o = new THREE.Path;
			t = 0;
			for(n = e.length; t < n; t++) r = e[t], i = r.args, r = r.action, r == THREE.PathActions.MOVE_TO && 0 != o.actions.length && (s.push(o), o = new THREE.Path), o[r].apply(o, i);
			return 0 != o.actions.length && s.push(o), s
		}(this.actions);
		if(0 == i.length) return [];
		if(!0 === t) return n(i);
		var s, o, u, a = [];
		if(1 == i.length) return o = i[0], u = new THREE.Shape, u.actions = o.actions, u.curves = o.curves, a.push(u), a;
		var f = !THREE.Shape.Utils.isClockWise(i[0].getPoints()),
			f = e ? !f : f;
		u = [];
		var l = [],
			c = [],
			h = 0,
			p;
		l[h] = void 0, c[h] = [];
		var d, v;
		d = 0;
		for(v = i.length; d < v; d++) o = i[d], p = o.getPoints(), s = THREE.Shape.Utils.isClockWise(p), (s = e ? !s : s) ? (!f && l[h] && h++, l[h] = {
			s: new THREE.Shape,
			p: p
		}, l[h].s.actions = o.actions, l[h].s.curves = o.curves, f && h++, c[h] = []) : c[h].push({
			h: o,
			p: p[0]
		});
		if(!l[0]) return n(i);
		if(1 < l.length) {
			d = !1, v = [], o = 0;
			for(i = l.length; o < i; o++) u[o] = [];
			o = 0;
			for(i = l.length; o < i; o++)
				for(s = c[o], f = 0; f < s.length; f++) {
					h = s[f], p = !0;
					for(var m = 0; m < l.length; m++) r(h.p, l[m].p) && (o != m && v.push({
						froms: o,
						tos: m,
						hole: f
					}), p ? (p = !1, u[m].push(h)) : d = !0);
					p && u[o].push(h)
				}
			0 < v.length && (d || (c = u))
		}
		d = 0;
		for(v = l.length; d < v; d++)
			for(u = l[d].s, a.push(u), o = c[d], i = 0, s = o.length; i < s; i++) u.holes.push(o[i].h);
		return a
	}, THREE.Shape = function() {
		THREE.Path.apply(this, arguments), this.holes = []
	}, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.extrude = function(e) {
		return new THREE.ExtrudeGeometry(this, e)
	}, THREE.Shape.prototype.makeGeometry = function(e) {
		return new THREE.ShapeGeometry(this, e)
	}, THREE.Shape.prototype.getPointsHoles = function(e) {
		var t, n = this.holes.length,
			r = [];
		for(t = 0; t < n; t++) r[t] = this.holes[t].getTransformedPoints(e, this.bends);
		return r
	}, THREE.Shape.prototype.getSpacedPointsHoles = function(e) {
		var t, n = this.holes.length,
			r = [];
		for(t = 0; t < n; t++) r[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
		return r
	}, THREE.Shape.prototype.extractAllPoints = function(e) {
		return {
			shape: this.getTransformedPoints(e),
			holes: this.getPointsHoles(e)
		}
	}, THREE.Shape.prototype.extractPoints = function(e) {
		return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e)
	}, THREE.Shape.prototype.extractAllSpacedPoints = function(e) {
		return {
			shape: this.getTransformedSpacedPoints(e),
			holes: this.getSpacedPointsHoles(e)
		}
	}, THREE.Shape.Utils = {
		triangulateShape: function(e, t) {
			function n(e, t, n) {
				return e.x != t.x ? e.x < t.x ? e.x <= n.x && n.x <= t.x : t.x <= n.x && n.x <= e.x : e.y < t.y ? e.y <= n.y && n.y <= t.y : t.y <= n.y && n.y <= e.y
			}

			function r(e, t, r, i, s) {
				var o = t.x - e.x,
					u = t.y - e.y,
					a = i.x - r.x,
					f = i.y - r.y,
					l = e.x - r.x,
					c = e.y - r.y,
					h = u * a - o * f,
					p = u * l - o * c;
				if(1e-10 < Math.abs(h)) {
					if(0 < h) {
						if(0 > p || p > h) return [];
						a = f * l - a * c;
						if(0 > a || a > h) return []
					} else {
						if(0 < p || p < h) return [];
						a = f * l - a * c;
						if(0 < a || a < h) return []
					}
					return 0 == a ? !s || 0 != p && p != h ? [e] : [] : a == h ? !s || 0 != p && p != h ? [t] : [] : 0 == p ? [r] : p == h ? [i] : (s = a / h, [{
						x: e.x + s * o,
						y: e.y + s * u
					}])
				}
				return 0 != p || f * l != a * c ? [] : (u = 0 == o && 0 == u, a = 0 == a && 0 == f, u && a ? e.x != r.x || e.y != r.y ? [] : [e] : u ? n(r, i, e) ? [e] : [] : a ? n(e, t, r) ? [r] : [] : (0 != o ? (e.x < t.x ? (o = e, a = e.x, u = t, e = t.x) : (o = t, a = t.x, u = e, e = e.x), r.x < i.x ? (t = r, h = r.x, f = i, r = i.x) : (t = i, h = i.x, f = r, r = r.x)) : (e.y < t.y ? (o = e, a = e.y, u = t, e = t.y) : (o = t, a = t.y, u = e, e = e.y), r.y < i.y ? (t = r, h = r.y, f = i, r = i.y) : (t = i, h = i.y, f = r, r = r.y)), a <= h ? e < h ? [] : e == h ? s ? [] : [t] : e <= r ? [t, u] : [t, f] : a > r ? [] : a == r ? s ? [] : [o] : e <= r ? [o, u] : [o, f]))
			}

			function i(e, t, n, r) {
				var i = t.x - e.x,
					s = t.y - e.y;
				t = n.x - e.x, n = n.y - e.y;
				var o = r.x - e.x;
				return r = r.y - e.y, e = i * n - s * t, i = i * r - s * o, 1e-10 < Math.abs(e) ? (t = o * n - r * t, 0 < e ? 0 <= i && 0 <= t : 0 <= i || 0 <= t) : 0 < i
			}
			var s, o, u, a, f, l = {};
			u = e.concat(), s = 0;
			for(o = t.length; s < o; s++) Array.prototype.push.apply(u, t[s]);
			s = 0;
			for(o = u.length; s < o; s++) f = u[s].x + ":" + u[s].y, void 0 !== l[f] && console.log("Duplicate point", f), l[f] = s;
			s = function(e, t) {
				function n(e, t) {
					var n = u.length - 1,
						r = e - 1;
					0 > r && (r = n);
					var s = e + 1;
					return s > n && (s = 0), n = i(u[e], u[r], u[s], a[t]), n ? (n = a.length - 1, r = t - 1, 0 > r && (r = n), s = t + 1, s > n && (s = 0), (n = i(a[t], a[r], a[s], u[e])) ? !0 : !1) : !1
				}

				function s(e, t) {
					var n, i;
					for(n = 0; n < u.length; n++)
						if(i = n + 1, i %= u.length, i = r(e, t, u[n], u[i], !0), 0 < i.length) return !0;
					return !1
				}

				function o(e, n) {
					var i, s, o, u;
					for(i = 0; i < f.length; i++)
						for(s = t[f[i]], o = 0; o < s.length; o++)
							if(u = o + 1, u %= s.length, u = r(e, n, s[o], s[u], !0), 0 < u.length) return !0;
					return !1
				}
				var u = e.concat(),
					a, f = [],
					l, c, h, p, v, m = [],
					g, y, b, w = 0;
				for(l = t.length; w < l; w++) f.push(w);
				g = 0;
				for(var E = 2 * f.length; 0 < f.length;) {
					E--;
					if(0 > E) {
						console.log("Infinite Loop! Holes left:" + f.length + ", Probably Hole outside Shape!");
						break
					}
					for(c = g; c < u.length; c++) {
						h = u[c], l = -1;
						for(w = 0; w < f.length; w++)
							if(p = f[w], v = h.x + ":" + h.y + ":" + p, void 0 === m[v]) {
								a = t[p];
								for(y = 0; y < a.length; y++)
									if(p = a[y], n(c, y) && !s(h, p) && !o(h, p)) {
										l = y, f.splice(w, 1), g = u.slice(0, c + 1), p = u.slice(c), y = a.slice(l), b = a.slice(0, l + 1), u = g.concat(y).concat(b).concat(p), g = c;
										break
									}
								if(0 <= l) break;
								m[v] = !0
							}
						if(0 <= l) break
					}
				}
				return u
			}(e, t);
			var c = THREE.FontUtils.Triangulate(s, !1);
			s = 0;
			for(o = c.length; s < o; s++)
				for(a = c[s], u = 0; 3 > u; u++) f = a[u].x + ":" + a[u].y, f = l[f], void 0 !== f && (a[u] = f);
			return c.concat()
		},
		isClockWise: function(e) {
			return 0 > THREE.FontUtils.Triangulate.area(e)
		},
		b2p0: function(e, t) {
			var n = 1 - e;
			return n * n * t
		},
		b2p1: function(e, t) {
			return 2 * (1 - e) * e * t
		},
		b2p2: function(e, t) {
			return e * e * t
		},
		b2: function(e, t, n, r) {
			return this.b2p0(e, t) + this.b2p1(e, n) + this.b2p2(e, r)
		},
		b3p0: function(e, t) {
			var n = 1 - e;
			return n * n * n * t
		},
		b3p1: function(e, t) {
			var n = 1 - e;
			return 3 * n * n * e * t
		},
		b3p2: function(e, t) {
			return 3 * (1 - e) * e * e * t
		},
		b3p3: function(e, t) {
			return e * e * e * t
		},
		b3: function(e, t, n, r, i) {
			return this.b3p0(e, t) + this.b3p1(e, n) + this.b3p2(e, r) + this.b3p3(e, i)
		}
	}, THREE.LineCurve = function(e, t) {
		this.v1 = e, this.v2 = t
	}, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.getPoint = function(e) {
		var t = this.v2.clone().sub(this.v1);
		return t.multiplyScalar(e).add(this.v1), t
	}, THREE.LineCurve.prototype.getPointAt = function(e) {
		return this.getPoint(e)
	}, THREE.LineCurve.prototype.getTangent = function(e) {
		return this.v2.clone().sub(this.v1).normalize()
	}, THREE.QuadraticBezierCurve = function(e, t, n) {
		this.v0 = e, this.v1 = t, this.v2 = n
	}, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.getPoint = function(e) {
		var t;
		return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), new THREE.Vector2(t, e)
	}, THREE.QuadraticBezierCurve.prototype.getTangent = function(e) {
		var t;
		return t = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y), t = new THREE.Vector2(t, e), t.normalize(), t
	}, THREE.CubicBezierCurve = function(e, t, n, r) {
		this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
	}, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.getPoint = function(e) {
		var t;
		return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(t, e)
	}, THREE.CubicBezierCurve.prototype.getTangent = function(e) {
		var t;
		return t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t = new THREE.Vector2(t, e), t.normalize(), t
	}, THREE.SplineCurve = function(e) {
		this.points = void 0 == e ? [] : e
	}, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.getPoint = function(e) {
		var t = new THREE.Vector2,
			n = [],
			r = this.points,
			i;
		return i = (r.length - 1) * e, e = Math.floor(i), i -= e, n[0] = 0 == e ? e : e - 1, n[1] = e, n[2] = e > r.length - 2 ? r.length - 1 : e + 1, n[3] = e > r.length - 3 ? r.length - 1 : e + 2, t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, i), t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, i), t
	}, THREE.EllipseCurve = function(e, t, n, r, i, s, o) {
		this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o
	}, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.getPoint = function(e) {
		var t;
		return t = this.aEndAngle - this.aStartAngle, 0 > t && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI), t = !0 === this.aClockwise ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t, e = this.aX + this.xRadius * Math.cos(t), t = this.aY + this.yRadius * Math.sin(t), new THREE.Vector2(e, t)
	}, THREE.ArcCurve = function(e, t, n, r, i, s) {
		THREE.EllipseCurve.call(this, e, t, n, n, r, i, s)
	}, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.LineCurve3 = THREE.Curve.create(function(e, t) {
		this.v1 = e, this.v2 = t
	}, function(e) {
		var t = new THREE.Vector3;
		return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
	}), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(e, t, n) {
		this.v0 = e, this.v1 = t, this.v2 = n
	}, function(e) {
		var t, n;
		return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), e = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z), new THREE.Vector3(t, n, e)
	}), THREE.CubicBezierCurve3 = THREE.Curve.create(function(e, t, n, r) {
		this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
	}, function(e) {
		var t, n;
		return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z), new THREE.Vector3(t, n, e)
	}), THREE.SplineCurve3 = THREE.Curve.create(function(e) {
		this.points = void 0 == e ? [] : e
	}, function(e) {
		var t = new THREE.Vector3,
			n = [],
			r = this.points,
			i;
		e *= r.length - 1, i = Math.floor(e), e -= i, n[0] = 0 == i ? i : i - 1, n[1] = i, n[2] = i > r.length - 2 ? r.length - 1 : i + 1, n[3] = i > r.length - 3 ? r.length - 1 : i + 2, i = r[n[0]];
		var s = r[n[1]],
			o = r[n[2]],
			n = r[n[3]];
		return t.x = THREE.Curve.Utils.interpolate(i.x, s.x, o.x, n.x, e), t.y = THREE.Curve.Utils.interpolate(i.y, s.y, o.y, n.y, e), t.z = THREE.Curve.Utils.interpolate(i.z, s.z, o.z, n.z, e), t
	}), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(e) {
		this.points = void 0 == e ? [] : e
	}, function(e) {
		var t = new THREE.Vector3,
			n = [],
			r = this.points,
			i;
		return i = (r.length - 0) * e, e = Math.floor(i), i -= e, e += 0 < e ? 0 : (Math.floor(Math.abs(e) / r.length) + 1) * r.length, n[0] = (e - 1) % r.length, n[1] = e % r.length, n[2] = (e + 1) % r.length, n[3] = (e + 2) % r.length, t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, i), t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, i), t.z = THREE.Curve.Utils.interpolate(r[n[0]].z, r[n[1]].z, r[n[2]].z, r[n[3]].z, i), t
	}), THREE.AnimationHandler = {
		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,
		add: function() {
			console.warn("THREE.AnimationHandler.add() has been deprecated.")
		},
		get: function() {
			console.warn("THREE.AnimationHandler.get() has been deprecated.")
		},
		remove: function() {
			console.warn("THREE.AnimationHandler.remove() has been deprecated.")
		},
		animations: [],
		init: function(e) {
			if(!0 !== e.initialized) {
				for(var t = 0; t < e.hierarchy.length; t++) {
					for(var n = 0; n < e.hierarchy[t].keys.length; n++)
						if(0 > e.hierarchy[t].keys[n].time && (e.hierarchy[t].keys[n].time = 0), void 0 !== e.hierarchy[t].keys[n].rot && !(e.hierarchy[t].keys[n].rot instanceof THREE.Quaternion)) {
							var r = e.hierarchy[t].keys[n].rot;
							e.hierarchy[t].keys[n].rot = (new THREE.Quaternion).fromArray(r)
						}
					if(e.hierarchy[t].keys.length && void 0 !== e.hierarchy[t].keys[0].morphTargets) {
						r = {};
						for(n = 0; n < e.hierarchy[t].keys.length; n++)
							for(var i = 0; i < e.hierarchy[t].keys[n].morphTargets.length; i++) {
								var s = e.hierarchy[t].keys[n].morphTargets[i];
								r[s] = -1
							}
						e.hierarchy[t].usedMorphTargets = r;
						for(n = 0; n < e.hierarchy[t].keys.length; n++) {
							var o = {};
							for(s in r) {
								for(i = 0; i < e.hierarchy[t].keys[n].morphTargets.length; i++)
									if(e.hierarchy[t].keys[n].morphTargets[i] === s) {
										o[s] = e.hierarchy[t].keys[n].morphTargetsInfluences[i];
										break
									}
								i === e.hierarchy[t].keys[n].morphTargets.length && (o[s] = 0)
							}
							e.hierarchy[t].keys[n].morphTargetsInfluences = o
						}
					}
					for(n = 1; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].time === e.hierarchy[t].keys[n - 1].time && (e.hierarchy[t].keys.splice(n, 1), n--);
					for(n = 0; n < e.hierarchy[t].keys.length; n++) e.hierarchy[t].keys[n].index = n
				}
				return e.initialized = !0, e
			}
		},
		parse: function(e) {
			var t = function(e, n) {
					n.push(e);
					for(var r = 0; r < e.children.length; r++) t(e.children[r], n)
				},
				n = [];
			if(e instanceof THREE.SkinnedMesh)
				for(var r = 0; r < e.skeleton.bones.length; r++) n.push(e.skeleton.bones[r]);
			else t(e, n);
			return n
		},
		play: function(e) {
			-1 === this.animations.indexOf(e) && this.animations.push(e)
		},
		stop: function(e) {
			e = this.animations.indexOf(e), -1 !== e && this.animations.splice(e, 1)
		},
		update: function(e) {
			for(var t = 0; t < this.animations.length; t++) this.animations[t].update(e)
		}
	}, THREE.Animation = function(e, t) {
		this.root = e, this.data = THREE.AnimationHandler.init(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, this.interpolationType = THREE.AnimationHandler.LINEAR
	}, THREE.Animation.prototype.keyTypes = ["pos", "rot", "scl"], THREE.Animation.prototype.play = function(e, t) {
		this.currentTime = void 0 !== e ? e : 0, this.weight = void 0 !== t ? t : 1, this.isPlaying = !0, this.reset(), THREE.AnimationHandler.play(this)
	}, THREE.Animation.prototype.stop = function() {
		this.isPlaying = !1, THREE.AnimationHandler.stop(this)
	}, THREE.Animation.prototype.reset = function() {
		for(var e = 0, t = this.hierarchy.length; e < t; e++) {
			var n = this.hierarchy[e];
			n.matrixAutoUpdate = !0, void 0 === n.animationCache && (n.animationCache = {}), void 0 === n.animationCache[this.data.name] && (n.animationCache[this.data.name] = {}, n.animationCache[this.data.name].prevKey = {
				pos: 0,
				rot: 0,
				scl: 0
			}, n.animationCache[this.data.name].nextKey = {
				pos: 0,
				rot: 0,
				scl: 0
			}, n.animationCache[this.data.name].originalMatrix = n.matrix);
			for(var n = n.animationCache[this.data.name], r = 0; 3 > r; r++) {
				for(var i = this.keyTypes[r], s = this.data.hierarchy[e].keys[0], o = this.getNextKeyWith(i, e, 1); o.time < this.currentTime && o.index > s.index;) s = o, o = this.getNextKeyWith(i, e, o.index + 1);
				n.prevKey[i] = s, n.nextKey[i] = o
			}
		}
	}, THREE.Animation.prototype.update = function() {
		var e = [],
			t = new THREE.Vector3,
			n = new THREE.Vector3,
			r = new THREE.Quaternion,
			i = function(e, t) {
				var n = [],
					r = [],
					i, o, u, a, l, c;
				return i = (e.length - 1) * t, o = Math.floor(i), i -= o, n[0] = 0 === o ? o : o - 1, n[1] = o, n[2] = o > e.length - 2 ? o : o + 1, n[3] = o > e.length - 3 ? o : o + 2, o = e[n[0]], a = e[n[1]], l = e[n[2]], c = e[n[3]], n = i * i, u = i * n, r[0] = s(o[0], a[0], l[0], c[0], i, n, u), r[1] = s(o[1], a[1], l[1], c[1], i, n, u), r[2] = s(o[2], a[2], l[2], c[2], i, n, u), r
			},
			s = function(e, t, n, r, i, s, o) {
				return e = .5 * (n - e), r = .5 * (r - t), (2 * (t - n) + e + r) * o + (-3 * (t - n) - 2 * e - r) * s + e * i + t
			};
		return function(s) {
			if(!1 !== this.isPlaying && (this.currentTime += s * this.timeScale, 0 !== this.weight)) {
				s = this.data.length;
				if(!0 === this.loop && this.currentTime > s) this.currentTime %= s, this.reset();
				else if(!1 === this.loop && this.currentTime > s) {
					this.stop();
					return
				}
				s = 0;
				for(var o = this.hierarchy.length; s < o; s++)
					for(var u = this.hierarchy[s], f = u.animationCache[this.data.name], l = 0; 3 > l; l++) {
						var h = this.keyTypes[l],
							p = f.prevKey[h],
							v = f.nextKey[h];
						if(v.time <= this.currentTime) {
							p = this.data.hierarchy[s].keys[0];
							for(v = this.getNextKeyWith(h, s, 1); v.time < this.currentTime && v.index > p.index;) p = v, v = this.getNextKeyWith(h, s, v.index + 1);
							f.prevKey[h] = p, f.nextKey[h] = v
						}
						u.matrixAutoUpdate = !0, u.matrixWorldNeedsUpdate = !0;
						var m = (this.currentTime - p.time) / (v.time - p.time),
							g = p[h],
							y = v[h];
						0 > m && (m = 0), 1 < m && (m = 1);
						if("pos" === h) {
							if(this.interpolationType === THREE.AnimationHandler.LINEAR) n.x = g[0] + (y[0] - g[0]) * m, n.y = g[1] + (y[1] - g[1]) * m, n.z = g[2] + (y[2] - g[2]) * m, u instanceof THREE.Bone ? (p = this.weight / (this.weight + u.accumulatedPosWeight), u.position.lerp(n, p), u.accumulatedPosWeight += this.weight) : u.position.copy(n);
							else if(this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) e[0] = this.getPrevKeyWith("pos", s, p.index - 1).pos, e[1] = g, e[2] = y, e[3] = this.getNextKeyWith("pos", s, v.index + 1).pos, m = .33 * m + .33, v = i(e, m), p = 1, u instanceof THREE.Bone && (p = this.weight / (this.weight + u.accumulatedPosWeight), u.accumulatedPosWeight += this.weight), h = u.position, h.x += (v[0] - h.x) * p, h.y += (v[1] - h.y) * p, h.z += (v[2] - h.z) * p, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (m = i(e, 1.01 * m), t.set(m[0], m[1], m[2]), t.sub(h), t.y = 0, t.normalize(), m = Math.atan2(t.x, t.z), u.rotation.set(0, m, 0))
						} else "rot" === h ? (THREE.Quaternion.slerp(g, y, r, m), u instanceof THREE.Bone ? 0 === u.accumulatedRotWeight ? (u.quaternion.copy(r), u.accumulatedRotWeight = this.weight) : (p = this.weight / (this.weight + u.accumulatedRotWeight), THREE.Quaternion.slerp(u.quaternion, r, u.quaternion, p), u.accumulatedRotWeight += this.weight) : u.quaternion.copy(r)) : "scl" === h && (n.x = g[0] + (y[0] - g[0]) * m, n.y = g[1] + (y[1] - g[1]) * m, n.z = g[2] + (y[2] - g[2]) * m, u instanceof THREE.Bone ? (p = this.weight / (this.weight + u.accumulatedSclWeight), u.scale.lerp(n, p), u.accumulatedSclWeight += this.weight) : u.scale.copy(n))
					}
				return !0
			}
		}
	}(), THREE.Animation.prototype.getNextKeyWith = function(e, t, n) {
		var r = this.data.hierarchy[t].keys;
		for(n = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? n < r.length - 1 ? n : r.length - 1 : n % r.length; n < r.length; n++)
			if(void 0 !== r[n][e]) return r[n];
		return this.data.hierarchy[t].keys[0]
	}, THREE.Animation.prototype.getPrevKeyWith = function(e, t, n) {
		var r = this.data.hierarchy[t].keys;
		for(n = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < n ? n : 0 : 0 <= n ? n : n + r.length; 0 <= n; n--)
			if(void 0 !== r[n][e]) return r[n];
		return this.data.hierarchy[t].keys[r.length - 1]
	}, THREE.KeyFrameAnimation = function(e) {
		this.root = e.node, this.data = THREE.AnimationHandler.init(e), this.hierarchy = THREE.AnimationHandler.parse(this.root), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0, e = 0;
		for(var t = this.hierarchy.length; e < t; e++) {
			var n = this.data.hierarchy[e].sids,
				r = this.hierarchy[e];
			if(this.data.hierarchy[e].keys.length && n) {
				for(var i = 0; i < n.length; i++) {
					var s = n[i],
						o = this.getNextKeyWith(s, e, 0);
					o && o.apply(s)
				}
				r.matrixAutoUpdate = !1, this.data.hierarchy[e].node.updateMatrix(), r.matrixWorldNeedsUpdate = !0
			}
		}
	}, THREE.KeyFrameAnimation.prototype.play = function(e) {
		this.currentTime = void 0 !== e ? e : 0;
		if(!1 === this.isPlaying) {
			this.isPlaying = !0;
			var t = this.hierarchy.length,
				n, r;
			for(e = 0; e < t; e++) n = this.hierarchy[e], r = this.data.hierarchy[e], void 0 === r.animationCache && (r.animationCache = {}, r.animationCache.prevKey = null, r.animationCache.nextKey = null, r.animationCache.originalMatrix = n.matrix), n = this.data.hierarchy[e].keys, n.length && (r.animationCache.prevKey = n[0], r.animationCache.nextKey = n[1], this.startTime = Math.min(n[0].time, this.startTime), this.endTime = Math.max(n[n.length - 1].time, this.endTime));
			this.update(0)
		}
		this.isPaused = !1, THREE.AnimationHandler.play(this)
	}, THREE.KeyFrameAnimation.prototype.stop = function() {
		this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.stop(this);
		for(var e = 0; e < this.data.hierarchy.length; e++) {
			var t = this.hierarchy[e],
				n = this.data.hierarchy[e];
			if(void 0 !== n.animationCache) {
				var r = n.animationCache.originalMatrix;
				r.copy(t.matrix), t.matrix = r, delete n.animationCache
			}
		}
	}, THREE.KeyFrameAnimation.prototype.update = function(e) {
		if(!1 !== this.isPlaying) {
			this.currentTime += e * this.timeScale, e = this.data.length, !0 === this.loop && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e), e = 0;
			for(var t = this.hierarchy.length; e < t; e++) {
				var n = this.hierarchy[e],
					r = this.data.hierarchy[e],
					i = r.keys,
					r = r.animationCache;
				if(i.length) {
					var s = r.prevKey,
						o = r.nextKey;
					if(o.time <= this.currentTime) {
						for(; o.time < this.currentTime && o.index > s.index;) s = o, o = i[s.index + 1];
						r.prevKey = s, r.nextKey = o
					}
					o.time >= this.currentTime ? s.interpolate(o, this.currentTime) : s.interpolate(o, o.time), this.data.hierarchy[e].node.updateMatrix(), n.matrixWorldNeedsUpdate = !0
				}
			}
		}
	}, THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(e, t, n) {
		t = this.data.hierarchy[t].keys;
		for(n %= t.length; n < t.length; n++)
			if(t[n].hasTarget(e)) return t[n];
		return t[0]
	}, THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(e, t, n) {
		t = this.data.hierarchy[t].keys;
		for(n = 0 <= n ? n : n + t.length; 0 <= n; n--)
			if(t[n].hasTarget(e)) return t[n];
		return t[t.length - 1]
	}, THREE.MorphAnimation = function(e) {
		this.mesh = e, this.frames = e.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.isPlaying = !1
	}, THREE.MorphAnimation.prototype = {
		play: function() {
			this.isPlaying = !0
		},
		pause: function() {
			this.isPlaying = !1
		},
		update: function() {
			var e = 0,
				t = 0;
			return function(n) {
				if(!1 !== this.isPlaying) {
					this.currentTime += n, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration), n = this.duration / this.frames;
					var r = Math.floor(this.currentTime / n);
					r != t && (this.mesh.morphTargetInfluences[e] = 0, this.mesh.morphTargetInfluences[t] = 1, this.mesh.morphTargetInfluences[r] = 0, e = t, t = r), this.mesh.morphTargetInfluences[r] = this.currentTime % n / n, this.mesh.morphTargetInfluences[e] = 1 - this.mesh.morphTargetInfluences[r]
				}
			}
		}()
	}, THREE.BoxGeometry = function(e, t, n, r, i, s) {
		function o(e, t, n, r, i, s, o, a) {
			var f, l = u.widthSegments,
				c = u.heightSegments,
				p = i / 2,
				d = s / 2,
				v = u.vertices.length;
			if("x" === e && "y" === t || "y" === e && "x" === t) f = "z";
			else if("x" === e && "z" === t || "z" === e && "x" === t) f = "y", c = u.depthSegments;
			else if("z" === e && "y" === t || "y" === e && "z" === t) f = "x", l = u.depthSegments;
			var m = l + 1,
				g = c + 1,
				y = i / l,
				b = s / c,
				w = new THREE.Vector3;
			w[f] = 0 < o ? 1 : -1;
			for(i = 0; i < g; i++)
				for(s = 0; s < m; s++) {
					var E = new THREE.Vector3;
					E[e] = (s * y - p) * n, E[t] = (i * b - d) * r, E[f] = o, u.vertices.push(E)
				}
			for(i = 0; i < c; i++)
				for(s = 0; s < l; s++) d = s + m * i, e = s + m * (i + 1), t = s + 1 + m * (i + 1), n = s + 1 + m * i, r = new THREE.Vector2(s / l, 1 - i / c), o = new THREE.Vector2(s / l, 1 - (i + 1) / c), f = new THREE.Vector2((s + 1) / l, 1 - (i + 1) / c), p = new THREE.Vector2((s + 1) / l, 1 - i / c), d = new THREE.Face3(d + v, e + v, n + v), d.normal.copy(w), d.vertexNormals.push(w.clone(), w.clone(), w.clone()), d.materialIndex = a, u.faces.push(d), u.faceVertexUvs[0].push([r, o, p]), d = new THREE.Face3(e + v, t + v, n + v), d.normal.copy(w), d.vertexNormals.push(w.clone(), w.clone(), w.clone()), d.materialIndex = a, u.faces.push(d), u.faceVertexUvs[0].push([o.clone(), f, p.clone()])
		}
		THREE.Geometry.call(this), this.parameters = {
			width: e,
			height: t,
			depth: n,
			widthSegments: r,
			heightSegments: i,
			depthSegments: s
		}, this.widthSegments = r || 1, this.heightSegments = i || 1, this.depthSegments = s || 1;
		var u = this;
		r = e / 2, i = t / 2, s = n / 2, o("z", "y", -1, -1, n, t, r, 0), o("z", "y", 1, -1, n, t, -r, 1), o("x", "z", 1, 1, e, n, i, 2), o("x", "z", 1, -1, e, n, -i, 3), o("x", "y", 1, -1, e, t, s, 4), o("x", "y", -1, -1, e, t, -s, 5), this.mergeVertices()
	}, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry = function(e, t, n, r) {
		THREE.Geometry.call(this), this.parameters = {
			radius: e,
			segments: t,
			thetaStart: n,
			thetaLength: r
		}, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
		var i, s = [];
		i = new THREE.Vector3;
		var o = new THREE.Vector2(.5, .5);
		this.vertices.push(i), s.push(o);
		for(i = 0; i <= t; i++) {
			var u = new THREE.Vector3,
				a = n + i / t * r;
			u.x = e * Math.cos(a), u.y = e * Math.sin(a), this.vertices.push(u), s.push(new THREE.Vector2((u.x / e + 1) / 2, (u.y / e + 1) / 2))
		}
		n = new THREE.Vector3(0, 0, 1);
		for(i = 1; i <= t; i++) this.faces.push(new THREE.Face3(i, i + 1, 0, [n.clone(), n.clone(), n.clone()])), this.faceVertexUvs[0].push([s[i].clone(), s[i + 1].clone(), o.clone()]);
		this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
	}, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CubeGeometry = function(e, t, n, r, i, s) {
		return console.warn("THEE.CubeGeometry has been renamed to THREE.BoxGeometry."), new THREE.BoxGeometry(e, t, n, r, i, s)
	}, THREE.CylinderGeometry = function(e, t, n, r, i, s) {
		THREE.Geometry.call(this), this.parameters = {
			radiusTop: e,
			radiusBottom: t,
			height: n,
			radialSegments: r,
			heightSegments: i,
			openEnded: s
		}, e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, n = void 0 !== n ? n : 100, r = r || 8, i = i || 1, s = void 0 !== s ? s : !1;
		var o = n / 2,
			u, a, f = [],
			l = [];
		for(a = 0; a <= i; a++) {
			var c = [],
				h = [],
				p = a / i,
				d = p * (t - e) + e;
			for(u = 0; u <= r; u++) {
				var v = u / r,
					m = new THREE.Vector3;
				m.x = d * Math.sin(v * Math.PI * 2), m.y = -p * n + o, m.z = d * Math.cos(v * Math.PI * 2), this.vertices.push(m), c.push(this.vertices.length - 1), h.push(new THREE.Vector2(v, 1 - p))
			}
			f.push(c), l.push(h)
		}
		n = (t - e) / n;
		for(u = 0; u < r; u++)
			for(0 !== e ? (c = this.vertices[f[0][u]].clone(), h = this.vertices[f[0][u + 1]].clone()) : (c = this.vertices[f[1][u]].clone(), h = this.vertices[f[1][u + 1]].clone()), c.setY(Math.sqrt(c.x * c.x + c.z * c.z) * n).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * n).normalize(), a = 0; a < i; a++) {
				var p = f[a][u],
					d = f[a + 1][u],
					v = f[a + 1][u + 1],
					m = f[a][u + 1],
					g = c.clone(),
					y = c.clone(),
					b = h.clone(),
					w = h.clone(),
					E = l[a][u].clone(),
					S = l[a + 1][u].clone(),
					x = l[a + 1][u + 1].clone(),
					T = l[a][u + 1].clone();
				this.faces.push(new THREE.Face3(p, d, m, [g, y, w])), this.faceVertexUvs[0].push([E, S, T]), this.faces.push(new THREE.Face3(d, v, m, [y.clone(), b, w.clone()])), this.faceVertexUvs[0].push([S.clone(), x, T.clone()])
			}
		if(!1 === s && 0 < e)
			for(this.vertices.push(new THREE.Vector3(0, o, 0)), u = 0; u < r; u++) p = f[0][u], d = f[0][u + 1], v = this.vertices.length - 1, g = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), b = new THREE.Vector3(0, 1, 0), E = l[0][u].clone(), S = l[0][u + 1].clone(), x = new THREE.Vector2(S.x, 0), this.faces.push(new THREE.Face3(p, d, v, [g, y, b])), this.faceVertexUvs[0].push([E, S, x]);
		if(!1 === s && 0 < t)
			for(this.vertices.push(new THREE.Vector3(0, -o, 0)), u = 0; u < r; u++) p = f[a][u + 1], d = f[a][u], v = this.vertices.length - 1, g = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), b = new THREE.Vector3(0, -1, 0), E = l[a][u + 1].clone(), S = l[a][u].clone(), x = new THREE.Vector2(S.x, 1), this.faces.push(new THREE.Face3(p, d, v, [g, y, b])), this.faceVertexUvs[0].push([E, S, x]);
		this.computeFaceNormals()
	}, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry = function(e, t) {
		"undefined" != typeof e && (THREE.Geometry.call(this), e = e instanceof Array ? e : [e], this.addShapeList(e, t), this.computeFaceNormals())
	}, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.addShapeList = function(e, t) {
		for(var n = e.length, r = 0; r < n; r++) this.addShape(e[r], t)
	}, THREE.ExtrudeGeometry.prototype.addShape = function(e, t) {
		function n(e, t, n) {
			return t || console.log("die"), t.clone().multiplyScalar(n).add(e)
		}

		function r(e, t, n) {
			var r = THREE.Math.sign,
				i = 1,
				i = e.x - t.x,
				s = e.y - t.y,
				o = n.x - e.x,
				u = n.y - e.y,
				a = i * i + s * s;
			if(1e-10 < Math.abs(i * u - s * o)) {
				var f = Math.sqrt(a),
					r = Math.sqrt(o * o + u * u),
					a = t.x - s / f;
				t = t.y + i / f, o = ((n.x - u / r - a) * u - (n.y + o / r - t) * o) / (i * u - s * o), n = a + i * o - e.x, e = t + s * o - e.y, i = n * n + e * e;
				if(2 >= i) return new THREE.Vector2(n, e);
				i = Math.sqrt(i / 2)
			} else e = !1, 1e-10 < i ? 1e-10 < o && (e = !0) : -1e-10 > i ? -1e-10 > o && (e = !0) : r(s) == r(u) && (e = !0), e ? (n = -s, e = i, i = Math.sqrt(a)) : (n = i, e = s, i = Math.sqrt(a / 2));
			return new THREE.Vector2(n / i, e / i)
		}

		function i(n, r) {
			var i, s;
			for(q = n.length; 0 <= --q;) {
				i = q, s = q - 1, 0 > s && (s = n.length - 1);
				for(var o = 0, u = p + 2 * l, o = 0; o < u; o++) {
					var a = j * o,
						f = j * (o + 1),
						c = r + i + a,
						a = r + s + a,
						h = r + s + f,
						f = r + i + f,
						d = n,
						v = o,
						m = u,
						g = i,
						w = s,
						c = c + L,
						a = a + L,
						h = h + L,
						f = f + L;
					k.faces.push(new THREE.Face3(c, a, f, null, null, y)), k.faces.push(new THREE.Face3(a, h, f, null, null, y)), c = b.generateSideWallUV(k, e, d, t, c, a, h, f, v, m, g, w), k.faceVertexUvs[0].push([c[0], c[1], c[3]]), k.faceVertexUvs[0].push([c[1], c[2], c[3]])
				}
			}
		}

		function s(e, t, n) {
			k.vertices.push(new THREE.Vector3(e, t, n))
		}

		function o(n, r, i, s) {
			n += L, r += L, i += L, k.faces.push(new THREE.Face3(n, r, i, null, null, g)), n = s ? b.generateBottomUV(k, e, t, n, r, i) : b.generateTopUV(k, e, t, n, r, i), k.faceVertexUvs[0].push(n)
		}
		var u = void 0 !== t.amount ? t.amount : 100,
			a = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
			f = void 0 !== t.bevelSize ? t.bevelSize : a - 2,
			l = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
			c = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0,
			h = void 0 !== t.curveSegments ? t.curveSegments : 12,
			p = void 0 !== t.steps ? t.steps : 1,
			d = t.extrudePath,
			v, m = !1,
			g = t.material,
			y = t.extrudeMaterial,
			b = void 0 !== t.UVGenerator ? t.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
			w, E, S, x;
		d && (v = d.getSpacedPoints(p), m = !0, c = !1, w = void 0 !== t.frames ? t.frames : new THREE.TubeGeometry.FrenetFrames(d, p, !1), E = new THREE.Vector3, S = new THREE.Vector3, x = new THREE.Vector3), c || (f = a = l = 0);
		var T, N, C, k = this,
			L = this.vertices.length,
			d = e.extractPoints(h),
			h = d.shape,
			A = d.holes;
		if(d = !THREE.Shape.Utils.isClockWise(h)) {
			h = h.reverse(), N = 0;
			for(C = A.length; N < C; N++) T = A[N], THREE.Shape.Utils.isClockWise(T) && (A[N] = T.reverse());
			d = !1
		}
		var O = THREE.Shape.Utils.triangulateShape(h, A),
			M = h;
		N = 0;
		for(C = A.length; N < C; N++) T = A[N], h = h.concat(T);
		var _, D, P, H, B, j = h.length,
			F, I = O.length,
			d = [],
			q = 0;
		P = M.length, _ = P - 1;
		for(D = q + 1; q < P; q++, _++, D++) _ === P && (_ = 0), D === P && (D = 0), d[q] = r(M[q], M[_], M[D]);
		var R = [],
			U, z = d.concat();
		N = 0;
		for(C = A.length; N < C; N++) {
			T = A[N], U = [], q = 0, P = T.length, _ = P - 1;
			for(D = q + 1; q < P; q++, _++, D++) _ === P && (_ = 0), D === P && (D = 0), U[q] = r(T[q], T[_], T[D]);
			R.push(U), z = z.concat(U)
		}
		for(_ = 0; _ < l; _++) {
			P = _ / l, H = a * (1 - P), D = f * Math.sin(P * Math.PI / 2), q = 0;
			for(P = M.length; q < P; q++) B = n(M[q], d[q], D), s(B.x, B.y, -H);
			N = 0;
			for(C = A.length; N < C; N++)
				for(T = A[N], U = R[N], q = 0, P = T.length; q < P; q++) B = n(T[q], U[q], D), s(B.x, B.y, -H)
		}
		D = f;
		for(q = 0; q < j; q++) B = c ? n(h[q], z[q], D) : h[q], m ? (S.copy(w.normals[0]).multiplyScalar(B.x), E.copy(w.binormals[0]).multiplyScalar(B.y), x.copy(v[0]).add(S).add(E), s(x.x, x.y, x.z)) : s(B.x, B.y, 0);
		for(P = 1; P <= p; P++)
			for(q = 0; q < j; q++) B = c ? n(h[q], z[q], D) : h[q], m ? (S.copy(w.normals[P]).multiplyScalar(B.x), E.copy(w.binormals[P]).multiplyScalar(B.y), x.copy(v[P]).add(S).add(E), s(x.x, x.y, x.z)) : s(B.x, B.y, u / p * P);
		for(_ = l - 1; 0 <= _; _--) {
			P = _ / l, H = a * (1 - P), D = f * Math.sin(P * Math.PI / 2), q = 0;
			for(P = M.length; q < P; q++) B = n(M[q], d[q], D), s(B.x, B.y, u + H);
			N = 0;
			for(C = A.length; N < C; N++)
				for(T = A[N], U = R[N], q = 0, P = T.length; q < P; q++) B = n(T[q], U[q], D), m ? s(B.x, B.y + v[p - 1].y, v[p - 1].x + H) : s(B.x, B.y, u + H)
		}(function() {
			if(c) {
				var e;
				e = 0 * j;
				for(q = 0; q < I; q++) F = O[q], o(F[2] + e, F[1] + e, F[0] + e, !0);
				e = p + 2 * l, e *= j;
				for(q = 0; q < I; q++) F = O[q], o(F[0] + e, F[1] + e, F[2] + e, !1)
			} else {
				for(q = 0; q < I; q++) F = O[q], o(F[2], F[1], F[0], !0);
				for(q = 0; q < I; q++) F = O[q], o(F[0] + j * p, F[1] + j * p, F[2] + j * p, !1)
			}
		})(),
		function() {
			var e = 0;
			i(M, e), e += M.length, N = 0;
			for(C = A.length; N < C; N++) T = A[N], i(T, e), e += T.length
		}()
	}, THREE.ExtrudeGeometry.WorldUVGenerator = {
		generateTopUV: function(e, t, n, r, i, s) {
			return t = e.vertices[i].x, i = e.vertices[i].y, n = e.vertices[s].x, s = e.vertices[s].y, [new THREE.Vector2(e.vertices[r].x, e.vertices[r].y), new THREE.Vector2(t, i), new THREE.Vector2(n, s)]
		},
		generateBottomUV: function(e, t, n, r, i, s) {
			return this.generateTopUV(e, t, n, r, i, s)
		},
		generateSideWallUV: function(e, t, n, r, i, s, o, u, a, f, l, c) {
			t = e.vertices[i].x, n = e.vertices[i].y, i = e.vertices[i].z, r = e.vertices[s].x, a = e.vertices[s].y, s = e.vertices[s].z, f = e.vertices[o].x, l = e.vertices[o].y, o = e.vertices[o].z, c = e.vertices[u].x;
			var h = e.vertices[u].y;
			return e = e.vertices[u].z, .01 > Math.abs(n - a) ? [new THREE.Vector2(t, 1 - i), new THREE.Vector2(r, 1 - s), new THREE.Vector2(f, 1 - o), new THREE.Vector2(c, 1 - e)] : [new THREE.Vector2(n, 1 - i), new THREE.Vector2(a, 1 - s), new THREE.Vector2(l, 1 - o), new THREE.Vector2(h, 1 - e)]
		}
	}, THREE.ExtrudeGeometry.__v1 = new THREE.Vector2, THREE.ExtrudeGeometry.__v2 = new THREE.Vector2, THREE.ExtrudeGeometry.__v3 = new THREE.Vector2, THREE.ExtrudeGeometry.__v4 = new THREE.Vector2, THREE.ExtrudeGeometry.__v5 = new THREE.Vector2, THREE.ExtrudeGeometry.__v6 = new THREE.Vector2, THREE.ShapeGeometry = function(e, t) {
		THREE.Geometry.call(this), 0 == e instanceof Array && (e = [e]), this.addShapeList(e, t), this.computeFaceNormals()
	}, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.addShapeList = function(e, t) {
		for(var n = 0, r = e.length; n < r; n++) this.addShape(e[n], t);
		return this
	}, THREE.ShapeGeometry.prototype.addShape = function(e, t) {
		void 0 === t && (t = {});
		var n = t.material,
			r = void 0 === t.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
			i, s, o, u = this.vertices.length;
		i = e.extractPoints(void 0 !== t.curveSegments ? t.curveSegments : 12);
		var a = i.shape,
			f = i.holes;
		if(!THREE.Shape.Utils.isClockWise(a))
			for(a = a.reverse(), i = 0, s = f.length; i < s; i++) o = f[i], THREE.Shape.Utils.isClockWise(o) && (f[i] = o.reverse());
		var l = THREE.Shape.Utils.triangulateShape(a, f);
		i = 0;
		for(s = f.length; i < s; i++) o = f[i], a = a.concat(o);
		f = a.length, s = l.length;
		for(i = 0; i < f; i++) o = a[i], this.vertices.push(new THREE.Vector3(o.x, o.y, 0));
		for(i = 0; i < s; i++) f = l[i], a = f[0] + u, o = f[1] + u, f = f[2] + u, this.faces.push(new THREE.Face3(a, o, f, null, null, n)), this.faceVertexUvs[0].push(r.generateBottomUV(this, e, t, a, o, f))
	}, THREE.LatheGeometry = function(e, t, n, r) {
		THREE.Geometry.call(this), t = t || 12, n = n || 0, r = r || 2 * Math.PI;
		for(var i = 1 / (e.length - 1), s = 1 / t, o = 0, u = t; o <= u; o++)
			for(var a = n + o * s * r, f = Math.cos(a), l = Math.sin(a), a = 0, c = e.length; a < c; a++) {
				var h = e[a],
					p = new THREE.Vector3;
				p.x = f * h.x - l * h.y, p.y = l * h.x + f * h.y, p.z = h.z, this.vertices.push(p)
			}
		n = e.length, o = 0;
		for(u = t; o < u; o++)
			for(a = 0, c = e.length - 1; a < c; a++) {
				t = l = a + n * o, r = l + n;
				var f = l + 1 + n,
					l = l + 1,
					h = o * s,
					p = a * i,
					d = h + s,
					v = p + i;
				this.faces.push(new THREE.Face3(t, r, l)), this.faceVertexUvs[0].push([new THREE.Vector2(h, p), new THREE.Vector2(d, p), new THREE.Vector2(h, v)]), this.faces.push(new THREE.Face3(r, f, l)), this.faceVertexUvs[0].push([new THREE.Vector2(d, p), new THREE.Vector2(d, v), new THREE.Vector2(h, v)])
			}
		this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry = function(e, t, n, r) {
		THREE.Geometry.call(this), this.parameters = {
			width: e,
			height: t,
			widthSegments: n,
			heightSegments: r
		};
		var i = e / 2,
			s = t / 2;
		n = n || 1, r = r || 1;
		var o = n + 1,
			u = r + 1,
			a = e / n,
			f = t / r,
			l = new THREE.Vector3(0, 0, 1);
		for(e = 0; e < u; e++) {
			var c = e * f - s;
			for(t = 0; t < o; t++) this.vertices.push(new THREE.Vector3(t * a - i, -c, 0))
		}
		for(e = 0; e < r; e++)
			for(t = 0; t < n; t++) {
				var h = t + o * e,
					i = t + o * (e + 1),
					s = t + 1 + o * (e + 1),
					u = t + 1 + o * e,
					a = new THREE.Vector2(t / n, 1 - e / r),
					f = new THREE.Vector2(t / n, 1 - (e + 1) / r),
					c = new THREE.Vector2((t + 1) / n, 1 - (e + 1) / r),
					p = new THREE.Vector2((t + 1) / n, 1 - e / r),
					h = new THREE.Face3(h, i, u);
				h.normal.copy(l), h.vertexNormals.push(l.clone(), l.clone(), l.clone()), this.faces.push(h), this.faceVertexUvs[0].push([a, f, p]), h = new THREE.Face3(i, s, u), h.normal.copy(l), h.vertexNormals.push(l.clone(), l.clone(), l.clone()), this.faces.push(h), this.faceVertexUvs[0].push([f.clone(), c, p.clone()])
			}
	}, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry = function(e, t, n, r, i, s) {
		THREE.Geometry.call(this), e = e || 0, t = t || 50, i = void 0 !== i ? i : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 8;
		var o, u = [],
			a = e,
			f = (t - e) / r;
		for(e = 0; e < r + 1; e++) {
			for(o = 0; o < n + 1; o++) {
				var l = new THREE.Vector3,
					c = i + o / n * s;
				l.x = a * Math.cos(c), l.y = a * Math.sin(c), this.vertices.push(l), u.push(new THREE.Vector2((l.x / t + 1) / 2, (l.y / t + 1) / 2))
			}
			a += f
		}
		t = new THREE.Vector3(0, 0, 1);
		for(e = 0; e < r; e++)
			for(i = e * (n + 1), o = 0; o < n; o++) s = c = o + i, f = c + n + 1, l = c + n + 2, this.faces.push(new THREE.Face3(s, f, l, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([u[s].clone(), u[f].clone(), u[l].clone()]), s = c, f = c + n + 2, l = c + 1, this.faces.push(new THREE.Face3(s, f, l, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([u[s].clone(), u[f].clone(), u[l].clone()]);
		this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
	}, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry = function(e, t, n, r, i, s, o) {
		THREE.Geometry.call(this), this.parameters = {
			radius: e,
			widthSegments: t,
			heightSegments: n,
			phiStart: r,
			phiLength: i,
			thetaStart: s,
			thetaLength: o
		}, e = e || 50, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, s = void 0 !== s ? s : 0, o = void 0 !== o ? o : Math.PI;
		var u, a, f = [],
			l = [];
		for(a = 0; a <= n; a++) {
			var c = [],
				h = [];
			for(u = 0; u <= t; u++) {
				var p = u / t,
					d = a / n,
					v = new THREE.Vector3;
				v.x = -e * Math.cos(r + p * i) * Math.sin(s + d * o), v.y = e * Math.cos(s + d * o), v.z = e * Math.sin(r + p * i) * Math.sin(s + d * o), this.vertices.push(v), c.push(this.vertices.length - 1), h.push(new THREE.Vector2(p, 1 - d))
			}
			f.push(c), l.push(h)
		}
		for(a = 0; a < n; a++)
			for(u = 0; u < t; u++) {
				r = f[a][u + 1], i = f[a][u], s = f[a + 1][u], o = f[a + 1][u + 1];
				var c = this.vertices[r].clone().normalize(),
					h = this.vertices[i].clone().normalize(),
					p = this.vertices[s].clone().normalize(),
					d = this.vertices[o].clone().normalize(),
					v = l[a][u + 1].clone(),
					m = l[a][u].clone(),
					g = l[a + 1][u].clone(),
					y = l[a + 1][u + 1].clone();
				Math.abs(this.vertices[r].y) === e ? (v.x = (v.x + m.x) / 2, this.faces.push(new THREE.Face3(r, s, o, [c, p, d])), this.faceVertexUvs[0].push([v, g, y])) : Math.abs(this.vertices[s].y) === e ? (g.x = (g.x + y.x) / 2, this.faces.push(new THREE.Face3(r, i, s, [c, h, p])), this.faceVertexUvs[0].push([v, m, g])) : (this.faces.push(new THREE.Face3(r, i, o, [c, h, d])), this.faceVertexUvs[0].push([v, m, y]), this.faces.push(new THREE.Face3(i, s, o, [h.clone(), p, d.clone()])), this.faceVertexUvs[0].push([m.clone(), g, y.clone()]))
			}
		this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
	}, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TextGeometry = function(e, t) {
		t = t || {};
		var n = THREE.FontUtils.generateShapes(e, t);
		t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, n, t)
	}, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TorusGeometry = function(e, t, n, r, i) {
		THREE.Geometry.call(this), this.parameters = {
			radius: e,
			tube: t,
			radialSegments: n,
			tubularSegments: r,
			arc: i
		}, e = e || 100, t = t || 40, n = n || 8, r = r || 6, i = i || 2 * Math.PI;
		for(var s = new THREE.Vector3, o = [], u = [], a = 0; a <= n; a++)
			for(var f = 0; f <= r; f++) {
				var l = f / r * i,
					c = a / n * Math.PI * 2;
				s.x = e * Math.cos(l), s.y = e * Math.sin(l);
				var h = new THREE.Vector3;
				h.x = (e + t * Math.cos(c)) * Math.cos(l), h.y = (e + t * Math.cos(c)) * Math.sin(l), h.z = t * Math.sin(c), this.vertices.push(h), o.push(new THREE.Vector2(f / r, a / n)), u.push(h.clone().sub(s).normalize())
			}
		for(a = 1; a <= n; a++)
			for(f = 1; f <= r; f++) e = (r + 1) * a + f - 1, t = (r + 1) * (a - 1) + f - 1, i = (r + 1) * (a - 1) + f, s = (r + 1) * a + f, l = new THREE.Face3(e, t, s, [u[e].clone(), u[t].clone(), u[s].clone()]), this.faces.push(l), this.faceVertexUvs[0].push([o[e].clone(), o[t].clone(), o[s].clone()]), l = new THREE.Face3(t, i, s, [u[t].clone(), u[i].clone(), u[s].clone()]), this.faces.push(l), this.faceVertexUvs[0].push([o[t].clone(), o[i].clone(), o[s].clone()]);
		this.computeFaceNormals()
	}, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry = function(e, t, n, r, i, s, o) {
		function u(e, t, n, r, i) {
			var s = Math.cos(e),
				o = Math.sin(e);
			return e *= t / n, t = Math.cos(e), s *= r * (2 + t) * .5, o = r * (2 + t) * o * .5, r = i * r * Math.sin(e) * .5, new THREE.Vector3(s, o, r)
		}
		THREE.Geometry.call(this), this.parameters = {
			radius: e,
			tube: t,
			radialSegments: n,
			tubularSegments: r,
			p: i,
			q: s,
			heightScale: o
		}, e = e || 100, t = t || 40, n = n || 64, r = r || 8, i = i || 2, s = s || 3, o = o || 1;
		for(var a = Array(n), f = new THREE.Vector3, l = new THREE.Vector3, c = new THREE.Vector3, h = 0; h < n; ++h) {
			a[h] = Array(r);
			var p = h / n * 2 * i * Math.PI,
				d = u(p, s, i, e, o),
				p = u(p + .01, s, i, e, o);
			f.subVectors(p, d), l.addVectors(p, d), c.crossVectors(f, l), l.crossVectors(c, f), c.normalize(), l.normalize();
			for(p = 0; p < r; ++p) {
				var v = p / r * 2 * Math.PI,
					m = -t * Math.cos(v),
					v = t * Math.sin(v),
					g = new THREE.Vector3;
				g.x = d.x + m * l.x + v * c.x, g.y = d.y + m * l.y + v * c.y, g.z = d.z + m * l.z + v * c.z, a[h][p] = this.vertices.push(g) - 1
			}
		}
		for(h = 0; h < n; ++h)
			for(p = 0; p < r; ++p) i = (h + 1) % n, s = (p + 1) % r, e = a[h][p], t = a[i][p], i = a[i][s], s = a[h][s], o = new THREE.Vector2(h / n, p / r), f = new THREE.Vector2((h + 1) / n, p / r), l = new THREE.Vector2((h + 1) / n, (p + 1) / r), c = new THREE.Vector2(h / n, (p + 1) / r), this.faces.push(new THREE.Face3(e, t, s)), this.faceVertexUvs[0].push([o, f, c]), this.faces.push(new THREE.Face3(t, i, s)), this.faceVertexUvs[0].push([f.clone(), l, c.clone()]);
		this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry = function(e, t, n, r, i) {
		THREE.Geometry.call(this), this.parameters = {
			path: e,
			segments: t,
			radius: n,
			radialSegments: r,
			closed: i
		}, t = t || 64, n = n || 1, r = r || 8, i = i || !1;
		var s = [],
			o, u, a = t + 1,
			f, l, c, h, p = new THREE.Vector3,
			d, v, m;
		d = new THREE.TubeGeometry.FrenetFrames(e, t, i), v = d.normals, m = d.binormals, this.tangents = d.tangents, this.normals = v, this.binormals = m;
		for(d = 0; d < a; d++)
			for(s[d] = [], f = d / (a - 1), h = e.getPointAt(f), o = v[d], u = m[d], f = 0; f < r; f++) l = f / r * 2 * Math.PI, c = -n * Math.cos(l), l = n * Math.sin(l), p.copy(h), p.x += c * o.x + l * u.x, p.y += c * o.y + l * u.y, p.z += c * o.z + l * u.z, s[d][f] = this.vertices.push(new THREE.Vector3(p.x, p.y, p.z)) - 1;
		for(d = 0; d < t; d++)
			for(f = 0; f < r; f++) a = i ? (d + 1) % t : d + 1, p = (f + 1) % r, e = s[d][f], n = s[a][f], a = s[a][p], p = s[d][p], v = new THREE.Vector2(d / t, f / r), m = new THREE.Vector2((d + 1) / t, f / r), o = new THREE.Vector2((d + 1) / t, (f + 1) / r), u = new THREE.Vector2(d / t, (f + 1) / r), this.faces.push(new THREE.Face3(e, n, p)), this.faceVertexUvs[0].push([v, m, u]), this.faces.push(new THREE.Face3(n, a, p)), this.faceVertexUvs[0].push([m.clone(), o, u.clone()]);
		this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.FrenetFrames = function(e, t, n) {
		new THREE.Vector3;
		var r = new THREE.Vector3;
		new THREE.Vector3;
		var i = [],
			s = [],
			o = [],
			u = new THREE.Vector3,
			a = new THREE.Matrix4;
		t += 1;
		var f, l, c;
		this.tangents = i, this.normals = s, this.binormals = o;
		for(f = 0; f < t; f++) l = f / (t - 1), i[f] = e.getTangentAt(l), i[f].normalize();
		s[0] = new THREE.Vector3, o[0] = new THREE.Vector3, e = Number.MAX_VALUE, f = Math.abs(i[0].x), l = Math.abs(i[0].y), c = Math.abs(i[0].z), f <= e && (e = f, r.set(1, 0, 0)), l <= e && (e = l, r.set(0, 1, 0)), c <= e && r.set(0, 0, 1), u.crossVectors(i[0], r).normalize(), s[0].crossVectors(i[0], u), o[0].crossVectors(i[0], s[0]);
		for(f = 1; f < t; f++) s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), u.crossVectors(i[f - 1], i[f]), 1e-4 < u.length() && (u.normalize(), r = Math.acos(THREE.Math.clamp(i[f - 1].dot(i[f]), -1, 1)), s[f].applyMatrix4(a.makeRotationAxis(u, r))), o[f].crossVectors(i[f], s[f]);
		if(n)
			for(r = Math.acos(THREE.Math.clamp(s[0].dot(s[t - 1]), -1, 1)), r /= t - 1, 0 < i[0].dot(u.crossVectors(s[0], s[t - 1])) && (r = -r), f = 1; f < t; f++) s[f].applyMatrix4(a.makeRotationAxis(i[f], r * f)), o[f].crossVectors(i[f], s[f])
	}, THREE.PolyhedronGeometry = function(e, t, n, r) {
		function i(e) {
			var t = e.normalize().clone();
			t.index = a.vertices.push(t) - 1;
			var n = Math.atan2(e.z, -e.x) / 2 / Math.PI + .5;
			return e = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5, t.uv = new THREE.Vector2(n, 1 - e), t
		}

		function s(e, t, n) {
			var r = new THREE.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()]);
			a.faces.push(r), m.copy(e).add(t).add(n).divideScalar(3), r = Math.atan2(m.z, -m.x), a.faceVertexUvs[0].push([u(e.uv, e, r), u(t.uv, t, r), u(n.uv, n, r)])
		}

		function o(e, t) {
			var n = Math.pow(2, t);
			Math.pow(4, t);
			for(var r = i(a.vertices[e.a]), o = i(a.vertices[e.b]), u = i(a.vertices[e.c]), f = [], l = 0; l <= n; l++) {
				f[l] = [];
				for(var c = i(r.clone().lerp(u, l / n)), h = i(o.clone().lerp(u, l / n)), p = n - l, d = 0; d <= p; d++) f[l][d] = 0 == d && l == n ? c : i(c.clone().lerp(h, d / p))
			}
			for(l = 0; l < n; l++)
				for(d = 0; d < 2 * (n - l) - 1; d++) r = Math.floor(d / 2), 0 == d % 2 ? s(f[l][r + 1], f[l + 1][r], f[l][r]) : s(f[l][r + 1], f[l + 1][r + 1], f[l + 1][r])
		}

		function u(e, t, n) {
			return 0 > n && 1 === e.x && (e = new THREE.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new THREE.Vector2(n / 2 / Math.PI + .5, e.y)), e.clone()
		}
		THREE.Geometry.call(this), n = n || 1, r = r || 0;
		for(var a = this, f = 0, l = e.length; f < l; f += 3) i(new THREE.Vector3(e[f], e[f + 1], e[f + 2]));
		e = this.vertices;
		for(var c = [], h = f = 0, l = t.length; f < l; f += 3, h++) {
			var p = e[t[f]],
				d = e[t[f + 1]],
				v = e[t[f + 2]];
			c[h] = new THREE.Face3(p.index, d.index, v.index, [p.clone(), d.clone(), v.clone()])
		}
		for(var m = new THREE.Vector3, f = 0, l = c.length; f < l; f++) o(c[f], r);
		f = 0;
		for(l = this.faceVertexUvs[0].length; f < l; f++) t = this.faceVertexUvs[0][f], r = t[0].x, e = t[1].x, c = t[2].x, h = Math.max(r, Math.max(e, c)), p = Math.min(r, Math.min(e, c)), .9 < h && .1 > p && (.2 > r && (t[0].x += 1), .2 > e && (t[1].x += 1), .2 > c && (t[2].x += 1));
		f = 0;
		for(l = this.vertices.length; f < l; f++) this.vertices[f].multiplyScalar(n);
		this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, n)
	}, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry = function(e, t) {
		this.parameters = {
			radius: e,
			detail: t
		};
		var n = (1 + Math.sqrt(5)) / 2;
		THREE.PolyhedronGeometry.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t)
	}, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry = function(e, t) {
		this.parameters = {
			radius: e,
			detail: t
		}, THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t)
	}, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry = function(e, t) {
		THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t)
	}, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry = function(e, t, n) {
		THREE.Geometry.call(this);
		var r = this.vertices,
			i = this.faces,
			s = this.faceVertexUvs[0],
			o, u, a, f, l = t + 1;
		for(o = 0; o <= n; o++)
			for(f = o / n, u = 0; u <= t; u++) a = u / t, a = e(a, f), r.push(a);
		var c, h, p, d;
		for(o = 0; o < n; o++)
			for(u = 0; u < t; u++) e = o * l + u, r = o * l + u + 1, f = (o + 1) * l + u + 1, a = (o + 1) * l + u, c = new THREE.Vector2(u / t, o / n), h = new THREE.Vector2((u + 1) / t, o / n), p = new THREE.Vector2((u + 1) / t, (o + 1) / n), d = new THREE.Vector2(u / t, (o + 1) / n), i.push(new THREE.Face3(e, r, a)), s.push([c, h, d]), i.push(new THREE.Face3(r, f, a)), s.push([h.clone(), p, d.clone()]);
		this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.AxisHelper = function(e) {
		e = e || 1;
		var t = new Float32Array([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]),
			n = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
		e = new THREE.BufferGeometry, e.addAttribute("position", new THREE.BufferAttribute(t, 3)), e.addAttribute("color", new THREE.BufferAttribute(n, 3)), t = new THREE.LineBasicMaterial({
			vertexColors: THREE.VertexColors
		}), THREE.Line.call(this, e, t, THREE.LinePieces)
	}, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.ArrowHelper = function() {
		var e = new THREE.Geometry;
		e.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
		var t = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
		return t.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0)),
			function(n, r, i, s, o, u) {
				THREE.Object3D.call(this), void 0 === s && (s = 16776960), void 0 === i && (i = 1), void 0 === o && (o = .2 * i), void 0 === u && (u = .2 * o), this.position.copy(r), this.line = new THREE.Line(e, new THREE.LineBasicMaterial({
					color: s
				})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(t, new THREE.MeshBasicMaterial({
					color: s
				})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(n), this.setLength(i, o, u)
			}
	}(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.setDirection = function() {
		var e = new THREE.Vector3,
			t;
		return function(n) {
			.99999 < n.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > n.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
		}
	}(), THREE.ArrowHelper.prototype.setLength = function(e, t, n) {
		void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, e, 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
	}, THREE.ArrowHelper.prototype.setColor = function(e) {
		this.line.material.color.set(e), this.cone.material.color.set(e)
	}, THREE.BoxHelper = function(e) {
		var t = new THREE.BufferGeometry;
		t.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), THREE.Line.call(this, t, new THREE.LineBasicMaterial({
			color: 16776960
		}), THREE.LinePieces), void 0 !== e && this.update(e)
	}, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.update = function(e) {
		var t = e.geometry;
		null === t.boundingBox && t.computeBoundingBox();
		var n = t.boundingBox.min,
			t = t.boundingBox.max,
			r = this.geometry.attributes.position.array;
		r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = n.x, r[4] = t.y, r[5] = t.z, r[6] = n.x, r[7] = t.y, r[8] = t.z, r[9] = n.x, r[10] = n.y, r[11] = t.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = n.y, r[20] = t.z, r[21] = t.x, r[22] = t.y, r[23] = t.z, r[24] = t.x, r[25] = t.y, r[26] = n.z, r[27] = n.x, r[28] = t.y, r[29] = n.z, r[30] = n.x, r[31] = t.y, r[32] = n.z, r[33] = n.x, r[34] = n.y, r[35] = n.z, r[36] = n.x, r[37] = n.y, r[38] = n.z, r[39] = t.x, r[40] = n.y, r[41] = n.z, r[42] = t.x, r[43] = n.y, r[44] = n.z, r[45] = t.x, r[46] = t.y, r[47] = n.z, r[48] = t.x, r[49] = t.y, r[50] = t.z, r[51] = t.x, r[52] = t.y, r[53] = n.z, r[54] = n.x, r[55] = t.y, r[56] = t.z, r[57] = n.x, r[58] = t.y, r[59] = n.z, r[60] = n.x, r[61] = n.y, r[62] = t.z, r[63] = n.x, r[64] = n.y, r[65] = n.z, r[66] = t.x, r[67] = n.y, r[68] = t.z, r[69] = t.x, r[70] = n.y, r[71] = n.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
	}, THREE.BoundingBoxHelper = function(e, t) {
		var n = void 0 !== t ? t : 8947848;
		this.object = e, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
			color: n,
			wireframe: !0
		}))
	}, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.update = function() {
		this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
	}, THREE.CameraHelper = function(e) {
		function t(e, t, r) {
			n(e, r), n(t, r)
		}

		function n(e, t) {
			r.vertices.push(new THREE.Vector3), r.colors.push(new THREE.Color(t)), void 0 === s[e] && (s[e] = []), s[e].push(r.vertices.length - 1)
		}
		var r = new THREE.Geometry,
			i = new THREE.LineBasicMaterial({
				color: 16777215,
				vertexColors: THREE.FaceColors
			}),
			s = {};
		t("n1", "n2", 16755200), t("n2", "n4", 16755200), t("n4", "n3", 16755200), t("n3", "n1", 16755200), t("f1", "f2", 16755200), t("f2", "f4", 16755200), t("f4", "f3", 16755200), t("f3", "f1", 16755200), t("n1", "f1", 16755200), t("n2", "f2", 16755200), t("n3", "f3", 16755200), t("n4", "f4", 16755200), t("p", "n1", 16711680), t("p", "n2", 16711680), t("p", "n3", 16711680), t("p", "n4", 16711680), t("u1", "u2", 43775), t("u2", "u3", 43775), t("u3", "u1", 43775), t("c", "t", 16777215), t("p", "c", 3355443), t("cn1", "cn2", 3355443), t("cn3", "cn4", 3355443), t("cf1", "cf2", 3355443), t("cf3", "cf4", 3355443), THREE.Line.call(this, r, i, THREE.LinePieces), this.camera = e, this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
	}, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Camera,
			n = new THREE.Projector;
		return function() {
			function r(r, s, o, u) {
				e.set(s, o, u), n.unprojectVector(e, t), r = i.pointMap[r];
				if(void 0 !== r)
					for(s = 0, o = r.length; s < o; s++) i.geometry.vertices[r[s]].copy(e)
			}
			var i = this;
			t.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -0.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), this.geometry.verticesNeedUpdate = !0
		}
	}(), THREE.DirectionalLightHelper = function(e, t) {
		THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
		var n = new THREE.Geometry;
		n.vertices.push(new THREE.Vector3(-t, t, 0), new THREE.Vector3(t, t, 0), new THREE.Vector3(t, -t, 0), new THREE.Vector3(-t, -t, 0), new THREE.Vector3(-t, t, 0));
		var r = new THREE.LineBasicMaterial({
			fog: !1
		});
		r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(n, r), this.add(this.lightPlane), n = new THREE.Geometry, n.vertices.push(new THREE.Vector3, new THREE.Vector3), r = new THREE.LineBasicMaterial({
			fog: !1
		}), r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(n, r), this.add(this.targetLine), this.update()
	}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.dispose = function() {
		this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
	}, THREE.DirectionalLightHelper.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3,
			n = new THREE.Vector3;
		return function() {
			e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(n), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
		}
	}(), THREE.EdgesHelper = function(e, t) {
		var n = void 0 !== t ? t : 16777215,
			r = [0, 0],
			i = {},
			s = function(e, t) {
				return e - t
			},
			o = ["a", "b", "c"],
			u = new THREE.BufferGeometry,
			a = e.geometry.clone();
		a.mergeVertices(), a.computeFaceNormals();
		for(var f = a.vertices, a = a.faces, l = 0, c = 0, h = a.length; c < h; c++)
			for(var p = a[c], d = 0; 3 > d; d++) {
				r[0] = p[o[d]], r[1] = p[o[(d + 1) % 3]], r.sort(s);
				var v = r.toString();
				void 0 === i[v] ? (i[v] = {
					vert1: r[0],
					vert2: r[1],
					face1: c,
					face2: void 0
				}, l++) : i[v].face2 = c
			}
		u.addAttribute("position", new THREE.Float32Attribute(6 * l, 3)), r = u.attributes.position.array, s = 0;
		for(v in i)
			if(o = i[v], void 0 === o.face2 || .9999 > a[o.face1].normal.dot(a[o.face2].normal)) l = f[o.vert1], r[s++] = l.x, r[s++] = l.y, r[s++] = l.z, l = f[o.vert2], r[s++] = l.x, r[s++] = l.y, r[s++] = l.z;
		THREE.Line.call(this, u, new THREE.LineBasicMaterial({
			color: n
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
	}, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper = function(e, t, n, r) {
		this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== n ? n : 16776960, r = void 0 !== r ? r : 1, t = new THREE.Geometry, n = 0;
		for(var i = this.object.geometry.faces.length; n < i; n++) t.vertices.push(new THREE.Vector3, new THREE.Vector3);
		THREE.Line.call(this, t, new THREE.LineBasicMaterial({
			color: e,
			linewidth: r
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
	}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.update = function() {
		var e = this.geometry.vertices,
			t = this.object,
			n = t.geometry.vertices,
			r = t.geometry.faces,
			i = t.matrixWorld;
		t.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(i);
		for(var s = t = 0, o = r.length; t < o; t++, s += 2) {
			var u = r[t];
			e[s].copy(n[u.a]).add(n[u.b]).add(n[u.c]).divideScalar(3).applyMatrix4(i), e[s + 1].copy(u.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(e[s])
		}
		return this.geometry.verticesNeedUpdate = !0, this
	}, THREE.GridHelper = function(e, t) {
		var n = new THREE.Geometry,
			r = new THREE.LineBasicMaterial({
				vertexColors: THREE.VertexColors
			});
		this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
		for(var i = -e; i <= e; i += t) {
			n.vertices.push(new THREE.Vector3(-e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e));
			var s = 0 === i ? this.color1 : this.color2;
			n.colors.push(s, s, s, s)
		}
		THREE.Line.call(this, n, r, THREE.LinePieces)
	}, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.setColors = function(e, t) {
		this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
	}, THREE.HemisphereLightHelper = function(e, t, n, r) {
		THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color], e = new THREE.SphereGeometry(t, 4, 2), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
		for(t = 0; 8 > t; t++) e.faces[t].color = this.colors[4 > t ? 0 : 1];
		t = new THREE.MeshBasicMaterial({
			vertexColors: THREE.FaceColors,
			wireframe: !0
		}), this.lightSphere = new THREE.Mesh(e, t), this.add(this.lightSphere), this.update()
	}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.dispose = function() {
		this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
	}, THREE.HemisphereLightHelper.prototype.update = function() {
		var e = new THREE.Vector3;
		return function() {
			this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
		}
	}(), THREE.PointLightHelper = function(e, t) {
		this.light = e, this.light.updateMatrixWorld();
		var n = new THREE.SphereGeometry(t, 4, 2),
			r = new THREE.MeshBasicMaterial({
				wireframe: !0,
				fog: !1
			});
		r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, n, r), this.matrixWorld = this.light.matrixWorld, this.matrixAutoUpdate = !1
	}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.dispose = function() {
		this.geometry.dispose(), this.material.dispose()
	}, THREE.PointLightHelper.prototype.update = function() {
		this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
	}, THREE.SkeletonHelper = function(e) {
		this.bones = this.getBoneList(e);
		for(var t = new THREE.Geometry, n = 0; n < this.bones.length; n++) this.bones[n].parent instanceof THREE.Bone && (t.vertices.push(new THREE.Vector3), t.vertices.push(new THREE.Vector3), t.colors.push(new THREE.Color(0, 0, 1)), t.colors.push(new THREE.Color(0, 1, 0)));
		n = new THREE.LineBasicMaterial({
			vertexColors: THREE.VertexColors,
			depthTest: !1,
			depthWrite: !1,
			transparent: !0
		}), THREE.Line.call(this, t, n, THREE.LinePieces), this.root = e, this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.update()
	}, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.getBoneList = function(e) {
		var t = [];
		e instanceof THREE.Bone && t.push(e);
		for(var n = 0; n < e.children.length; n++) t.push.apply(t, this.getBoneList(e.children[n]));
		return t
	}, THREE.SkeletonHelper.prototype.update = function() {
		for(var e = this.geometry, t = (new THREE.Matrix4).getInverse(this.root.matrixWorld), n = new THREE.Matrix4, r = 0, i = 0; i < this.bones.length; i++) {
			var s = this.bones[i];
			s.parent instanceof THREE.Bone && (n.multiplyMatrices(t, s.matrixWorld), e.vertices[r].setFromMatrixPosition(n), n.multiplyMatrices(t, s.parent.matrixWorld), e.vertices[r + 1].setFromMatrixPosition(n), r += 2)
		}
		e.verticesNeedUpdate = !0, e.computeBoundingSphere()
	}, THREE.SpotLightHelper = function(e) {
		THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0), e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
		var t = new THREE.MeshBasicMaterial({
			wireframe: !0,
			fog: !1
		});
		this.cone = new THREE.Mesh(e, t), this.add(this.cone), this.update()
	}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.dispose = function() {
		this.cone.geometry.dispose(), this.cone.material.dispose()
	}, THREE.SpotLightHelper.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3;
		return function() {
			var n = this.light.distance ? this.light.distance : 1e4,
				r = n * Math.tan(this.light.angle);
			this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
		}
	}(), THREE.VertexNormalsHelper = function(e, t, n, r) {
		this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== n ? n : 16711680, r = void 0 !== r ? r : 1, n = new THREE.Geometry, e = e.geometry.faces;
		for(var i = 0, s = e.length; i < s; i++)
			for(var o = 0, u = e[i].vertexNormals.length; o < u; o++) n.vertices.push(new THREE.Vector3, new THREE.Vector3);
		THREE.Line.call(this, n, new THREE.LineBasicMaterial({
			color: t,
			linewidth: r
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
	}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.update = function(e) {
		var t = new THREE.Vector3;
		return function(e) {
			e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
			for(var n = this.geometry.vertices, r = this.object.geometry.vertices, i = this.object.geometry.faces, s = this.object.matrixWorld, o = 0, u = 0, a = i.length; u < a; u++)
				for(var f = i[u], l = 0, c = f.vertexNormals.length; l < c; l++) {
					var h = f.vertexNormals[l];
					n[o].copy(r[f[e[l]]]).applyMatrix4(s), t.copy(h).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(n[o]), o += 1, n[o].copy(t), o += 1
				}
			return this.geometry.verticesNeedUpdate = !0, this
		}
	}(), THREE.VertexTangentsHelper = function(e, t, n, r) {
		this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== n ? n : 255, r = void 0 !== r ? r : 1, n = new THREE.Geometry, e = e.geometry.faces;
		for(var i = 0, s = e.length; i < s; i++)
			for(var o = 0, u = e[i].vertexTangents.length; o < u; o++) n.vertices.push(new THREE.Vector3), n.vertices.push(new THREE.Vector3);
		THREE.Line.call(this, n, new THREE.LineBasicMaterial({
			color: t,
			linewidth: r
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update()
	}, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.update = function(e) {
		var t = new THREE.Vector3;
		return function(e) {
			e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0);
			for(var n = this.geometry.vertices, r = this.object.geometry.vertices, i = this.object.geometry.faces, s = this.object.matrixWorld, o = 0, u = 0, a = i.length; u < a; u++)
				for(var f = i[u], l = 0, c = f.vertexTangents.length; l < c; l++) {
					var h = f.vertexTangents[l];
					n[o].copy(r[f[e[l]]]).applyMatrix4(s), t.copy(h).transformDirection(s).multiplyScalar(this.size), t.add(n[o]), o += 1, n[o].copy(t), o += 1
				}
			return this.geometry.verticesNeedUpdate = !0, this
		}
	}(), THREE.WireframeHelper = function(e, t) {
		var n = void 0 !== t ? t : 16777215,
			r = [0, 0],
			i = {},
			s = function(e, t) {
				return e - t
			},
			o = ["a", "b", "c"],
			u = new THREE.BufferGeometry;
		if(e.geometry instanceof THREE.Geometry) {
			for(var a = e.geometry.vertices, f = e.geometry.faces, l = 0, c = new Uint32Array(6 * f.length), h = 0, p = f.length; h < p; h++)
				for(var d = f[h], v = 0; 3 > v; v++) {
					r[0] = d[o[v]], r[1] = d[o[(v + 1) % 3]], r.sort(s);
					var m = r.toString();
					void 0 === i[m] && (c[2 * l] = r[0], c[2 * l + 1] = r[1], i[m] = !0, l++)
				}
			r = new Float32Array(6 * l), h = 0;
			for(p = l; h < p; h++)
				for(v = 0; 2 > v; v++) l = a[c[2 * h + v]], o = 6 * h + 3 * v, r[o + 0] = l.x, r[o + 1] = l.y, r[o + 2] = l.z;
			u.addAttribute("position", new THREE.BufferAttribute(r, 3))
		} else if(e.geometry instanceof THREE.BufferGeometry) {
			if(void 0 !== e.geometry.attributes.index) {
				for(var a = e.geometry.attributes.position.array, p = e.geometry.attributes.index.array, f = e.geometry.offsets, l = 0, c = new Uint32Array(2 * p.length), d = 0, g = f.length; d < g; ++d)
					for(var v = f[d].start, m = f[d].count, o = f[d].index, h = v, y = v + m; h < y; h += 3)
						for(v = 0; 3 > v; v++) r[0] = o + p[h + v], r[1] = o + p[h + (v + 1) % 3], r.sort(s), m = r.toString(), void 0 === i[m] && (c[2 * l] = r[0], c[2 * l + 1] = r[1], i[m] = !0, l++);
				r = new Float32Array(6 * l), h = 0;
				for(p = l; h < p; h++)
					for(v = 0; 2 > v; v++) o = 6 * h + 3 * v, l = 3 * c[2 * h + v], r[o + 0] = a[l], r[o + 1] = a[l + 1], r[o + 2] = a[l + 2]
			} else
				for(a = e.geometry.attributes.position.array, l = a.length / 3, c = l / 3, r = new Float32Array(6 * l), h = 0, p = c; h < p; h++)
					for(v = 0; 3 > v; v++) o = 18 * h + 6 * v, c = 9 * h + 3 * v, r[o + 0] = a[c], r[o + 1] = a[c + 1], r[o + 2] = a[c + 2], l = 9 * h + (v + 1) % 3 * 3, r[o + 3] = a[l], r[o + 4] = a[l + 1], r[o + 5] = a[l + 2];
			u.addAttribute("position", new THREE.BufferAttribute(r, 3))
		}
		THREE.Line.call(this, u, new THREE.LineBasicMaterial({
			color: n
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
	}, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.ImmediateRenderObject = function() {
		THREE.Object3D.call(this), this.render = function(e) {}
	}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare = function(e, t, n, r, i) {
		THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, n, r, i)
	}, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.add = function(e, t, n, r, i, s) {
		void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === s && (s = 1), void 0 === i && (i = new THREE.Color(16777215)), void 0 === r && (r = THREE.NormalBlending), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
			texture: e,
			size: t,
			distance: n,
			x: 0,
			y: 0,
			z: 0,
			scale: 1,
			rotation: 1,
			opacity: s,
			color: i,
			blending: r
		})
	}, THREE.LensFlare.prototype.updateLensFlares = function() {
		var e, t = this.lensFlares.length,
			n, r = 2 * -this.positionScreen.x,
			i = 2 * -this.positionScreen.y;
		for(e = 0; e < t; e++) n = this.lensFlares[e], n.x = this.positionScreen.x + r * n.distance, n.y = this.positionScreen.y + i * n.distance, n.wantedRotation = n.x * Math.PI * .25, n.rotation += .25 * (n.wantedRotation - n.rotation)
	}, THREE.MorphBlendMesh = function(e, t) {
		THREE.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
		var n = this.geometry.morphTargets.length;
		this.createAnimation("__default", 0, n - 1, n / 1), this.setAnimationWeight("__default", 1)
	}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.createAnimation = function(e, t, n, r) {
		t = {
			startFrame: t,
			endFrame: n,
			length: n - t + 1,
			fps: r,
			duration: (n - t) / r,
			lastFrame: 0,
			currentFrame: 0,
			active: !1,
			time: 0,
			direction: 1,
			weight: 1,
			directionBackwards: !1,
			mirroredLoop: !1
		}, this.animationsMap[e] = t, this.animationsList.push(t)
	}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(e) {
		for(var t = /([a-z]+)_?(\d+)/, n, r = {}, i = this.geometry, s = 0, o = i.morphTargets.length; s < o; s++) {
			var u = i.morphTargets[s].name.match(t);
			if(u && 1 < u.length) {
				var a = u[1];
				r[a] || (r[a] = {
					start: Infinity,
					end: -Infinity
				}), u = r[a], s < u.start && (u.start = s), s > u.end && (u.end = s), n || (n = a)
			}
		}
		for(a in r) u = r[a], this.createAnimation(a, u.start, u.end, e);
		this.firstAnimation = n
	}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(e) {
		if(e = this.animationsMap[e]) e.direction = 1, e.directionBackwards = !1
	}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(e) {
		if(e = this.animationsMap[e]) e.direction = -1, e.directionBackwards = !0
	}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.fps = t, n.duration = (n.end - n.start) / n.fps)
	}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.duration = t, n.fps = (n.end - n.start) / n.duration)
	}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.weight = t)
	}, THREE.MorphBlendMesh.prototype.setAnimationTime = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.time = t)
	}, THREE.MorphBlendMesh.prototype.getAnimationTime = function(e) {
		var t = 0;
		if(e = this.animationsMap[e]) t = e.time;
		return t
	}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(e) {
		var t = -1;
		if(e = this.animationsMap[e]) t = e.duration;
		return t
	}, THREE.MorphBlendMesh.prototype.playAnimation = function(e) {
		var t = this.animationsMap[e];
		t ? (t.time = 0, t.active = !0) : console.warn("animation[" + e + "] undefined")
	}, THREE.MorphBlendMesh.prototype.stopAnimation = function(e) {
		if(e = this.animationsMap[e]) e.active = !1
	}, THREE.MorphBlendMesh.prototype.update = function(e) {
		for(var t = 0, n = this.animationsList.length; t < n; t++) {
			var r = this.animationsList[t];
			if(r.active) {
				var i = r.duration / r.length;
				r.time += r.direction * e;
				if(r.mirroredLoop) {
					if(r.time > r.duration || 0 > r.time) r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), 0 > r.time && (r.time = 0, r.directionBackwards = !1)
				} else r.time %= r.duration, 0 > r.time && (r.time += r.duration);
				var s = r.startFrame + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
					o = r.weight;
				s !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * o, this.morphTargetInfluences[s] = 0, r.lastFrame = r.currentFrame, r.currentFrame = s), i = r.time % i / i, r.directionBackwards && (i = 1 - i), this.morphTargetInfluences[r.currentFrame] = i * o, this.morphTargetInfluences[r.lastFrame] = (1 - i) * o
			}
		}
	}, THREE.LensFlarePlugin = function() {
		function e(e, t) {
			var r = n.createProgram(),
				i = n.createShader(n.FRAGMENT_SHADER),
				s = n.createShader(n.VERTEX_SHADER),
				o = "precision " + t + " float;\n";
			return n.shaderSource(i, o + e.fragmentShader), n.shaderSource(s, o + e.vertexShader), n.compileShader(i), n.compileShader(s), n.attachShader(r, i), n.attachShader(r, s), n.linkProgram(r), r
		}
		var t = [],
			n, r, i, s, o, u, a, f, l, c, h, p, d;
		this.init = function(t) {
			n = t.context, r = t, i = t.getPrecision(), s = new Float32Array(16), o = new Uint16Array(6), t = 0, s[t++] = -1, s[t++] = -1, s[t++] = 0, s[t++] = 0, s[t++] = 1, s[t++] = -1, s[t++] = 1, s[t++] = 0, s[t++] = 1, s[t++] = 1, s[t++] = 1, s[t++] = 1, s[t++] = -1, s[t++] = 1, s[t++] = 0, s[t++] = 1, t = 0, o[t++] = 0, o[t++] = 1, o[t++] = 2, o[t++] = 0, o[t++] = 2, o[t++] = 3, u = n.createBuffer(), a = n.createBuffer(), n.bindBuffer(n.ARRAY_BUFFER, u), n.bufferData(n.ARRAY_BUFFER, s, n.STATIC_DRAW), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, a), n.bufferData(n.ELEMENT_ARRAY_BUFFER, o, n.STATIC_DRAW), f = n.createTexture(), l = n.createTexture(), n.bindTexture(n.TEXTURE_2D, f), n.texImage2D(n.TEXTURE_2D, 0, n.RGB, 16, 16, 0, n.RGB, n.UNSIGNED_BYTE, null), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.bindTexture(n.TEXTURE_2D, l), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, 16, 16, 0, n.RGBA, n.UNSIGNED_BYTE, null), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), 0 >= n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (c = !1, h = e(THREE.ShaderFlares.lensFlare, i)) : (c = !0, h = e(THREE.ShaderFlares.lensFlareVertexTexture, i)), p = {}, d = {}, p.vertex = n.getAttribLocation(h, "position"), p.uv = n.getAttribLocation(h, "uv"), d.renderType = n.getUniformLocation(h, "renderType"), d.map = n.getUniformLocation(h, "map"), d.occlusionMap = n.getUniformLocation(h, "occlusionMap"), d.opacity = n.getUniformLocation(h, "opacity"), d.color = n.getUniformLocation(h, "color"), d.scale = n.getUniformLocation(h, "scale"), d.rotation = n.getUniformLocation(h, "rotation"), d.screenPosition = n.getUniformLocation(h, "screenPosition")
		}, this.render = function(e, i, s, o) {
			t.length = 0, e.traverseVisible(function(e) {
				e instanceof THREE.LensFlare && t.push(e)
			});
			if(0 !== t.length) {
				e = new THREE.Vector3;
				var v = o / s,
					m = .5 * s,
					g = .5 * o,
					y = 16 / o,
					w = new THREE.Vector2(y * v, y),
					E = new THREE.Vector3(1, 1, 0),
					S = new THREE.Vector2(1, 1),
					x = d,
					y = p;
				n.useProgram(h), n.enableVertexAttribArray(p.vertex), n.enableVertexAttribArray(p.uv), n.uniform1i(x.occlusionMap, 0), n.uniform1i(x.map, 1), n.bindBuffer(n.ARRAY_BUFFER, u), n.vertexAttribPointer(y.vertex, 2, n.FLOAT, !1, 16, 0), n.vertexAttribPointer(y.uv, 2, n.FLOAT, !1, 16, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, a), n.disable(n.CULL_FACE), n.depthMask(!1);
				for(var T = 0, N = t.length; T < N; T++) {
					y = 16 / o, w.set(y * v, y);
					var C = t[T];
					e.set(C.matrixWorld.elements[12], C.matrixWorld.elements[13], C.matrixWorld.elements[14]), e.applyMatrix4(i.matrixWorldInverse), e.applyProjection(i.projectionMatrix), E.copy(e), S.x = E.x * m + m, S.y = E.y * g + g;
					if(c || 0 < S.x && S.x < s && 0 < S.y && S.y < o) {
						n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, f), n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGB, S.x - 8, S.y - 8, 16, 16, 0), n.uniform1i(x.renderType, 0), n.uniform2f(x.scale, w.x, w.y), n.uniform3f(x.screenPosition, E.x, E.y, E.z), n.disable(n.BLEND), n.enable(n.DEPTH_TEST), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, l), n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, S.x - 8, S.y - 8, 16, 16, 0), n.uniform1i(x.renderType, 1), n.disable(n.DEPTH_TEST), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, f), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0), C.positionScreen.copy(E), C.customUpdateCallback ? C.customUpdateCallback(C) : C.updateLensFlares(), n.uniform1i(x.renderType, 2), n.enable(n.BLEND);
						for(var L = 0, A = C.lensFlares.length; L < A; L++) {
							var O = C.lensFlares[L];
							.001 < O.opacity && .001 < O.scale && (E.x = O.x, E.y = O.y, E.z = O.z, y = O.size * O.scale / o, w.x = y * v, w.y = y, n.uniform3f(x.screenPosition, E.x, E.y, E.z), n.uniform2f(x.scale, w.x, w.y), n.uniform1f(x.rotation, O.rotation), n.uniform1f(x.opacity, O.opacity), n.uniform3f(x.color, O.color.r, O.color.g, O.color.b), r.setBlending(O.blending, O.blendEquation, O.blendSrc, O.blendDst), r.setTexture(O.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0))
						}
					}
				}
				n.enable(n.CULL_FACE), n.enable(n.DEPTH_TEST), n.depthMask(!0)
			}
		}
	}, THREE.ShadowMapPlugin = function() {
		function e(t, n, r) {
			if(n.visible) {
				var i = t.__webglObjects[n.id];
				if(i && n.castShadow && (!1 === n.frustumCulled || !0 === u.intersectsObject(n)))
					for(var s = 0, o = i.length; s < o; s++) {
						var a = i[s];
						n._modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld), h.push(a)
					}
				s = 0;
				for(o = n.children.length; s < o; s++) e(t, n.children[s], r)
			}
		}
		var t, n, r, i, s, o, u = new THREE.Frustum,
			a = new THREE.Matrix4,
			f = new THREE.Vector3,
			l = new THREE.Vector3,
			c = new THREE.Vector3,
			h = [];
		this.init = function(e) {
			t = e.context, n = e, e = THREE.ShaderLib.depthRGBA;
			var u = THREE.UniformsUtils.clone(e.uniforms);
			r = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u
			}), i = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u,
				morphTargets: !0
			}), s = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u,
				skinning: !0
			}), o = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u,
				morphTargets: !0,
				skinning: !0
			}), r._shadowPass = !0, i._shadowPass = !0, s._shadowPass = !0, o._shadowPass = !0
		}, this.render = function(e, t) {
			n.shadowMapEnabled && n.shadowMapAutoUpdate && this.update(e, t)
		}, this.update = function(p, v) {
			var m, y, w, E, S, x, T, N, C = [];
			E = 0, t.clearColor(1, 1, 1, 1), t.disable(t.BLEND), t.enable(t.CULL_FACE), t.frontFace(t.CCW), n.shadowMapCullFace === THREE.CullFaceFront ? t.cullFace(t.FRONT) : t.cullFace(t.BACK), n.setDepthTest(!0), m = 0;
			for(y = p.__lights.length; m < y; m++)
				if(w = p.__lights[m], w.castShadow)
					if(w instanceof THREE.DirectionalLight && w.shadowCascade)
						for(S = 0; S < w.shadowCascadeCount; S++) {
							var L;
							if(w.shadowCascadeArray[S]) L = w.shadowCascadeArray[S];
							else {
								T = w;
								var A = S;
								L = new THREE.DirectionalLight, L.isVirtual = !0, L.onlyShadow = !0, L.castShadow = !0, L.shadowCameraNear = T.shadowCameraNear, L.shadowCameraFar = T.shadowCameraFar, L.shadowCameraLeft = T.shadowCameraLeft, L.shadowCameraRight = T.shadowCameraRight, L.shadowCameraBottom = T.shadowCameraBottom, L.shadowCameraTop = T.shadowCameraTop, L.shadowCameraVisible = T.shadowCameraVisible, L.shadowDarkness = T.shadowDarkness, L.shadowBias = T.shadowCascadeBias[A], L.shadowMapWidth = T.shadowCascadeWidth[A], L.shadowMapHeight = T.shadowCascadeHeight[A], L.pointsWorld = [], L.pointsFrustum = [], N = L.pointsWorld, x = L.pointsFrustum;
								for(var O = 0; 8 > O; O++) N[O] = new THREE.Vector3, x[O] = new THREE.Vector3;
								N = T.shadowCascadeNearZ[A], T = T.shadowCascadeFarZ[A], x[0].set(-1, -1, N), x[1].set(1, -1, N), x[2].set(-1, 1, N), x[3].set(1, 1, N), x[4].set(-1, -1, T), x[5].set(1, -1, T), x[6].set(-1, 1, T), x[7].set(1, 1, T), L.originalCamera = v, x = new THREE.Gyroscope, x.position.copy(w.shadowCascadeOffset), x.add(L), x.add(L.target), v.add(x), w.shadowCascadeArray[S] = L, console.log("Created virtualLight", L)
							}
							A = w, N = S, T = A.shadowCascadeArray[N], T.position.copy(A.position), T.target.position.copy(A.target.position), T.lookAt(T.target), T.shadowCameraVisible = A.shadowCameraVisible, T.shadowDarkness = A.shadowDarkness, T.shadowBias = A.shadowCascadeBias[N], x = A.shadowCascadeNearZ[N], A = A.shadowCascadeFarZ[N], T = T.pointsFrustum, T[0].z = x, T[1].z = x, T[2].z = x, T[3].z = x, T[4].z = A, T[5].z = A, T[6].z = A, T[7].z = A, C[E] = L, E++
						} else C[E] = w, E++;
			m = 0;
			for(y = C.length; m < y; m++) {
				w = C[m], w.shadowMap || (S = THREE.LinearFilter, n.shadowMapType === THREE.PCFSoftShadowMap && (S = THREE.NearestFilter), w.shadowMap = new THREE.WebGLRenderTarget(w.shadowMapWidth, w.shadowMapHeight, {
					minFilter: S,
					magFilter: S,
					format: THREE.RGBAFormat
				}), w.shadowMapSize = new THREE.Vector2(w.shadowMapWidth, w.shadowMapHeight), w.shadowMatrix = new THREE.Matrix4);
				if(!w.shadowCamera) {
					if(w instanceof THREE.SpotLight) w.shadowCamera = new THREE.PerspectiveCamera(w.shadowCameraFov, w.shadowMapWidth / w.shadowMapHeight, w.shadowCameraNear, w.shadowCameraFar);
					else {
						if(!(w instanceof THREE.DirectionalLight)) {
							console.error("Unsupported light type for shadow");
							continue
						}
						w.shadowCamera = new THREE.OrthographicCamera(w.shadowCameraLeft, w.shadowCameraRight, w.shadowCameraTop, w.shadowCameraBottom, w.shadowCameraNear, w.shadowCameraFar)
					}
					p.add(w.shadowCamera), !0 === p.autoUpdate && p.updateMatrixWorld()
				}
				w.shadowCameraVisible && !w.cameraHelper && (w.cameraHelper = new THREE.CameraHelper(w.shadowCamera), w.shadowCamera.add(w.cameraHelper));
				if(w.isVirtual && L.originalCamera == v) {
					S = v, E = w.shadowCamera, x = w.pointsFrustum, T = w.pointsWorld, f.set(Infinity, Infinity, Infinity), l.set(-Infinity, -Infinity, -Infinity);
					for(A = 0; 8 > A; A++) N = T[A], N.copy(x[A]), THREE.ShadowMapPlugin.__projector.unprojectVector(N, S), N.applyMatrix4(E.matrixWorldInverse), N.x < f.x && (f.x = N.x), N.x > l.x && (l.x = N.x), N.y < f.y && (f.y = N.y), N.y > l.y && (l.y = N.y), N.z < f.z && (f.z = N.z), N.z > l.z && (l.z = N.z);
					E.left = f.x, E.right = l.x, E.top = l.y, E.bottom = f.y, E.updateProjectionMatrix()
				}
				E = w.shadowMap, x = w.shadowMatrix, S = w.shadowCamera, S.position.setFromMatrixPosition(w.matrixWorld), c.setFromMatrixPosition(w.target.matrixWorld), S.lookAt(c), S.updateMatrixWorld(), S.matrixWorldInverse.getInverse(S.matrixWorld), w.cameraHelper && (w.cameraHelper.visible = w.shadowCameraVisible), w.shadowCameraVisible && w.cameraHelper.update(), x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(S.projectionMatrix), x.multiply(S.matrixWorldInverse), a.multiplyMatrices(S.projectionMatrix, S.matrixWorldInverse), u.setFromMatrix(a), n.setRenderTarget(E), n.clear(), h.length = 0, e(p, p, S), w = 0;
				for(E = h.length; w < E; w++) T = h[w], x = T.object, T = T.buffer, A = x.material instanceof THREE.MeshFaceMaterial ? x.material.materials[0] : x.material, N = void 0 !== x.geometry.morphTargets && 0 < x.geometry.morphTargets.length && A.morphTargets, O = x instanceof THREE.SkinnedMesh && A.skinning, N = x.customDepthMaterial ? x.customDepthMaterial : O ? N ? o : s : N ? i : r, n.setMaterialFaces(A), T instanceof THREE.BufferGeometry ? n.renderBufferDirect(S, p.__lights, null, N, T, x) : n.renderBuffer(S, p.__lights, null, N, T, x);
				A = p.__webglObjectsImmediate, w = 0;
				for(E = A.length; w < E; w++) T = A[w], x = T.object, x.visible && x.castShadow && (x._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, x.matrixWorld), n.renderImmediateObject(S, p.__lights, null, r, x))
			}
			m = n.getClearColor(), y = n.getClearAlpha(), t.clearColor(m.r, m.g, m.b, y), t.enable(t.BLEND), n.shadowMapCullFace === THREE.CullFaceFront && t.cullFace(t.BACK)
		}
	}, THREE.ShadowMapPlugin.__projector = new THREE.Projector, THREE.SpritePlugin = function() {
		function g(e, t) {
			return e.z !== t.z ? t.z - e.z : t.id - e.id
		}
		var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, y, b, w, E = [],
			S, x, T, N, C;
		this.init = function(g) {
			y = g.context, b = g, S = new Float32Array([-0.5, -0.5, 0, 0, .5, -0.5, 1, 0, .5, .5, 1, 1, -0.5, .5, 0, 1]), x = new Uint16Array([0, 1, 2, 0, 2, 3]), T = y.createBuffer(), N = y.createBuffer(), y.bindBuffer(y.ARRAY_BUFFER, T), y.bufferData(y.ARRAY_BUFFER, S, y.STATIC_DRAW), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, N), y.bufferData(y.ELEMENT_ARRAY_BUFFER, x, y.STATIC_DRAW), g = y.createProgram();
			var E = y.createShader(y.VERTEX_SHADER),
				L = y.createShader(y.FRAGMENT_SHADER);
			y.shaderSource(E, ["precision " + b.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), y.shaderSource(L, ["precision " + b.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), y.compileShader(E), y.compileShader(L), y.attachShader(g, E), y.attachShader(g, L), y.linkProgram(g), C = g, v = y.getAttribLocation(C, "position"), m = y.getAttribLocation(C, "uv"), e = y.getUniformLocation(C, "uvOffset"), t = y.getUniformLocation(C, "uvScale"), n = y.getUniformLocation(C, "rotation"), r = y.getUniformLocation(C, "scale"), i = y.getUniformLocation(C, "color"), s = y.getUniformLocation(C, "map"), o = y.getUniformLocation(C, "opacity"), u = y.getUniformLocation(C, "modelViewMatrix"), a = y.getUniformLocation(C, "projectionMatrix"), f = y.getUniformLocation(C, "fogType"), l = y.getUniformLocation(C, "fogDensity"), c = y.getUniformLocation(C, "fogNear"), h = y.getUniformLocation(C, "fogFar"), p = y.getUniformLocation(C, "fogColor"), d = y.getUniformLocation(C, "alphaTest"), g = document.createElement("canvas"), g.width = 8, g.height = 8, E = g.getContext("2d"), E.fillStyle = "white", E.fillRect(0, 0, 8, 8), w = new THREE.Texture(g), w.needsUpdate = !0
		}, this.render = function(S, x, L, O) {
			E.length = 0, S.traverseVisible(function(e) {
				e instanceof THREE.Sprite && E.push(e)
			});
			if(0 !== E.length) {
				y.useProgram(C), y.enableVertexAttribArray(v), y.enableVertexAttribArray(m), y.disable(y.CULL_FACE), y.enable(y.BLEND), y.bindBuffer(y.ARRAY_BUFFER, T), y.vertexAttribPointer(v, 2, y.FLOAT, !1, 16, 0), y.vertexAttribPointer(m, 2, y.FLOAT, !1, 16, 8), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, N), y.uniformMatrix4fv(a, !1, x.projectionMatrix.elements), y.activeTexture(y.TEXTURE0), y.uniform1i(s, 0), O = L = 0;
				var M = S.fog;
				M ? (y.uniform3f(p, M.color.r, M.color.g, M.color.b), M instanceof THREE.Fog ? (y.uniform1f(c, M.near), y.uniform1f(h, M.far), y.uniform1i(f, 1), O = L = 1) : M instanceof THREE.FogExp2 && (y.uniform1f(l, M.density), y.uniform1i(f, 2), O = L = 2)) : (y.uniform1i(f, 0), O = L = 0);
				for(var M = 0, _ = E.length; M < _; M++) {
					var P = E[M],
						H = P.material;
					P._modelViewMatrix.multiplyMatrices(x.matrixWorldInverse, P.matrixWorld), P.z = -P._modelViewMatrix.elements[14]
				}
				E.sort(g), x = [], M = 0;
				for(_ = E.length; M < _; M++) P = E[M], H = P.material, y.uniform1f(d, H.alphaTest), y.uniformMatrix4fv(u, !1, P._modelViewMatrix.elements), x[0] = P.scale.x, x[1] = P.scale.y, P = 0, S.fog && H.fog && (P = O), L !== P && (y.uniform1i(f, P), L = P), null !== H.map ? (y.uniform2f(e, H.map.offset.x, H.map.offset.y), y.uniform2f(t, H.map.repeat.x, H.map.repeat.y)) : (y.uniform2f(e, 0, 0), y.uniform2f(t, 1, 1)), y.uniform1f(o, H.opacity), y.uniform3f(i, H.color.r, H.color.g, H.color.b), y.uniform1f(n, H.rotation), y.uniform2fv(r, x), b.setBlending(H.blending, H.blendEquation, H.blendSrc, H.blendDst), b.setDepthTest(H.depthTest), b.setDepthWrite(H.depthWrite), H.map && H.map.image && H.map.image.width ? b.setTexture(H.map, 0) : b.setTexture(w, 0), y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0);
				y.enable(y.CULL_FACE)
			}
		}
	}, THREE.DepthPassPlugin = function() {
		function e(t, n, r) {
			if(n.visible) {
				var i = t.__webglObjects[n.id];
				if(i && (!1 === n.frustumCulled || !0 === u.intersectsObject(n)))
					for(var s = 0, o = i.length; s < o; s++) {
						var a = i[s];
						n._modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld), f.push(a)
					}
				s = 0;
				for(o = n.children.length; s < o; s++) e(t, n.children[s], r)
			}
		}
		this.enabled = !1, this.renderTarget = null;
		var t, n, r, i, s, o, u = new THREE.Frustum,
			a = new THREE.Matrix4,
			f = [];
		this.init = function(e) {
			t = e.context, n = e, e = THREE.ShaderLib.depthRGBA;
			var u = THREE.UniformsUtils.clone(e.uniforms);
			r = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u
			}), i = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u,
				morphTargets: !0
			}), s = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u,
				skinning: !0
			}), o = new THREE.ShaderMaterial({
				fragmentShader: e.fragmentShader,
				vertexShader: e.vertexShader,
				uniforms: u,
				morphTargets: !0,
				skinning: !0
			}), r._shadowPass = !0, i._shadowPass = !0, s._shadowPass = !0, o._shadowPass = !0
		}, this.render = function(e, t) {
			this.enabled && this.update(e, t)
		}, this.update = function(p, v) {
			var m, y, w, E, S;
			t.clearColor(1, 1, 1, 1), t.disable(t.BLEND), n.setDepthTest(!0), !0 === p.autoUpdate && p.updateMatrixWorld(), v.matrixWorldInverse.getInverse(v.matrixWorld), a.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse), u.setFromMatrix(a), n.setRenderTarget(this.renderTarget), n.clear(), f.length = 0, e(p, p, v);
			var x;
			m = 0;
			for(y = f.length; m < y; m++) w = f[m], S = w.object, w = w.buffer, S instanceof THREE.PointCloud && !S.customDepthMaterial || ((x = S.material instanceof THREE.MeshFaceMaterial ? S.material.materials[0] : S.material) && n.setMaterialFaces(S.material), E = void 0 !== S.geometry.morphTargets && 0 < S.geometry.morphTargets.length && x.morphTargets, x = S instanceof THREE.SkinnedMesh && x.skinning, E = S.customDepthMaterial ? S.customDepthMaterial : x ? E ? o : s : E ? i : r, w instanceof THREE.BufferGeometry ? n.renderBufferDirect(v, p.__lights, null, E, w, S) : n.renderBuffer(v, p.__lights, null, E, w, S));
			E = p.__webglObjectsImmediate, m = 0;
			for(y = E.length; m < y; m++) w = E[m], S = w.object, S.visible && (S._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, S.matrixWorld), n.renderImmediateObject(v, p.__lights, null, r, S));
			m = n.getClearColor(), y = n.getClearAlpha(), t.clearColor(m.r, m.g, m.b, y), t.enable(t.BLEND)
		}
	}, THREE.ShaderFlares = {
		lensFlareVertexTexture: {
			vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
			fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
		},
		lensFlare: {
			vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
			fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
		}
	}, define("three", function() {}), requirejs.config({
		baseUrl: "js/lib",
		paths: {
			app: "../app",
			jquery: "jquery-2.1.0.min",
			gsap: "TweenMax.min",
			three: "three.min",
			datgui: "dat.gui.min"
		}
	}), requirejs(["app/loading", "matter", "jquery", "datgui", "three", "gsap"], function(e) {
		var t = $("html").hasClass("mobile"),
			n = null;
		n = document.createElement("audio"), n.src = "music.mp3", n.autobuffer = !0, n.load();
		var r = !1;
		n.addEventListener("progress", function() {
			$("html").hasClass("firefox") && !r && (l(), r = !0)
		}), n.addEventListener("error", function() {}), n.addEventListener("play", function() {}), n.addEventListener("ended", function() {
			n.play()
		}), n.addEventListener("canplay", function() {
			if($("html").hasClass("firefox")) return;
			l()
		});
		var t = $("html").hasClass("mobile");
		if(t) {
			var i = function() {
				var e = window.document,
					t = e.documentElement,
					n = t.requestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullScreen || t.msRequestFullscreen;
				try {
					n.call(t)
				} catch(r) {}
			};
			$(document).on("touchstart", i)
		}
		var s = !1,
			o = function() {
				switch(document.visibilityState) {
					case "hidden":
						if(n.paused) return;
						n.pause(), s = !0;
						break;
					case "visible":
						if(!s) return;
						n.play(), s = !1
				}
			};
		$(document).on("visibilitychange", o);
		var u = function() {
				if(t) {
					$(".load-progress").hide(), $(".load-mobile-prompt").show(), TweenLite.to($(".loader"), .5, {
						opacity: 0,
						scale: 1.05,
						ease: Power1.easeInOut
					});
					var r = function() {
						$(document).off("touchstart", r), n.play(), setTimeout(function() {
							e.exit()
						}, 500), setTimeout(function() {
							p.enabled = !0
						}, 1270)
					};
					$(document).on("touchstart", r);
					return
				}
				n.play(), setTimeout(function() {
					e.exit()
				}, 500), setTimeout(function() {
					p.enabled = !0
				}, 1270)
			},
			a = 12,
			f = 0,
			l = function() {
				f++, e.update(f / a), f == a && u()
			},
			c = window.innerWidth,
			h = window.innerHeight,
			p = null,
			d = {
				override: !1,
				pause: !1,
				timing: 675,
				x: .1,
				y: .1,
				rock: .1,
				xOffset: .01,
				scale: 55
			};
		if(location.search.split("?")[1] == "dev") {
			var v = new dat.GUI;
			v.add(d, "override").name("Override"), v.add(d, "pause").name("Pause"), v.add(d, "x", 0, 3).name("Gravity x"), v.add(d, "y", 0, 3).name("Gravity y"), v.add(d, "rock", 0, .5).name("Sway"), v.add(d, "timing", 0, 2e3).name("Timing (ms)")
		} else console.log("\nMade by NATHAN GORDON\nhttps://twitter.com/gordonnl\n"), console.log("\nArt directed by PASCAL VAN DER HAAR\nhttps://twitter.com/Pascalsetsail\n"), console.log("\nIllustration by JONO YUEN\nhttps://twitter.com/jonoyuen\n"), console.log("\nAdd ?dev and check out the guts\nhttp://pablotheflamingo.com?dev\n"), console.log("%c\nLibraries used are:\nMatterJs http://brm.io/matter-js/\nThreeJs http://threejs.org/\nGSAP http://greensock.com/gsap\n", "line-height: 17px;");
		var m = new THREE.PerspectiveCamera(35, c / h, 1, 1e4);
		m.position.x = 0, m.position.y = 4.5, m.position.z = 15, m.target = new THREE.Vector3(-15, 30, 0), m.lookAt(m.target);
		var g = new THREE.Scene,
			y = new THREE.WebGLRenderer({
				antialias: !0,
				alpha: !0,
				preserveDrawingBuffer: !0
			});
		y.setSize(c, h), y.domElement.className = "pablo", document.querySelectorAll(".scene")[0].insertBefore(y.domElement, document.querySelectorAll("nav")[0]);
		var b = y.context;
		rtTexture = new THREE.WebGLRenderTarget(c, h, {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.NearestFilter,
			format: THREE.RGBAFormat
		});
		var w = document.createElement("canvas"),
			E = w.getContext("2d");
		w.width = 1024, w.height = 1024;
		var S = new THREE.Texture(w);
		S.minFilter = THREE.LinearFilter, S.magFilter = THREE.LinearFilter;
		var x = new THREE.MeshBasicMaterial({
				map: S,
				skinning: !0,
				transparent: !0
			}),
			T = function(e, t) {
				E.clearRect(0, 0, 1024, 1024), E.drawImage(C[0], 0, 0, 1024, 1024), e && E.drawImage(C[e], 637, 100, 100, 137), t && E.drawImage(C[t], 310, 100, 313, 313), S.needsUpdate = !0
			},
			N = ["img/pablo.png", "img/pablo-eye_angry.png", "img/pablo-eye_open.png", "img/pablo-eye_cute.png", "img/pablo-eye_dazed.png", "img/pablo-eye_look.png", "img/pablo-eye_rock.png", "img/pablo-eye_shock.png", "img/pablo-mouth_frown.png", "img/pablo-mouth_smile.png"],
			C = [];
		loadCount = 0;
		var k = function(e, t) {
			var n = new Image;
			n.onload = function() {
				l(), C[t] = n, loadCount++, loadCount == N.length && T()
			}, n.src = e
		};
		for(var L = 0; L < N.length; L++) k(N[L], L);
		var A = null,
			O = new THREE.Object3D;
		(new THREE.JSONLoader).load("js/pabloJSON.js", function(e, t) {
			l(), A = new THREE.SkinnedMesh(e, x), A.position.y = 3, O.add(A), g.add(O)
		});
		var M = Matter.Bodies,
			_ = Matter.Common,
			D = Matter.Composites,
			P = Matter.Constraint,
			H = Matter.Engine,
			B = Matter.Events,
			j = Matter.MouseConstraint,
			F = Matter.World,
			I = Matter.Sleeping;
		p = H.create($(".scene")[0], {
			render: {
				options: {
					wireframes: !0
				}
			}
		}), p.render.canvas.className += "debug", location.search.split("?")[1] == "dev" && (p.render.canvas.style.display = "block");
		var q = M.rectangle(400, 625, 800, 50, {
				isStatic: !0
			}),
			R = D.softBody(340, 240, 2, 6, 0, 0, !0, 30, {}, {}),
			U = D.softBody(160, 120, 5, 2, 0, 0, !0, 30, {}, {}),
			z = R.bodies.concat(U.bodies),
			W = j.create(p, {
				constraint: {
					stiffness: .1
				}
			}),
			X = P.create({
				pointA: {
					x: 0,
					y: 0
				},
				pointB: {
					x: 0,
					y: 0
				},
				stiffness: .3,
				angularStiffness: 1,
				render: {
					strokeStyle: "#90EE90"
				}
			}),
			V = P.create({
				pointA: {
					x: 0,
					y: 0
				},
				pointB: {
					x: 0,
					y: 0
				},
				stiffness: .4,
				angularStiffness: 1,
				render: {
					strokeStyle: "#90EE90"
				}
			}),
			J = function(e, t, n) {
				return P.create({
					pointA: {
						x: e,
						y: t
					},
					bodyB: n,
					stiffness: 1
				})
			},
			K = J(370, 570, R.bodies[R.bodies.length - 2]),
			Q = J(430, 570, R.bodies[R.bodies.length - 1]),
			G = function(e, t) {
				return P.create({
					bodyA: e,
					bodyB: t,
					stiffness: 1
				})
			},
			Y = G(U.bodies[8], R.bodies[0]),
			Z = G(U.bodies[9], R.bodies[1]),
			et = G(U.bodies[9], R.bodies[0]),
			tt = G(U.bodies[8], R.bodies[1]);
		F.add(p.world, [W, X, V, q, R, U, K, Q, Y, Z, et, tt]);
		var nt = [R.bodies[9], R.bodies[5], R.bodies[1], U.bodies[4]],
			rt = [
				[R.bodies[8], R.bodies[9]],
				[R.bodies[4], R.bodies[5]],
				[R.bodies[0], R.bodies[1]],
				[U.bodies[0], U.bodies[4]]
			],
			it = function(e, t) {
				var n = t.position.y - e.position.y,
					r = t.position.x - e.position.x;
				return -Math.atan2(n, r)
			};
		H.run(p), p.enabled = !1, B.on(p, "tick", function(e) {
			p.timing.timestamp < 4e3 && (m.target.x += (0 - m.target.x) / 40, m.target.y += (5.5 - m.target.y) / 40, m.lookAt(m.target)), p.world.gravity.y = d.y * Math.sin(20 * e.timestamp / (Math.PI * d.timing)), p.world.gravity.x = d.x * Math.sin(20 * e.timestamp / 2 / (Math.PI * d.timing) - 1 * Math.PI / 1) - d.xOffset, O.rotation.x = d.rock * Math.sin(20 * e.timestamp / 2 / (Math.PI * d.timing));
			if(!A) return;
			for(var t = 0; t < A.skeleton.bones.length - 1; t++) A.skeleton.bones[t].position.x = (nt[t].position.x - 400) / d.scale, A.skeleton.bones[t].position.y = (360 - nt[t].position.y) / d.scale, A.skeleton.bones[t].rotation.z = it(rt[t][0], rt[t][1]);
			y.render(g, m);
			if(d.override) return;
			d.pause ? (d.x += (0 - d.x) / 10, d.y += (0 - d.y) / 10, d.rock += (0 - d.rock) / 10) : (d.x += (.5 * Math.sin(20 * p.timing.timestamp / (Math.PI * 17 * 1e3)) + 1 - d.x) / 20, d.y += (.5 * Math.sin(20 * p.timing.timestamp / (Math.PI * 42 * 1e3)) + 1.25 - d.y) / 20, d.rock += (.1 * Math.sin(20 * p.timing.timestamp / (Math.PI * 30 * 1e3)) + .2 - d.rock) / 20);
			if(v)
				for(t in v.__controllers) v.__controllers[t].updateDisplay()
		}), $(".prompt").on("mouseenter", function() {
			if(t) return;
			$(this).addClass("hover")
		}), $(".prompt").on("mouseleave", function() {
			if(t) return;
			$(this).removeClass("hover")
		});
		var st = function(e, t) {
			if(d.pause) return;
			T(e, t)
		};
		$(".share-prompt").on("mouseenter", function() {
			if(t) return;
			st(2, 9)
		}), $(".adopt-prompt").on("mouseenter", function() {
			if(t) return;
			st(4, 9)
		}), $(".prompt").on("mouseleave", function() {
			if(t) return;
			st(6, 9)
		});
		var ot = $("<div />"),
			ut = function() {
				if(d.pause) return;
				TweenLite.set($(this).find(".button"), {
					boxShadow: "0px 0px 0px 0pt rgba(75, 52, 10, 0.3)"
				}), TweenLite.to($(this).find(".button"), .5, {
					boxShadow: "0px 0px 0px 10pt rgba(75, 52, 10, 0)",
					ease: Power1.easeOut
				}), $(".mute-prompt").off("click", ut), $(this).toggleClass("active"), $(this).find(".button").html("&#xe003;"), $(this).find(".label").html("Sound | off"), d.pause = !0, n.pause(), X.pointA = {
					x: U.bodies[4].position.x + 1,
					y: U.bodies[4].position.y + 1
				}, X.bodyB = U.bodies[4], X.angleB = 0, X.pointB = {
					x: 0,
					y: 0
				}, V.pointA = {
					x: U.bodies[5].position.x + 1,
					y: U.bodies[5].position.y + 1
				}, V.bodyB = U.bodies[5], V.angleB = 0, V.pointB = {
					x: 0,
					y: 0
				};
				var e = (46 - c / 2) / (h / .75) * 800 + 400,
					t = (.7 * h - 70) / h * 600,
					r = new TimelineMax({
						onComplete: function() {
							X.bodyB = null, X.pointA = {
								x: 0,
								y: 0
							}, X.pointB = {
								x: 0,
								y: 0
							}, V.bodyB = null, V.pointA = {
								x: 0,
								y: 0
							}, V.pointB = {
								x: 0,
								y: 0
							}, $(".mute-prompt").on("click", ut)
						},
						onUpdate: function() {
							V.pointA.x = ot[0]._gsTransform.rotationX, V.pointA.y = ot[0]._gsTransform.rotationY, X.pointA.x = ot[0]._gsTransform.x, X.pointA.y = ot[0]._gsTransform.y
						}
					});
				r.add([TweenLite.set(ot, {
					x: X.pointA.x + 1,
					y: X.pointA.y + 1
				}), TweenLite.set(ot, {
					rotationX: V.pointA.x + 1,
					rotationY: V.pointA.y + 1
				}), TweenLite.to(ot, 3, {
					x: e + 200,
					y: t - 180,
					ease: Power1.easeInOut,
					delay: 2
				}), TweenLite.to(ot, 3, {
					rotationX: e - 40,
					rotationY: t - 120,
					ease: Power1.easeInOut,
					delay: 2
				})]), r.add([TweenLite.to(ot, 1, {
					x: "+=40",
					y: "-=40",
					ease: Power1.easeInOut
				}), TweenLite.to(ot, 1, {
					rotationX: "+=40",
					rotationY: "-=120",
					ease: Power1.easeInOut
				})]), r.add([TweenLite.to(ot, .2, {
					x: e + 180,
					y: t - 180,
					ease: Power1.easeIn
				}), TweenLite.to(ot, .2, {
					rotationX: e - 60,
					rotationY: t - 120,
					ease: Power1.easeIn
				}), TweenLite.to(ot, .1, {
					rotationX: "+=0",
					delay: .2
				})]), r.add([TweenLite.to(ot, 1, {
					x: 430,
					y: 150,
					ease: Power1.easeOut
				}), TweenLite.to(ot, 1, {
					rotationX: 190,
					ease: Power1.easeOut
				}), TweenLite.to(ot, .3, {
					rotationY: 70,
					ease: Power1.easeOut
				}), TweenLite.to(ot, .7, {
					rotationY: 210,
					ease: Power1.easeInOut,
					delay: .3
				})]), T(7, 8), r.addCallback(function() {
					T(5, 8)
				}, 1.3), r.addCallback(function() {
					T(7, 8)
				}, 1.6), r.addCallback(function() {
					T(5, 8)
				}, 2.2), r.addCallback(function() {
					T(1, 8)
				}, 4.2), r.addCallback(function() {
					T(6, 9), d.pause = !1, n.play(), $(".mute-prompt").toggleClass("active"), $(".mute-prompt .button").html("&#xe002;"), $(".mute-prompt .label").html("Sound | on"), TweenLite.set($(".mute-prompt .button"), {
						boxShadow: "0px 0px 0px 0pt rgba(75, 52, 10, 0.3)"
					}), TweenLite.to($(".mute-prompt .button"), .5, {
						boxShadow: "0px 0px 0px 10pt rgba(75, 52, 10, 0)",
						ease: Power1.easeOut
					})
				}, 6.2)
			};
		$(".mute-prompt").on("click", ut);
		var at = function() {
			$(".share-prompt").off("click", at), $(".share-prompt").toggleClass("active"), TweenLite.set($(".share-prompt .button"), {
				boxShadow: "0px 0px 0px 0pt rgba(75, 52, 10, 0.3)"
			}), TweenLite.to($(".share-prompt .button"), .5, {
				boxShadow: "0px 0px 0px 10pt rgba(75, 52, 10, 0)",
				ease: Power1.easeOut
			}), TweenLite.set($(".network"), {
				x: -42,
				rotation: -120,
				opacity: 0,
				display: "block"
			}), TweenMax.staggerTo($(".network"), .3, {
				x: 0,
				rotation: 0,
				opacity: 1,
				ease: Back.easeOut
			}, .05), clearShare = function() {
				$(document).off("touchstart click", clearShare), setTimeout(function() {
					$(".share-prompt").on("click", at)
				}, 0), $(".share-prompt").toggleClass("active"), TweenMax.staggerTo($(".network"), .15, {
					x: 10,
					opacity: 0,
					ease: Power1.easeOut
				}, .05)
			}, setTimeout(function() {
				$(document).on("touchstart click", clearShare)
			}, 0)
		};
		$(".share-prompt").on("click", at);
		var ft = new Uint8Array(4),
			lt, ct = function() {
				$(document).off("mousemove", ht), $(document).off("mouseup", ct), $(document).off("touchmove", ht), $(document).off("touchend", ct), X.bodyB = null, X.pointA = {
					x: 0,
					y: 0
				}, X.pointB = {
					x: 0,
					y: 0
				}, T(6, 9)
			},
			ht = function(e) {
				e = e.type == "touchmove" ? e.originalEvent.touches[0] : e, X.pointA.x = (e.clientX - c / 2) / (h / .75) * 800 + 400, X.pointA.y = e.clientY / h * 600
			},
			pt = function(e) {
				if(d.pause) return;
				e.type == "touchstart" && e.preventDefault(), e = e.type == "touchstart" ? e.originalEvent.touches[0] : e, y.render(g, m, rtTexture, !0), lt = rtTexture.__webglFramebuffer, b.bindFramebuffer(b.FRAMEBUFFER, lt), b.viewport(e.clientX, h - e.clientY, 1, 1), b.readPixels(e.clientX, h - e.clientY, 1, 1, b.RGBA, b.UNSIGNED_BYTE, ft), b.bindFramebuffer(b.FRAMEBUFFER, null);
				if(!ft[3]) return;
				T(2, 8), X.pointA.x = (e.clientX - c / 2) / (h / .75) * 800 + 400, X.pointA.y = e.clientY / h * 600, e.clientY < h / 2 ? X.bodyB = U.bodies[3] : X.bodyB = R.bodies[5], X.angleB = 0, X.pointB = {
					x: X.pointA.x - X.bodyB.position.x,
					y: X.pointA.y - X.bodyB.position.y
				}, $(document).on("mousemove", ht), $(document).on("mouseup", ct), $(document).on("touchmove", ht), $(document).on("touchend", ct)
			};
		$(y.domElement).on("mousedown", pt), $(y.domElement).on("touchstart", pt), $(window).on("resize", function() {
			c = window.innerWidth, h = window.innerHeight, y.setSize(c, h), m.aspect = c / h, m.updateProjectionMatrix(), rtTexture.setSize(c, h)
		})
	}), define("../app", function() {});